#!/usr/bin/env node
// Bundled MCP Server for Mim
// Built with esbuild - all dependencies included

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs
var sdk_exports = {};
__export(sdk_exports, {
  AbortError: () => F1,
  EXIT_REASONS: () => dU,
  HOOK_EVENTS: () => pU,
  createSdkMcpServer: () => ZE,
  query: () => o_,
  tool: () => SE,
  unstable_v2_createSession: () => t_,
  unstable_v2_prompt: () => s_,
  unstable_v2_resumeSession: () => a_
});
function N6(X = BK) {
  let Q = new AbortController();
  return (0, import_events.setMaxListeners)(X, Q.signal), Q;
}
function FK(X) {
  var Q = LK.call(X, e6), $ = X[e6];
  try {
    X[e6] = void 0;
    var Y = true;
  } catch (J) {
  }
  var W = qK.call(X);
  if (Y) if (Q) X[e6] = $;
  else delete X[e6];
  return W;
}
function DK(X) {
  return OK.call(X);
}
function MK(X) {
  if (X == null) return X === void 0 ? wK : AK;
  return D7 && D7 in Object(X) ? N7(X) : O7(X);
}
function jK(X) {
  var Q = typeof X;
  return X != null && (Q == "object" || Q == "function");
}
function PK(X) {
  if (!z4(X)) return false;
  var Q = A7(X);
  return Q == EK || Q == IK || Q == RK || Q == bK;
}
function ZK(X) {
  return !!M7 && M7 in X;
}
function vK(X) {
  if (X != null) {
    try {
      return kK.call(X);
    } catch (Q) {
    }
    try {
      return X + "";
    } catch (Q) {
    }
  }
  return "";
}
function uK(X) {
  if (!z4(X) || j7(X)) return false;
  var Q = w7(X) ? hK : _K;
  return Q.test(R7(X));
}
function lK(X, Q) {
  return X == null ? void 0 : X[Q];
}
function mK(X, Q) {
  var $ = I7(X, Q);
  return E7($) ? $ : void 0;
}
function pK() {
  this.__data__ = q1 ? q1(null) : {}, this.size = 0;
}
function dK(X) {
  var Q = this.has(X) && delete this.__data__[X];
  return this.size -= Q ? 1 : 0, Q;
}
function oK(X) {
  var Q = this.__data__;
  if (q1) {
    var $ = Q[X];
    return $ === iK ? void 0 : $;
  }
  return rK.call(Q, X) ? Q[X] : void 0;
}
function sK(X) {
  var Q = this.__data__;
  return q1 ? Q[X] !== void 0 : aK.call(Q, X);
}
function XU(X, Q) {
  var $ = this.__data__;
  return this.size += this.has(X) ? 0 : 1, $[X] = q1 && Q === void 0 ? eK : Q, this;
}
function A6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
function QU() {
  this.__data__ = [], this.size = 0;
}
function $U(X, Q) {
  return X === Q || X !== X && Q !== Q;
}
function YU(X, Q) {
  var $ = X.length;
  while ($--) if (v7(X[$][0], Q)) return $;
  return -1;
}
function GU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  if ($ < 0) return false;
  var Y = Q.length - 1;
  if ($ == Y) Q.pop();
  else JU.call(Q, $, 1);
  return --this.size, true;
}
function HU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  return $ < 0 ? void 0 : Q[$][1];
}
function BU(X) {
  return Z1(this.__data__, X) > -1;
}
function zU(X, Q) {
  var $ = this.__data__, Y = Z1($, X);
  if (Y < 0) ++this.size, $.push([X, Q]);
  else $[Y][1] = Q;
  return this;
}
function w6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
function UU() {
  this.size = 0, this.__data__ = { hash: new W9(), map: new (f7 || g7)(), string: new W9() };
}
function VU(X) {
  var Q = typeof X;
  return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? X !== "__proto__" : X === null;
}
function LU(X, Q) {
  var $ = X.__data__;
  return u7(Q) ? $[typeof Q == "string" ? "string" : "hash"] : $.map;
}
function qU(X) {
  var Q = C1(this, X).delete(X);
  return this.size -= Q ? 1 : 0, Q;
}
function FU(X) {
  return C1(this, X).get(X);
}
function NU(X) {
  return C1(this, X).has(X);
}
function OU(X, Q) {
  var $ = C1(this, X), Y = $.size;
  return $.set(X, Q), this.size += $.size == Y ? 0 : 1, this;
}
function M6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
function G9(X, Q) {
  if (typeof X != "function" || Q != null && typeof Q != "function") throw TypeError(DU);
  var $ = function() {
    var Y = arguments, W = Q ? Q.apply(this, Y) : Y[0], J = $.cache;
    if (J.has(W)) return J.get(W);
    var G = X.apply(this, Y);
    return $.cache = J.set(W, G) || J, G;
  };
  return $.cache = new (G9.Cache || J9)(), $;
}
function AU(X, Q) {
  if (X.destroyed) return;
  X.write(Q);
}
function d7(X) {
  AU(process.stderr, X);
}
function wU(X) {
  let Q = [], $ = X.match(/^MCP server ["']([^"']+)["']/);
  if ($ && $[1]) Q.push("mcp"), Q.push($[1].toLowerCase());
  else {
    let J = X.match(/^([^:[]+):/);
    if (J && J[1]) Q.push(J[1].trim().toLowerCase());
  }
  let Y = X.match(/^\[([^\]]+)]/);
  if (Y && Y[1]) Q.push(Y[1].trim().toLowerCase());
  if (X.toLowerCase().includes("statsig event:")) Q.push("statsig");
  let W = X.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (W && W[1]) {
    let J = W[1].trim().toLowerCase();
    if (J.length < 30 && !J.includes(" ")) Q.push(J);
  }
  return Array.from(new Set(Q));
}
function MU(X, Q) {
  if (!Q) return true;
  if (X.length === 0) return false;
  if (Q.isExclusive) return !X.some(($) => Q.exclude.includes($));
  else return X.some(($) => Q.include.includes($));
}
function n7(X, Q) {
  if (!Q) return true;
  let $ = wU(X);
  return MU($, Q);
}
function V4() {
  return process.env.CLAUDE_CONFIG_DIR ?? (0, import_path2.join)((0, import_os.homedir)(), ".claude");
}
function H9(X) {
  if (!X) return false;
  if (typeof X === "boolean") return X;
  let Q = X.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(Q);
}
function r7(X) {
  return { name: X, default: 3e4, validate: (Q) => {
    if (!Q) return { effective: 3e4, status: "valid" };
    let $ = parseInt(Q, 10);
    if (isNaN($) || $ <= 0) return { effective: 3e4, status: "invalid", message: `Invalid value "${Q}" (using default: 30000)` };
    if ($ > 15e4) return { effective: 15e4, status: "capped", message: `Capped from ${$} to 150000` };
    return { effective: $, status: "valid" };
  } };
}
function PU() {
  let X = "";
  if (typeof process < "u" && typeof process.cwd === "function") X = (0, import_fs.realpathSync)((0, import_process.cwd)());
  return { originalCwd: X, projectRoot: X, totalCostUSD: 0, totalAPIDuration: 0, totalAPIDurationWithoutRetries: 0, totalToolDuration: 0, startTime: Date.now(), lastInteractionTime: Date.now(), totalLinesAdded: 0, totalLinesRemoved: 0, hasUnknownModelCost: false, cwd: X, modelUsage: {}, mainLoopModelOverride: void 0, initialMainLoopModel: null, modelStrings: null, isInteractive: false, clientType: "cli", sessionIngressToken: void 0, oauthTokenFromFd: void 0, apiKeyFromFd: void 0, flagSettingsPath: void 0, allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"], meter: null, sessionCounter: null, locCounter: null, prCounter: null, commitCounter: null, costCounter: null, tokenCounter: null, codeEditToolDecisionCounter: null, activeTimeCounter: null, sessionId: (0, import_crypto.randomUUID)(), parentSessionId: void 0, loggerProvider: null, eventLogger: null, meterProvider: null, tracerProvider: null, agentColorMap: /* @__PURE__ */ new Map(), agentColorIndex: 0, envVarValidators: [o7, t7], lastAPIRequest: null, inMemoryErrorLog: [], inlinePlugins: [], useCoworkPlugins: false, sessionBypassPermissionsMode: false, sessionTrustAccepted: false, sessionPersistenceDisabled: false, hasExitedPlanMode: false, needsPlanModeExitAttachment: false, hasExitedDelegateMode: false, needsDelegateModeExitAttachment: false, lspRecommendationShownThisSession: false, initJsonSchema: null, registeredHooks: null, planSlugCache: /* @__PURE__ */ new Map(), teleportedSessionInfo: null, invokedSkills: /* @__PURE__ */ new Map(), slowOperations: [], sdkBetas: void 0, mainThreadAgentType: void 0, isRemoteMode: false, additionalDirectoriesForClaudeMd: [], resumedTranscriptPath: null };
}
function a7() {
  return SU.sessionId;
}
function s7({ writeFn: X, flushIntervalMs: Q = 1e3, maxBufferSize: $ = 100, immediateMode: Y = false }) {
  let W = [], J = null;
  function G() {
    if (J) clearTimeout(J), J = null;
  }
  function H() {
    if (W.length === 0) return;
    X(W.join("")), W = [], G();
  }
  function B() {
    if (!J) J = setTimeout(H, Q);
  }
  return { write(z2) {
    if (Y) {
      X(z2);
      return;
    }
    if (W.push(z2), B(), W.length >= $) H();
  }, flush: H, dispose() {
    H();
  } };
}
function XW(X) {
  return e7.add(X), () => e7.delete(X);
}
function ZU(X) {
  if (X === null) return "null";
  if (X === void 0) return "undefined";
  if (Array.isArray(X)) return `Array[${X.length}]`;
  if (typeof X === "object") return `Object{${Object.keys(X).length} keys}`;
  if (typeof X === "string") return `string(${X.length} chars)`;
  return typeof X;
}
function QW(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
function Z0(X, Q, $) {
  let Y = ZU(X);
  return QW(`JSON.stringify(${Y})`, () => JSON.stringify(X, Q, $));
}
function vU(X) {
  if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return false;
  let Q = kU();
  return n7(X, Q);
}
function _U() {
  if (!q4) q4 = s7({ writeFn: (X) => {
    let Q = JW();
    if (!n0().existsSync((0, import_path3.dirname)(Q))) n0().mkdirSync((0, import_path3.dirname)(Q));
    n0().appendFileSync(Q, X), xU();
  }, flushIntervalMs: 1e3, maxBufferSize: 100, immediateMode: CU() }), XW(async () => q4?.dispose());
  return q4;
}
function v1(X, { level: Q } = { level: "debug" }) {
  if (!vU(X)) return;
  if (TU && X.includes(`
`)) X = Z0(X);
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} [${Q.toUpperCase()}] ${X.trim()}
`;
  if (YW()) {
    d7(Y);
    return;
  }
  _U().write(Y);
}
function JW() {
  return WW() ?? process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? (0, import_path3.join)(V4(), "debug", `${a7()}.txt`);
}
function F0(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
function n0() {
  return cU;
}
function j6() {
  return process.versions.bun !== void 0;
}
function tU() {
  if (HW) return F4;
  if (HW = true, !process.env.DEBUG_CLAUDE_AGENT_SDK) return null;
  let X = (0, import_path4.join)(V4(), "debug");
  if (F4 = (0, import_path4.join)(X, `sdk-${(0, import_crypto2.randomUUID)()}.txt`), !(0, import_fs2.existsSync)(X)) (0, import_fs2.mkdirSync)(X, { recursive: true });
  return process.stderr.write(`SDK debug logs: ${F4}
`), F4;
}
function N1(X) {
  let Q = tU();
  if (!Q) return;
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} ${X}
`;
  (0, import_fs2.appendFileSync)(Q, Y);
}
function BW(X, Q) {
  let $ = { ...X };
  if (Q) {
    let Y = { sandbox: Q };
    if ($.settings) try {
      Y = { ...L4($.settings), sandbox: Q };
    } catch {
    }
    $.settings = Z0(Y);
  }
  return $;
}
function eU(X) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some(($) => X.endsWith($));
}
function V9(X) {
  return new U9(X);
}
function KW(X, Q) {
  return new U9({ ...Q, resume: X });
}
function YX() {
  return YV;
}
function b(X, Q) {
  let $ = YX(), Y = N4({ issueData: Q, data: X.data, path: X.path, errorMaps: [X.common.contextualErrorMap, X.schemaErrorMap, $, $ === T1 ? void 0 : T1].filter((W) => !!W) });
  X.common.issues.push(Y);
}
function l(X) {
  if (!X) return {};
  let { errorMap: Q, invalid_type_error: $, required_error: Y, description: W } = X;
  if (Q && ($ || Y)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (Q) return { errorMap: Q, description: W };
  return { errorMap: (G, H) => {
    let { message: B } = X;
    if (G.code === "invalid_enum_value") return { message: B ?? H.defaultError };
    if (typeof H.data > "u") return { message: B ?? Y ?? H.defaultError };
    if (G.code !== "invalid_type") return { message: H.defaultError };
    return { message: B ?? $ ?? H.defaultError };
  }, description: W };
}
function qW(X) {
  let Q = "[0-5]\\d";
  if (X.precision) Q = `${Q}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Q = `${Q}(\\.\\d+)?`;
  let $ = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Q})${$}`;
}
function wV(X) {
  return new RegExp(`^${qW(X)}$`);
}
function MV(X) {
  let Q = `${LW}T${qW(X)}`, $ = [];
  if ($.push(X.local ? "Z?" : "Z"), X.offset) $.push("([+-]\\d{2}:?\\d{2})");
  return Q = `${Q}(${$.join("|")})`, new RegExp(`^${Q}$`);
}
function jV(X, Q) {
  if ((Q === "v4" || !Q) && LV.test(X)) return true;
  if ((Q === "v6" || !Q) && FV.test(X)) return true;
  return false;
}
function RV(X, Q) {
  if (!zV.test(X)) return false;
  try {
    let [$] = X.split(".");
    if (!$) return false;
    let Y = $.replace(/-/g, "+").replace(/_/g, "/").padEnd($.length + (4 - $.length % 4) % 4, "="), W = JSON.parse(atob(Y));
    if (typeof W !== "object" || W === null) return false;
    if ("typ" in W && W?.typ !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && W.alg !== Q) return false;
    return true;
  } catch {
    return false;
  }
}
function EV(X, Q) {
  if ((Q === "v4" || !Q) && qV.test(X)) return true;
  if ((Q === "v6" || !Q) && NV.test(X)) return true;
  return false;
}
function IV(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
function E6(X) {
  if (X instanceof V0) {
    let Q = {};
    for (let $ in X.shape) {
      let Y = X.shape[$];
      Q[$] = G1.create(E6(Y));
    }
    return new V0({ ...X._def, shape: () => Q });
  } else if (X instanceof J1) return new J1({ ...X._def, type: E6(X.element) });
  else if (X instanceof G1) return G1.create(E6(X.unwrap()));
  else if (X instanceof _1) return _1.create(E6(X.unwrap()));
  else if (X instanceof M1) return M1.create(X.items.map((Q) => E6(Q)));
  else return X;
}
function N9(X, Q) {
  let $ = O1(X), Y = O1(Q);
  if (X === Q) return { valid: true, data: X };
  else if ($ === E.object && Y === E.object) {
    let W = n.objectKeys(Q), J = n.objectKeys(X).filter((H) => W.indexOf(H) !== -1), G = { ...X, ...Q };
    for (let H of J) {
      let B = N9(X[H], Q[H]);
      if (!B.valid) return { valid: false };
      G[H] = B.data;
    }
    return { valid: true, data: G };
  } else if ($ === E.array && Y === E.array) {
    if (X.length !== Q.length) return { valid: false };
    let W = [];
    for (let J = 0; J < X.length; J++) {
      let G = X[J], H = Q[J], B = N9(G, H);
      if (!B.valid) return { valid: false };
      W.push(B.data);
    }
    return { valid: true, data: W };
  } else if ($ === E.date && Y === E.date && +X === +Q) return { valid: true, data: X };
  else return { valid: false };
}
function FW(X, Q) {
  return new a1({ values: X, typeName: j.ZodEnum, ...l(Q) });
}
function O(X, Q, $) {
  function Y(H, B) {
    var z2;
    Object.defineProperty(H, "_zod", { value: H._zod ?? {}, enumerable: false }), (z2 = H._zod).traits ?? (z2.traits = /* @__PURE__ */ new Set()), H._zod.traits.add(X), Q(H, B);
    for (let K in G.prototype) if (!(K in H)) Object.defineProperty(H, K, { value: G.prototype[K].bind(H) });
    H._zod.constr = G, H._zod.def = B;
  }
  let W = $?.Parent ?? Object;
  class J extends W {
  }
  Object.defineProperty(J, "name", { value: X });
  function G(H) {
    var B;
    let z2 = $?.Parent ? new J() : this;
    Y(z2, H), (B = z2._zod).deferred ?? (B.deferred = []);
    for (let K of z2._zod.deferred) K();
    return z2;
  }
  return Object.defineProperty(G, "init", { value: Y }), Object.defineProperty(G, Symbol.hasInstance, { value: (H) => {
    if ($?.Parent && H instanceof $.Parent) return true;
    return H?._zod?.traits?.has(X);
  } }), Object.defineProperty(G, "name", { value: X }), G;
}
function u0(X) {
  if (X) Object.assign(I4, X);
  return I4;
}
function SV(X) {
  return X;
}
function ZV(X) {
  return X;
}
function CV(X) {
}
function kV(X) {
  throw Error();
}
function vV(X) {
}
function DX(X) {
  let Q = Object.values(X).filter((Y) => typeof Y === "number");
  return Object.entries(X).filter(([Y, W]) => Q.indexOf(+Y) === -1).map(([Y, W]) => W);
}
function b4(X, Q = "|") {
  return X.map(($) => S4($)).join(Q);
}
function w9(X, Q) {
  if (typeof Q === "bigint") return Q.toString();
  return Q;
}
function AX(X) {
  return { get value() {
    {
      let $ = X();
      return Object.defineProperty(this, "value", { value: $ }), $;
    }
    throw Error("cached value already set");
  } };
}
function wX(X) {
  return X === null || X === void 0;
}
function MX(X) {
  let Q = X.startsWith("^") ? 1 : 0, $ = X.endsWith("$") ? X.length - 1 : X.length;
  return X.slice(Q, $);
}
function M9(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
function Y0(X, Q, $) {
  Object.defineProperty(X, Q, { get() {
    {
      let W = $();
      return X[Q] = W, W;
    }
    throw Error("cached value already set");
  }, set(W) {
    Object.defineProperty(X, Q, { value: W });
  }, configurable: true });
}
function j9(X, Q, $) {
  Object.defineProperty(X, Q, { value: $, writable: true, enumerable: true, configurable: true });
}
function TV(X, Q) {
  if (!Q) return X;
  return Q.reduce(($, Y) => $?.[Y], X);
}
function _V(X) {
  let Q = Object.keys(X), $ = Q.map((Y) => X[Y]);
  return Promise.all($).then((Y) => {
    let W = {};
    for (let J = 0; J < Q.length; J++) W[Q[J]] = Y[J];
    return W;
  });
}
function xV(X = 10) {
  let $ = "";
  for (let Y = 0; Y < X; Y++) $ += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return $;
}
function s1(X) {
  return JSON.stringify(X);
}
function Z6(X) {
  return typeof X === "object" && X !== null && !Array.isArray(X);
}
function C6(X) {
  if (Z6(X) === false) return false;
  let Q = X.constructor;
  if (Q === void 0) return true;
  let $ = Q.prototype;
  if (Z6($) === false) return false;
  if (Object.prototype.hasOwnProperty.call($, "isPrototypeOf") === false) return false;
  return true;
}
function yV(X) {
  let Q = 0;
  for (let $ in X) if (Object.prototype.hasOwnProperty.call(X, $)) Q++;
  return Q;
}
function y1(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function l0(X, Q, $) {
  let Y = new X._zod.constr(Q ?? X._zod.def);
  if (!Q || $?.parent) Y._zod.parent = X;
  return Y;
}
function y(X) {
  let Q = X;
  if (!Q) return {};
  if (typeof Q === "string") return { error: () => Q };
  if (Q?.message !== void 0) {
    if (Q?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    Q.error = Q.message;
  }
  if (delete Q.message, typeof Q.error === "string") return { ...Q, error: () => Q.error };
  return Q;
}
function fV(X) {
  let Q;
  return new Proxy({}, { get($, Y, W) {
    return Q ?? (Q = X()), Reflect.get(Q, Y, W);
  }, set($, Y, W, J) {
    return Q ?? (Q = X()), Reflect.set(Q, Y, W, J);
  }, has($, Y) {
    return Q ?? (Q = X()), Reflect.has(Q, Y);
  }, deleteProperty($, Y) {
    return Q ?? (Q = X()), Reflect.deleteProperty(Q, Y);
  }, ownKeys($) {
    return Q ?? (Q = X()), Reflect.ownKeys(Q);
  }, getOwnPropertyDescriptor($, Y) {
    return Q ?? (Q = X()), Reflect.getOwnPropertyDescriptor(Q, Y);
  }, defineProperty($, Y, W) {
    return Q ?? (Q = X()), Reflect.defineProperty(Q, Y, W);
  } });
}
function S4(X) {
  if (typeof X === "bigint") return X.toString() + "n";
  if (typeof X === "string") return `"${X}"`;
  return `${X}`;
}
function I9(X) {
  return Object.keys(X).filter((Q) => {
    return X[Q]._zod.optin === "optional" && X[Q]._zod.optout === "optional";
  });
}
function hV(X, Q) {
  let $ = {}, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    $[W] = Y.shape[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function uV(X, Q) {
  let $ = { ...X._zod.def.shape }, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    delete $[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function lV(X, Q) {
  if (!C6(Q)) throw Error("Invalid input to extend: expected a plain object");
  let $ = { ...X._zod.def, get shape() {
    let Y = { ...X._zod.def.shape, ...Q };
    return j9(this, "shape", Y), Y;
  }, checks: [] };
  return l0(X, $);
}
function mV(X, Q) {
  return l0(X, { ...X._zod.def, get shape() {
    let $ = { ...X._zod.def.shape, ...Q._zod.def.shape };
    return j9(this, "shape", $), $;
  }, catchall: Q._zod.def.catchall, checks: [] });
}
function cV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in Y)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  }
  else for (let J in Y) W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function pV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in W)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  }
  else for (let J in Y) W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function e1(X, Q = 0) {
  for (let $ = Q; $ < X.issues.length; $++) if (X.issues[$]?.continue !== true) return true;
  return false;
}
function B1(X, Q) {
  return Q.map(($) => {
    var Y;
    return (Y = $).path ?? (Y.path = []), $.path.unshift(X), $;
  });
}
function OX(X) {
  return typeof X === "string" ? X : X?.message;
}
function o0(X, Q, $) {
  let Y = { ...X, path: X.path ?? [] };
  if (!X.message) {
    let W = OX(X.inst?._zod.def?.error?.(X)) ?? OX(Q?.error?.(X)) ?? OX($.customError?.(X)) ?? OX($.localeError?.(X)) ?? "Invalid input";
    Y.message = W;
  }
  if (delete Y.inst, delete Y.continue, !Q?.reportInput) delete Y.input;
  return Y;
}
function AW(X) {
  if (X instanceof Set) return "set";
  if (X instanceof Map) return "map";
  if (X instanceof File) return "file";
  return "unknown";
}
function jX(X) {
  if (Array.isArray(X)) return "array";
  if (typeof X === "string") return "string";
  return "unknown";
}
function P9(...X) {
  let [Q, $, Y] = X;
  if (typeof Q === "string") return { message: Q, code: "custom", input: $, inst: Y };
  return { ...Q };
}
function dV(X) {
  return Object.entries(X).filter(([Q, $]) => {
    return Number.isNaN(Number.parseInt(Q, 10));
  }).map((Q) => Q[1]);
}
function S9(X, Q = ($) => $.message) {
  let $ = {}, Y = [];
  for (let W of X.issues) if (W.path.length > 0) $[W.path[0]] = $[W.path[0]] || [], $[W.path[0]].push(Q(W));
  else Y.push(Q(W));
  return { formErrors: Y, fieldErrors: $ };
}
function Z9(X, Q) {
  let $ = Q || function(J) {
    return J.message;
  }, Y = { _errors: [] }, W = (J) => {
    for (let G of J.issues) if (G.code === "invalid_union" && G.errors.length) G.errors.map((H) => W({ issues: H }));
    else if (G.code === "invalid_key") W({ issues: G.issues });
    else if (G.code === "invalid_element") W({ issues: G.issues });
    else if (G.path.length === 0) Y._errors.push($(G));
    else {
      let H = Y, B = 0;
      while (B < G.path.length) {
        let z2 = G.path[B];
        if (B !== G.path.length - 1) H[z2] = H[z2] || { _errors: [] };
        else H[z2] = H[z2] || { _errors: [] }, H[z2]._errors.push($(G));
        H = H[z2], B++;
      }
    }
  };
  return W(X), Y;
}
function kW() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
function lW(X) {
  return typeof X.precision === "number" ? X.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : X.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${X.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function mW(X) {
  return new RegExp(`^${lW(X)}$`);
}
function cW(X) {
  let Q = lW({ precision: X.precision }), $ = ["Z"];
  if (X.local) $.push("");
  if (X.offset) $.push("([+-]\\d{2}:\\d{2})");
  let Y = `${Q}(?:${$.join("|")})`;
  return new RegExp(`^${hW}T(?:${Y})$`);
}
function IJ(X) {
  if (X === "") return true;
  if (X.length % 4 !== 0) return false;
  try {
    return atob(X), true;
  } catch {
    return false;
  }
}
function nV(X) {
  if (!g9.test(X)) return false;
  let Q = X.replace(/[-_]/g, (Y) => Y === "-" ? "+" : "/"), $ = Q.padEnd(Math.ceil(Q.length / 4) * 4, "=");
  return IJ($);
}
function rV(X, Q = null) {
  try {
    let $ = X.split(".");
    if ($.length !== 3) return false;
    let [Y] = $;
    if (!Y) return false;
    let W = JSON.parse(atob(Y));
    if ("typ" in W && W?.typ !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && (!("alg" in W) || W.alg !== Q)) return false;
    return true;
  } catch {
    return false;
  }
}
function VJ(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
function k4(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
function LJ(X, Q, $, Y) {
  if (X.issues.length) if (Y[$] === void 0) if ($ in Y) Q.value[$] = void 0;
  else Q.value[$] = X.value;
  else Q.issues.push(...B1($, X.issues));
  else if (X.value === void 0) {
    if ($ in Y) Q.value[$] = void 0;
  } else Q.value[$] = X.value;
}
function qJ(X, Q, $, Y) {
  for (let W of X) if (W.issues.length === 0) return Q.value = W.value, Q;
  return Q.issues.push({ code: "invalid_union", input: Q.value, inst: $, errors: X.map((W) => W.issues.map((J) => o0(J, Y, u0()))) }), Q;
}
function l9(X, Q) {
  if (X === Q) return { valid: true, data: X };
  if (X instanceof Date && Q instanceof Date && +X === +Q) return { valid: true, data: X };
  if (C6(X) && C6(Q)) {
    let $ = Object.keys(Q), Y = Object.keys(X).filter((J) => $.indexOf(J) !== -1), W = { ...X, ...Q };
    for (let J of Y) {
      let G = l9(X[J], Q[J]);
      if (!G.valid) return { valid: false, mergeErrorPath: [J, ...G.mergeErrorPath] };
      W[J] = G.data;
    }
    return { valid: true, data: W };
  }
  if (Array.isArray(X) && Array.isArray(Q)) {
    if (X.length !== Q.length) return { valid: false, mergeErrorPath: [] };
    let $ = [];
    for (let Y = 0; Y < X.length; Y++) {
      let W = X[Y], J = Q[Y], G = l9(W, J);
      if (!G.valid) return { valid: false, mergeErrorPath: [Y, ...G.mergeErrorPath] };
      $.push(G.data);
    }
    return { valid: true, data: $ };
  }
  return { valid: false, mergeErrorPath: [] };
}
function FJ(X, Q, $) {
  if (Q.issues.length) X.issues.push(...Q.issues);
  if ($.issues.length) X.issues.push(...$.issues);
  if (e1(X)) return X;
  let Y = l9(Q.value, $.value);
  if (!Y.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(Y.mergeErrorPath)}`);
  return X.value = Y.data, X;
}
function NJ(X, Q) {
  if (X.value === void 0) X.value = Q.defaultValue;
  return X;
}
function OJ(X, Q) {
  if (!X.issues.length && X.value === void 0) X.issues.push({ code: "invalid_type", expected: "nonoptional", input: X.value, inst: Q });
  return X;
}
function DJ(X, Q, $) {
  if (e1(X)) return X;
  return Q.out._zod.run({ value: X.value, issues: X.issues }, $);
}
function AJ(X) {
  return X.value = Object.freeze(X.value), X;
}
function wJ(X, Q, $, Y) {
  if (!X) {
    let W = { code: "custom", input: $, inst: Y, path: [...Y._zod.def.path ?? []], continue: !Y._zod.def.abort };
    if (Y._zod.def.params) W.params = Y._zod.def.params;
    Q.issues.push(P9(W));
  }
}
function SQ() {
  return { localeError: tV() };
}
function bJ() {
  return new x4();
}
function ZQ(X, Q) {
  return new X({ type: "string", ...y(Q) });
}
function CQ(X, Q) {
  return new X({ type: "string", format: "email", check: "string_format", abort: false, ...y(Q) });
}
function y4(X, Q) {
  return new X({ type: "string", format: "guid", check: "string_format", abort: false, ...y(Q) });
}
function kQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, ...y(Q) });
}
function vQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...y(Q) });
}
function TQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...y(Q) });
}
function _Q(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...y(Q) });
}
function xQ(X, Q) {
  return new X({ type: "string", format: "url", check: "string_format", abort: false, ...y(Q) });
}
function yQ(X, Q) {
  return new X({ type: "string", format: "emoji", check: "string_format", abort: false, ...y(Q) });
}
function gQ(X, Q) {
  return new X({ type: "string", format: "nanoid", check: "string_format", abort: false, ...y(Q) });
}
function fQ(X, Q) {
  return new X({ type: "string", format: "cuid", check: "string_format", abort: false, ...y(Q) });
}
function hQ(X, Q) {
  return new X({ type: "string", format: "cuid2", check: "string_format", abort: false, ...y(Q) });
}
function uQ(X, Q) {
  return new X({ type: "string", format: "ulid", check: "string_format", abort: false, ...y(Q) });
}
function lQ(X, Q) {
  return new X({ type: "string", format: "xid", check: "string_format", abort: false, ...y(Q) });
}
function mQ(X, Q) {
  return new X({ type: "string", format: "ksuid", check: "string_format", abort: false, ...y(Q) });
}
function cQ(X, Q) {
  return new X({ type: "string", format: "ipv4", check: "string_format", abort: false, ...y(Q) });
}
function pQ(X, Q) {
  return new X({ type: "string", format: "ipv6", check: "string_format", abort: false, ...y(Q) });
}
function dQ(X, Q) {
  return new X({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...y(Q) });
}
function iQ(X, Q) {
  return new X({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...y(Q) });
}
function nQ(X, Q) {
  return new X({ type: "string", format: "base64", check: "string_format", abort: false, ...y(Q) });
}
function rQ(X, Q) {
  return new X({ type: "string", format: "base64url", check: "string_format", abort: false, ...y(Q) });
}
function oQ(X, Q) {
  return new X({ type: "string", format: "e164", check: "string_format", abort: false, ...y(Q) });
}
function tQ(X, Q) {
  return new X({ type: "string", format: "jwt", check: "string_format", abort: false, ...y(Q) });
}
function PJ(X, Q) {
  return new X({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...y(Q) });
}
function SJ(X, Q) {
  return new X({ type: "string", format: "date", check: "string_format", ...y(Q) });
}
function ZJ(X, Q) {
  return new X({ type: "string", format: "time", check: "string_format", precision: null, ...y(Q) });
}
function CJ(X, Q) {
  return new X({ type: "string", format: "duration", check: "string_format", ...y(Q) });
}
function aQ(X, Q) {
  return new X({ type: "number", checks: [], ...y(Q) });
}
function sQ(X, Q) {
  return new X({ type: "number", check: "number_format", abort: false, format: "safeint", ...y(Q) });
}
function eQ(X, Q) {
  return new X({ type: "boolean", ...y(Q) });
}
function X$(X, Q) {
  return new X({ type: "null", ...y(Q) });
}
function Q$(X) {
  return new X({ type: "unknown" });
}
function $$(X, Q) {
  return new X({ type: "never", ...y(Q) });
}
function g4(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: false });
}
function bX(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: true });
}
function f4(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: false });
}
function PX(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: true });
}
function h4(X, Q) {
  return new sW({ check: "multiple_of", ...y(Q), value: X });
}
function u4(X, Q) {
  return new XJ({ check: "max_length", ...y(Q), maximum: X });
}
function k6(X, Q) {
  return new QJ({ check: "min_length", ...y(Q), minimum: X });
}
function l4(X, Q) {
  return new $J({ check: "length_equals", ...y(Q), length: X });
}
function Y$(X, Q) {
  return new YJ({ check: "string_format", format: "regex", ...y(Q), pattern: X });
}
function W$(X) {
  return new WJ({ check: "string_format", format: "lowercase", ...y(X) });
}
function J$(X) {
  return new JJ({ check: "string_format", format: "uppercase", ...y(X) });
}
function G$(X, Q) {
  return new GJ({ check: "string_format", format: "includes", ...y(Q), includes: X });
}
function H$(X, Q) {
  return new HJ({ check: "string_format", format: "starts_with", ...y(Q), prefix: X });
}
function B$(X, Q) {
  return new BJ({ check: "string_format", format: "ends_with", ...y(Q), suffix: X });
}
function $6(X) {
  return new zJ({ check: "overwrite", tx: X });
}
function z$(X) {
  return $6((Q) => Q.normalize(X));
}
function K$() {
  return $6((X) => X.trim());
}
function U$() {
  return $6((X) => X.toLowerCase());
}
function V$() {
  return $6((X) => X.toUpperCase());
}
function kJ(X, Q, $) {
  return new X({ type: "array", element: Q, ...y($) });
}
function L$(X, Q, $) {
  let Y = y($);
  return Y.abort ?? (Y.abort = true), new X({ type: "custom", check: "custom", fn: Q, ...Y });
}
function q$(X, Q, $) {
  return new X({ type: "custom", check: "custom", fn: Q, ...y($) });
}
function N$(X, Q) {
  if (X instanceof x4) {
    let Y = new F$(Q), W = {};
    for (let H of X._idmap.entries()) {
      let [B, z2] = H;
      Y.process(z2);
    }
    let J = {}, G = { registry: X, uri: Q?.uri || ((H) => H), defs: W };
    for (let H of X._idmap.entries()) {
      let [B, z2] = H;
      J[B] = Y.emit(z2, { ...Q, external: G });
    }
    if (Object.keys(W).length > 0) {
      let H = Y.target === "draft-2020-12" ? "$defs" : "definitions";
      J.__shared = { [H]: W };
    }
    return { schemas: J };
  }
  let $ = new F$(Q);
  return $.process(X), $.emit(X, Q);
}
function A0(X, Q) {
  let $ = Q ?? { seen: /* @__PURE__ */ new Set() };
  if ($.seen.has(X)) return false;
  $.seen.add(X);
  let W = X._zod.def;
  switch (W.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array":
      return A0(W.element, $);
    case "object": {
      for (let J in W.shape) if (A0(W.shape[J], $)) return true;
      return false;
    }
    case "union": {
      for (let J of W.options) if (A0(J, $)) return true;
      return false;
    }
    case "intersection":
      return A0(W.left, $) || A0(W.right, $);
    case "tuple": {
      for (let J of W.items) if (A0(J, $)) return true;
      if (W.rest && A0(W.rest, $)) return true;
      return false;
    }
    case "record":
      return A0(W.keyType, $) || A0(W.valueType, $);
    case "map":
      return A0(W.keyType, $) || A0(W.valueType, $);
    case "set":
      return A0(W.valueType, $);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return A0(W.innerType, $);
    case "lazy":
      return A0(W.getter(), $);
    case "default":
      return A0(W.innerType, $);
    case "prefault":
      return A0(W.innerType, $);
    case "custom":
      return false;
    case "transform":
      return true;
    case "pipe":
      return A0(W.in, $) || A0(W.out, $);
    case "success":
      return false;
    case "catch":
      return false;
    default:
  }
  throw Error(`Unknown schema type: ${W.type}`);
}
function O$(X, Q) {
  let $ = { type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, ...i.normalizeParams(Q) };
  return new _L($);
}
function m0(X) {
  return !!X._zod;
}
function v6(X) {
  let Q = Object.values(X);
  if (Q.length === 0) return O$({});
  let $ = Q.every(m0), Y = Q.every((W) => !m0(W));
  if ($) return O$(X);
  if (Y) return NW(X);
  throw Error("Mixed Zod versions detected in object shape.");
}
function f1(X, Q) {
  if (m0(X)) return X6(X, Q);
  return X.safeParse(Q);
}
async function m4(X, Q) {
  if (m0(X)) return await Q6(X, Q);
  return await X.safeParseAsync(Q);
}
function h1(X) {
  var Q, $;
  if (!X) return;
  let Y;
  if (m0(X)) Y = ($ = (Q = X._zod) === null || Q === void 0 ? void 0 : Q.def) === null || $ === void 0 ? void 0 : $.shape;
  else Y = X.shape;
  if (!Y) return;
  if (typeof Y === "function") try {
    return Y();
  } catch (W) {
    return;
  }
  return Y;
}
function T6(X) {
  var Q;
  if (!X) return;
  if (typeof X === "object") {
    let $ = X, Y = X;
    if (!$._def && !Y._zod) {
      let W = Object.values(X);
      if (W.length > 0 && W.every((J) => typeof J === "object" && J !== null && (J._def !== void 0 || J._zod !== void 0 || typeof J.parse === "function"))) return v6(X);
    }
  }
  if (m0(X)) {
    let Y = (Q = X._zod) === null || Q === void 0 ? void 0 : Q.def;
    if (Y && (Y.type === "object" || Y.shape !== void 0)) return X;
  } else if (X.shape !== void 0) return X;
  return;
}
function c4(X) {
  if (X && typeof X === "object") {
    if ("message" in X && typeof X.message === "string") return X.message;
    if ("issues" in X && Array.isArray(X.issues) && X.issues.length > 0) {
      let Q = X.issues[0];
      if (Q && typeof Q === "object" && "message" in Q) return String(Q.message);
    }
    try {
      return JSON.stringify(X);
    } catch (Q) {
      return String(X);
    }
  }
  return String(X);
}
function TJ(X) {
  var Q, $, Y, W;
  if (m0(X)) return ($ = (Q = X._zod) === null || Q === void 0 ? void 0 : Q.def) === null || $ === void 0 ? void 0 : $.description;
  let J = X;
  return (Y = X.description) !== null && Y !== void 0 ? Y : (W = J._def) === null || W === void 0 ? void 0 : W.description;
}
function _J(X) {
  var Q, $, Y;
  if (m0(X)) return (($ = (Q = X._zod) === null || Q === void 0 ? void 0 : Q.def) === null || $ === void 0 ? void 0 : $.type) === "optional";
  let W = X;
  if (typeof X.isOptional === "function") return X.isOptional();
  return ((Y = W._def) === null || Y === void 0 ? void 0 : Y.typeName) === "ZodOptional";
}
function p4(X) {
  var Q;
  if (m0(X)) {
    let G = (Q = X._zod) === null || Q === void 0 ? void 0 : Q.def;
    if (G) {
      if (G.value !== void 0) return G.value;
      if (Array.isArray(G.values) && G.values.length > 0) return G.values[0];
    }
  }
  let Y = X._def;
  if (Y) {
    if (Y.value !== void 0) return Y.value;
    if (Array.isArray(Y.values) && Y.values.length > 0) return Y.values[0];
  }
  let W = X.value;
  if (W !== void 0) return W;
  return;
}
function D$(X) {
  return PJ(xJ, X);
}
function A$(X) {
  return SJ(yJ, X);
}
function w$(X) {
  return ZJ(gJ, X);
}
function M$(X) {
  return CJ(fJ, X);
}
function D(X) {
  return ZQ(cL, X);
}
function Q0(X) {
  return aQ(rJ, X);
}
function dJ(X) {
  return sQ(Hq, X);
}
function M0(X) {
  return eQ(Bq, X);
}
function E$(X) {
  return X$(zq, X);
}
function N0() {
  return Q$(Kq);
}
function Vq(X) {
  return $$(Uq, X);
}
function r(X, Q) {
  return kJ(Lq, X, Q);
}
function I(X, Q) {
  let $ = { type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, ...i.normalizeParams(Q) };
  return new oJ($);
}
function c0(X, Q) {
  return new oJ({ type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, catchall: N0(), ...i.normalizeParams(Q) });
}
function J0(X, Q) {
  return new tJ({ type: "union", options: X, ...i.normalizeParams(Q) });
}
function I$(X, Q, $) {
  return new qq({ type: "union", options: Q, discriminator: X, ...i.normalizeParams($) });
}
function i4(X, Q) {
  return new Fq({ type: "intersection", left: X, right: Q });
}
function O0(X, Q, $) {
  return new Nq({ type: "record", keyType: X, valueType: Q, ...i.normalizeParams($) });
}
function j0(X, Q) {
  let $ = Array.isArray(X) ? Object.fromEntries(X.map((Y) => [Y, Y])) : X;
  return new j$({ type: "enum", entries: $, ...i.normalizeParams(Q) });
}
function T(X, Q) {
  return new Oq({ type: "literal", values: Array.isArray(X) ? X : [X], ...i.normalizeParams(Q) });
}
function aJ(X) {
  return new Dq({ type: "transform", transform: X });
}
function v(X) {
  return new sJ({ type: "optional", innerType: X });
}
function iJ(X) {
  return new Aq({ type: "nullable", innerType: X });
}
function Mq(X, Q) {
  return new wq({ type: "default", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
function Rq(X, Q) {
  return new jq({ type: "prefault", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
function Eq(X, Q) {
  return new eJ({ type: "nonoptional", innerType: X, ...i.normalizeParams(Q) });
}
function bq(X, Q) {
  return new Iq({ type: "catch", innerType: X, catchValue: typeof Q === "function" ? Q : () => Q });
}
function R$(X, Q) {
  return new Pq({ type: "pipe", in: X, out: Q });
}
function Zq(X) {
  return new Sq({ type: "readonly", innerType: X });
}
function Cq(X, Q) {
  let $ = new w0({ check: "custom", ...i.normalizeParams(Q) });
  return $._zod.check = X, $;
}
function Q5(X, Q) {
  return L$(X5, X ?? (() => true), Q);
}
function kq(X, Q = {}) {
  return q$(X5, X, Q);
}
function vq(X, Q) {
  let $ = Cq((Y) => {
    return Y.addIssue = (W) => {
      if (typeof W === "string") Y.issues.push(i.issue(W, Y.value, $._zod.def));
      else {
        let J = W;
        if (J.fatal) J.continue = false;
        J.code ?? (J.code = "custom"), J.input ?? (J.input = Y.value), J.inst ?? (J.inst = $), J.continue ?? (J.continue = !$._zod.def.abort), Y.issues.push(i.issue(J));
      }
    }, X(Y.value, Y);
  }, Q);
  return $;
}
function b$(X, Q) {
  return R$(aJ(X), Q);
}
function A5(X) {
  if (X.params.ref.type !== "ref/prompt") throw TypeError(`Expected CompleteRequestPrompt, but got ${X.params.ref.type}`);
}
function w5(X) {
  if (X.params.ref.type !== "ref/resource") throw TypeError(`Expected CompleteRequestResourceTemplate, but got ${X.params.ref.type}`);
}
function u1(X) {
  return X === "completed" || X === "failed" || X === "cancelled";
}
function m$(X, Q, $, Y) {
  if (!Y?.errorMessages) return;
  if ($) X.errorMessage = { ...X.errorMessage, [Q]: $ };
}
function o(X, Q, $, Y, W) {
  X[Q] = $, m$(X, Q, Y, W);
}
function B0(X) {
  if (X.target !== "openAi") return {};
  let Q = [...X.basePath, X.definitionPath, X.openAiAnyTypeName];
  return X.flags.hasReferencedOpenAiAnyType = true, { $ref: X.$refStrategy === "relative" ? q8(Q, X.currentPath) : Q.join("/") };
}
function b5(X, Q) {
  let $ = { type: "array" };
  if (X.type?._def && X.type?._def?.typeName !== j.ZodAny) $.items = f(X.type._def, { ...Q, currentPath: [...Q.currentPath, "items"] });
  if (X.minLength) o($, "minItems", X.minLength.value, X.minLength.message, Q);
  if (X.maxLength) o($, "maxItems", X.maxLength.value, X.maxLength.message, Q);
  if (X.exactLength) o($, "minItems", X.exactLength.value, X.exactLength.message, Q), o($, "maxItems", X.exactLength.value, X.exactLength.message, Q);
  return $;
}
function P5(X, Q) {
  let $ = { type: "integer", format: "int64" };
  if (!X.checks) return $;
  for (let Y of X.checks) switch (Y.kind) {
    case "min":
      if (Q.target === "jsonSchema7") if (Y.inclusive) o($, "minimum", Y.value, Y.message, Q);
      else o($, "exclusiveMinimum", Y.value, Y.message, Q);
      else {
        if (!Y.inclusive) $.exclusiveMinimum = true;
        o($, "minimum", Y.value, Y.message, Q);
      }
      break;
    case "max":
      if (Q.target === "jsonSchema7") if (Y.inclusive) o($, "maximum", Y.value, Y.message, Q);
      else o($, "exclusiveMaximum", Y.value, Y.message, Q);
      else {
        if (!Y.inclusive) $.exclusiveMaximum = true;
        o($, "maximum", Y.value, Y.message, Q);
      }
      break;
    case "multipleOf":
      o($, "multipleOf", Y.value, Y.message, Q);
      break;
  }
  return $;
}
function S5() {
  return { type: "boolean" };
}
function F8(X, Q) {
  return f(X.type._def, Q);
}
function c$(X, Q, $) {
  let Y = $ ?? Q.dateStrategy;
  if (Array.isArray(Y)) return { anyOf: Y.map((W, J) => c$(X, Q, W)) };
  switch (Y) {
    case "string":
    case "format:date-time":
      return { type: "string", format: "date-time" };
    case "format:date":
      return { type: "string", format: "date" };
    case "integer":
      return WN(X, Q);
  }
}
function C5(X, Q) {
  return { ...f(X.innerType._def, Q), default: X.defaultValue() };
}
function k5(X, Q) {
  return Q.effectStrategy === "input" ? f(X.schema._def, Q) : B0(Q);
}
function v5(X) {
  return { type: "string", enum: Array.from(X.values) };
}
function T5(X, Q) {
  let $ = [f(X.left._def, { ...Q, currentPath: [...Q.currentPath, "allOf", "0"] }), f(X.right._def, { ...Q, currentPath: [...Q.currentPath, "allOf", "1"] })].filter((J) => !!J), Y = Q.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0, W = [];
  return $.forEach((J) => {
    if (JN(J)) {
      if (W.push(...J.allOf), J.unevaluatedProperties === void 0) Y = void 0;
    } else {
      let G = J;
      if ("additionalProperties" in J && J.additionalProperties === false) {
        let { additionalProperties: H, ...B } = J;
        G = B;
      } else Y = void 0;
      W.push(G);
    }
  }), W.length ? { allOf: W, ...Y } : void 0;
}
function _5(X, Q) {
  let $ = typeof X.value;
  if ($ !== "bigint" && $ !== "number" && $ !== "boolean" && $ !== "string") return { type: Array.isArray(X.value) ? "array" : "object" };
  if (Q.target === "openApi3") return { type: $ === "bigint" ? "integer" : $, enum: [X.value] };
  return { type: $ === "bigint" ? "integer" : $, const: X.value };
}
function N8(X, Q) {
  let $ = { type: "string" };
  if (X.checks) for (let Y of X.checks) switch (Y.kind) {
    case "min":
      o($, "minLength", typeof $.minLength === "number" ? Math.max($.minLength, Y.value) : Y.value, Y.message, Q);
      break;
    case "max":
      o($, "maxLength", typeof $.maxLength === "number" ? Math.min($.maxLength, Y.value) : Y.value, Y.message, Q);
      break;
    case "email":
      switch (Q.emailStrategy) {
        case "format:email":
          a0($, "email", Y.message, Q);
          break;
        case "format:idn-email":
          a0($, "idn-email", Y.message, Q);
          break;
        case "pattern:zod":
          k0($, t0.email, Y.message, Q);
          break;
      }
      break;
    case "url":
      a0($, "uri", Y.message, Q);
      break;
    case "uuid":
      a0($, "uuid", Y.message, Q);
      break;
    case "regex":
      k0($, Y.regex, Y.message, Q);
      break;
    case "cuid":
      k0($, t0.cuid, Y.message, Q);
      break;
    case "cuid2":
      k0($, t0.cuid2, Y.message, Q);
      break;
    case "startsWith":
      k0($, RegExp(`^${d$(Y.value, Q)}`), Y.message, Q);
      break;
    case "endsWith":
      k0($, RegExp(`${d$(Y.value, Q)}$`), Y.message, Q);
      break;
    case "datetime":
      a0($, "date-time", Y.message, Q);
      break;
    case "date":
      a0($, "date", Y.message, Q);
      break;
    case "time":
      a0($, "time", Y.message, Q);
      break;
    case "duration":
      a0($, "duration", Y.message, Q);
      break;
    case "length":
      o($, "minLength", typeof $.minLength === "number" ? Math.max($.minLength, Y.value) : Y.value, Y.message, Q), o($, "maxLength", typeof $.maxLength === "number" ? Math.min($.maxLength, Y.value) : Y.value, Y.message, Q);
      break;
    case "includes": {
      k0($, RegExp(d$(Y.value, Q)), Y.message, Q);
      break;
    }
    case "ip": {
      if (Y.version !== "v6") a0($, "ipv4", Y.message, Q);
      if (Y.version !== "v4") a0($, "ipv6", Y.message, Q);
      break;
    }
    case "base64url":
      k0($, t0.base64url, Y.message, Q);
      break;
    case "jwt":
      k0($, t0.jwt, Y.message, Q);
      break;
    case "cidr": {
      if (Y.version !== "v6") k0($, t0.ipv4Cidr, Y.message, Q);
      if (Y.version !== "v4") k0($, t0.ipv6Cidr, Y.message, Q);
      break;
    }
    case "emoji":
      k0($, t0.emoji(), Y.message, Q);
      break;
    case "ulid": {
      k0($, t0.ulid, Y.message, Q);
      break;
    }
    case "base64": {
      switch (Q.base64Strategy) {
        case "format:binary": {
          a0($, "binary", Y.message, Q);
          break;
        }
        case "contentEncoding:base64": {
          o($, "contentEncoding", "base64", Y.message, Q);
          break;
        }
        case "pattern:zod": {
          k0($, t0.base64, Y.message, Q);
          break;
        }
      }
      break;
    }
    case "nanoid":
      k0($, t0.nanoid, Y.message, Q);
    case "toLowerCase":
    case "toUpperCase":
    case "trim":
      break;
    default:
      /* @__PURE__ */ ((W) => {
      })(Y);
  }
  return $;
}
function d$(X, Q) {
  return Q.patternStrategy === "escape" ? HN(X) : X;
}
function HN(X) {
  let Q = "";
  for (let $ = 0; $ < X.length; $++) {
    if (!GN.has(X[$])) Q += "\\";
    Q += X[$];
  }
  return Q;
}
function a0(X, Q, $, Y) {
  if (X.format || X.anyOf?.some((W) => W.format)) {
    if (!X.anyOf) X.anyOf = [];
    if (X.format) {
      if (X.anyOf.push({ format: X.format, ...X.errorMessage && Y.errorMessages && { errorMessage: { format: X.errorMessage.format } } }), delete X.format, X.errorMessage) {
        if (delete X.errorMessage.format, Object.keys(X.errorMessage).length === 0) delete X.errorMessage;
      }
    }
    X.anyOf.push({ format: Q, ...$ && Y.errorMessages && { errorMessage: { format: $ } } });
  } else o(X, "format", Q, $, Y);
}
function k0(X, Q, $, Y) {
  if (X.pattern || X.allOf?.some((W) => W.pattern)) {
    if (!X.allOf) X.allOf = [];
    if (X.pattern) {
      if (X.allOf.push({ pattern: X.pattern, ...X.errorMessage && Y.errorMessages && { errorMessage: { pattern: X.errorMessage.pattern } } }), delete X.pattern, X.errorMessage) {
        if (delete X.errorMessage.pattern, Object.keys(X.errorMessage).length === 0) delete X.errorMessage;
      }
    }
    X.allOf.push({ pattern: x5(Q, Y), ...$ && Y.errorMessages && { errorMessage: { pattern: $ } } });
  } else o(X, "pattern", x5(Q, Y), $, Y);
}
function x5(X, Q) {
  if (!Q.applyRegexFlags || !X.flags) return X.source;
  let $ = { i: X.flags.includes("i"), m: X.flags.includes("m"), s: X.flags.includes("s") }, Y = $.i ? X.source.toLowerCase() : X.source, W = "", J = false, G = false, H = false;
  for (let B = 0; B < Y.length; B++) {
    if (J) {
      W += Y[B], J = false;
      continue;
    }
    if ($.i) {
      if (G) {
        if (Y[B].match(/[a-z]/)) {
          if (H) W += Y[B], W += `${Y[B - 2]}-${Y[B]}`.toUpperCase(), H = false;
          else if (Y[B + 1] === "-" && Y[B + 2]?.match(/[a-z]/)) W += Y[B], H = true;
          else W += `${Y[B]}${Y[B].toUpperCase()}`;
          continue;
        }
      } else if (Y[B].match(/[a-z]/)) {
        W += `[${Y[B]}${Y[B].toUpperCase()}]`;
        continue;
      }
    }
    if ($.m) {
      if (Y[B] === "^") {
        W += `(^|(?<=[\r
]))`;
        continue;
      } else if (Y[B] === "$") {
        W += `($|(?=[\r
]))`;
        continue;
      }
    }
    if ($.s && Y[B] === ".") {
      W += G ? `${Y[B]}\r
` : `[${Y[B]}\r
]`;
      continue;
    }
    if (W += Y[B], Y[B] === "\\") J = true;
    else if (G && Y[B] === "]") G = false;
    else if (!G && Y[B] === "[") G = true;
  }
  try {
    new RegExp(W);
  } catch {
    return console.warn(`Could not convert regex pattern at ${Q.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), X.source;
  }
  return W;
}
function O8(X, Q) {
  if (Q.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (Q.target === "openApi3" && X.keyType?._def.typeName === j.ZodEnum) return { type: "object", required: X.keyType._def.values, properties: X.keyType._def.values.reduce((Y, W) => ({ ...Y, [W]: f(X.valueType._def, { ...Q, currentPath: [...Q.currentPath, "properties", W] }) ?? B0(Q) }), {}), additionalProperties: Q.rejectedAdditionalProperties };
  let $ = { type: "object", additionalProperties: f(X.valueType._def, { ...Q, currentPath: [...Q.currentPath, "additionalProperties"] }) ?? Q.allowedAdditionalProperties };
  if (Q.target === "openApi3") return $;
  if (X.keyType?._def.typeName === j.ZodString && X.keyType._def.checks?.length) {
    let { type: Y, ...W } = N8(X.keyType._def, Q);
    return { ...$, propertyNames: W };
  } else if (X.keyType?._def.typeName === j.ZodEnum) return { ...$, propertyNames: { enum: X.keyType._def.values } };
  else if (X.keyType?._def.typeName === j.ZodBranded && X.keyType._def.type._def.typeName === j.ZodString && X.keyType._def.type._def.checks?.length) {
    let { type: Y, ...W } = F8(X.keyType._def, Q);
    return { ...$, propertyNames: W };
  }
  return $;
}
function y5(X, Q) {
  if (Q.mapStrategy === "record") return O8(X, Q);
  let $ = f(X.keyType._def, { ...Q, currentPath: [...Q.currentPath, "items", "items", "0"] }) || B0(Q), Y = f(X.valueType._def, { ...Q, currentPath: [...Q.currentPath, "items", "items", "1"] }) || B0(Q);
  return { type: "array", maxItems: 125, items: { type: "array", items: [$, Y], minItems: 2, maxItems: 2 } };
}
function g5(X) {
  let Q = X.values, Y = Object.keys(X.values).filter((J) => {
    return typeof Q[Q[J]] !== "number";
  }).map((J) => Q[J]), W = Array.from(new Set(Y.map((J) => typeof J)));
  return { type: W.length === 1 ? W[0] === "string" ? "string" : "number" : ["string", "number"], enum: Y };
}
function f5(X) {
  return X.target === "openAi" ? void 0 : { not: B0({ ...X, currentPath: [...X.currentPath, "not"] }) };
}
function h5(X) {
  return X.target === "openApi3" ? { enum: ["null"], nullable: true } : { type: "null" };
}
function l5(X, Q) {
  if (Q.target === "openApi3") return u5(X, Q);
  let $ = X.options instanceof Map ? Array.from(X.options.values()) : X.options;
  if ($.every((Y) => Y._def.typeName in gX && (!Y._def.checks || !Y._def.checks.length))) {
    let Y = $.reduce((W, J) => {
      let G = gX[J._def.typeName];
      return G && !W.includes(G) ? [...W, G] : W;
    }, []);
    return { type: Y.length > 1 ? Y : Y[0] };
  } else if ($.every((Y) => Y._def.typeName === "ZodLiteral" && !Y.description)) {
    let Y = $.reduce((W, J) => {
      let G = typeof J._def.value;
      switch (G) {
        case "string":
        case "number":
        case "boolean":
          return [...W, G];
        case "bigint":
          return [...W, "integer"];
        case "object":
          if (J._def.value === null) return [...W, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return W;
      }
    }, []);
    if (Y.length === $.length) {
      let W = Y.filter((J, G, H) => H.indexOf(J) === G);
      return { type: W.length > 1 ? W : W[0], enum: $.reduce((J, G) => {
        return J.includes(G._def.value) ? J : [...J, G._def.value];
      }, []) };
    }
  } else if ($.every((Y) => Y._def.typeName === "ZodEnum")) return { type: "string", enum: $.reduce((Y, W) => [...Y, ...W._def.values.filter((J) => !Y.includes(J))], []) };
  return u5(X, Q);
}
function m5(X, Q) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(X.innerType._def.typeName) && (!X.innerType._def.checks || !X.innerType._def.checks.length)) {
    if (Q.target === "openApi3") return { type: gX[X.innerType._def.typeName], nullable: true };
    return { type: [gX[X.innerType._def.typeName], "null"] };
  }
  if (Q.target === "openApi3") {
    let Y = f(X.innerType._def, { ...Q, currentPath: [...Q.currentPath] });
    if (Y && "$ref" in Y) return { allOf: [Y], nullable: true };
    return Y && { ...Y, nullable: true };
  }
  let $ = f(X.innerType._def, { ...Q, currentPath: [...Q.currentPath, "anyOf", "0"] });
  return $ && { anyOf: [$, { type: "null" }] };
}
function c5(X, Q) {
  let $ = { type: "number" };
  if (!X.checks) return $;
  for (let Y of X.checks) switch (Y.kind) {
    case "int":
      $.type = "integer", m$($, "type", Y.message, Q);
      break;
    case "min":
      if (Q.target === "jsonSchema7") if (Y.inclusive) o($, "minimum", Y.value, Y.message, Q);
      else o($, "exclusiveMinimum", Y.value, Y.message, Q);
      else {
        if (!Y.inclusive) $.exclusiveMinimum = true;
        o($, "minimum", Y.value, Y.message, Q);
      }
      break;
    case "max":
      if (Q.target === "jsonSchema7") if (Y.inclusive) o($, "maximum", Y.value, Y.message, Q);
      else o($, "exclusiveMaximum", Y.value, Y.message, Q);
      else {
        if (!Y.inclusive) $.exclusiveMaximum = true;
        o($, "maximum", Y.value, Y.message, Q);
      }
      break;
    case "multipleOf":
      o($, "multipleOf", Y.value, Y.message, Q);
      break;
  }
  return $;
}
function p5(X, Q) {
  let $ = Q.target === "openAi", Y = { type: "object", properties: {} }, W = [], J = X.shape();
  for (let H in J) {
    let B = J[H];
    if (B === void 0 || B._def === void 0) continue;
    let z2 = zN(B);
    if (z2 && $) {
      if (B._def.typeName === "ZodOptional") B = B._def.innerType;
      if (!B.isNullable()) B = B.nullable();
      z2 = false;
    }
    let K = f(B._def, { ...Q, currentPath: [...Q.currentPath, "properties", H], propertyPath: [...Q.currentPath, "properties", H] });
    if (K === void 0) continue;
    if (Y.properties[H] = K, !z2) W.push(H);
  }
  if (W.length) Y.required = W;
  let G = BN(X, Q);
  if (G !== void 0) Y.additionalProperties = G;
  return Y;
}
function BN(X, Q) {
  if (X.catchall._def.typeName !== "ZodNever") return f(X.catchall._def, { ...Q, currentPath: [...Q.currentPath, "additionalProperties"] });
  switch (X.unknownKeys) {
    case "passthrough":
      return Q.allowedAdditionalProperties;
    case "strict":
      return Q.rejectedAdditionalProperties;
    case "strip":
      return Q.removeAdditionalStrategy === "strict" ? Q.allowedAdditionalProperties : Q.rejectedAdditionalProperties;
  }
}
function zN(X) {
  try {
    return X.isOptional();
  } catch {
    return true;
  }
}
function n5(X, Q) {
  return f(X.type._def, Q);
}
function r5(X, Q) {
  let Y = { type: "array", uniqueItems: true, items: f(X.valueType._def, { ...Q, currentPath: [...Q.currentPath, "items"] }) };
  if (X.minSize) o(Y, "minItems", X.minSize.value, X.minSize.message, Q);
  if (X.maxSize) o(Y, "maxItems", X.maxSize.value, X.maxSize.message, Q);
  return Y;
}
function o5(X, Q) {
  if (X.rest) return { type: "array", minItems: X.items.length, items: X.items.map(($, Y) => f($._def, { ...Q, currentPath: [...Q.currentPath, "items", `${Y}`] })).reduce(($, Y) => Y === void 0 ? $ : [...$, Y], []), additionalItems: f(X.rest._def, { ...Q, currentPath: [...Q.currentPath, "additionalItems"] }) };
  else return { type: "array", minItems: X.items.length, maxItems: X.items.length, items: X.items.map(($, Y) => f($._def, { ...Q, currentPath: [...Q.currentPath, "items", `${Y}`] })).reduce(($, Y) => Y === void 0 ? $ : [...$, Y], []) };
}
function t5(X) {
  return { not: B0(X) };
}
function a5(X) {
  return B0(X);
}
function f(X, Q, $ = false) {
  let Y = Q.seen.get(X);
  if (Q.override) {
    let H = Q.override?.(X, Q, Y, $);
    if (H !== R5) return H;
  }
  if (Y && !$) {
    let H = KN(Y, Q);
    if (H !== void 0) return H;
  }
  let W = { def: X, path: Q.currentPath, jsonSchema: void 0 };
  Q.seen.set(X, W);
  let J = e5(X, X.typeName, Q), G = typeof J === "function" ? f(J(), Q) : J;
  if (G) UN(X, Q, G);
  if (Q.postProcess) {
    let H = Q.postProcess(G, X, Q);
    return W.jsonSchema = G, H;
  }
  return W.jsonSchema = G, G;
}
function VN(X) {
  if (!X) return "draft-7";
  if (X === "jsonSchema7" || X === "draft-7") return "draft-7";
  if (X === "jsonSchema2019-09" || X === "draft-2020-12") return "draft-2020-12";
  return "draft-7";
}
function n$(X, Q) {
  var $, Y, W;
  if (m0(X)) return N$(X, { target: VN(Q === null || Q === void 0 ? void 0 : Q.target), io: ($ = Q === null || Q === void 0 ? void 0 : Q.pipeStrategy) !== null && $ !== void 0 ? $ : "input" });
  return i$(X, { strictUnions: (Y = Q === null || Q === void 0 ? void 0 : Q.strictUnions) !== null && Y !== void 0 ? Y : true, pipeStrategy: (W = Q === null || Q === void 0 ? void 0 : Q.pipeStrategy) !== null && W !== void 0 ? W : "input" });
}
function r$(X) {
  let Q = h1(X), $ = Q === null || Q === void 0 ? void 0 : Q.method;
  if (!$) throw Error("Schema is missing a method literal");
  let Y = p4($);
  if (typeof Y !== "string") throw Error("Schema method literal must be a string");
  return Y;
}
function o$(X, Q) {
  let $ = f1(X, Q);
  if (!$.success) throw $.error;
  return $.data;
}
function XG(X) {
  return X !== null && typeof X === "object" && !Array.isArray(X);
}
function QG(X, Q) {
  let $ = { ...X };
  for (let Y in Q) {
    let W = Y, J = Q[W];
    if (J === void 0) continue;
    let G = $[W];
    if (XG(G) && XG(J)) $[W] = { ...G, ...J };
    else $[W] = J;
  }
  return $;
}
function ME() {
  let X = new fz.Ajv({ strict: false, validateFormats: true, validateSchema: false, allErrors: true });
  return hz.default(X), X;
}
function uz(X, Q, $) {
  var Y;
  if (!X) throw Error(`${$} does not support task creation (required for ${Q})`);
  switch (Q) {
    case "tools/call":
      if (!((Y = X.tools) === null || Y === void 0 ? void 0 : Y.call)) throw Error(`${$} does not support task creation for tools/call (required for ${Q})`);
      break;
    default:
      break;
  }
}
function lz(X, Q, $) {
  var Y, W;
  if (!X) throw Error(`${$} does not support task creation (required for ${Q})`);
  switch (Q) {
    case "sampling/createMessage":
      if (!((Y = X.sampling) === null || Y === void 0 ? void 0 : Y.createMessage)) throw Error(`${$} does not support task creation for sampling/createMessage (required for ${Q})`);
      break;
    case "elicitation/create":
      if (!((W = X.elicitation) === null || W === void 0 ? void 0 : W.create)) throw Error(`${$} does not support task creation for elicitation/create (required for ${Q})`);
      break;
    default:
      break;
  }
}
function pz(X) {
  return !!X && typeof X === "object" && cz in X;
}
function dz(X) {
  let Q = X[cz];
  return Q === null || Q === void 0 ? void 0 : Q.complete;
}
function RE(X) {
  let Q = [];
  if (X.length === 0) return { isValid: false, warnings: ["Tool name cannot be empty"] };
  if (X.length > 128) return { isValid: false, warnings: [`Tool name exceeds maximum length of 128 characters (current: ${X.length})`] };
  if (X.includes(" ")) Q.push("Tool name contains spaces, which may cause parsing issues");
  if (X.includes(",")) Q.push("Tool name contains commas, which may cause parsing issues");
  if (X.startsWith("-") || X.endsWith("-")) Q.push("Tool name starts or ends with a dash, which may cause parsing issues in some contexts");
  if (X.startsWith(".") || X.endsWith(".")) Q.push("Tool name starts or ends with a dot, which may cause parsing issues in some contexts");
  if (!jE.test(X)) {
    let $ = X.split("").filter((Y) => !/[A-Za-z0-9._-]/.test(Y)).filter((Y, W, J) => J.indexOf(Y) === W);
    return Q.push(`Tool name contains invalid characters: ${$.map((Y) => `"${Y}"`).join(", ")}`, "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)"), { isValid: false, warnings: Q };
  }
  return { isValid: true, warnings: Q };
}
function EE(X, Q) {
  if (Q.length > 0) {
    console.warn(`Tool name validation warning for "${X}":`);
    for (let $ of Q) console.warn(`  - ${$}`);
    console.warn("Tool registration will proceed, but this may cause compatibility issues."), console.warn("Consider updating the tool name to conform to the MCP tool naming standard."), console.warn("See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.");
  }
}
function $7(X) {
  let Q = RE(X);
  return EE(X, Q.warnings), Q.isValid;
}
function rz(X) {
  return X !== null && typeof X === "object" && "parse" in X && typeof X.parse === "function" && "safeParse" in X && typeof X.safeParse === "function";
}
function bE(X) {
  return "_def" in X || "_zod" in X || rz(X);
}
function W7(X) {
  if (typeof X !== "object" || X === null) return false;
  if (bE(X)) return false;
  if (Object.keys(X).length === 0) return true;
  return Object.values(X).some(rz);
}
function iz(X) {
  if (!X) return;
  if (W7(X)) return v6(X);
  return X;
}
function PE(X) {
  let Q = h1(X);
  if (!Q) return [];
  return Object.entries(Q).map(([$, Y]) => {
    let W = TJ(Y), J = _J(Y);
    return { name: $, description: W, required: !J };
  });
}
function r1(X) {
  let Q = h1(X), $ = Q === null || Q === void 0 ? void 0 : Q.method;
  if (!$) throw Error("Schema is missing a method literal");
  let Y = p4($);
  if (typeof Y === "string") return Y;
  throw Error("Schema method literal must be a string");
}
function nz(X) {
  return { completion: { values: X.slice(0, 100), total: X.length, hasMore: X.length > 100 } };
}
function SE(X, Q, $, Y) {
  return { name: X, description: Q, inputSchema: $, handler: Y };
}
function ZE(X) {
  let Q = new J7({ name: X.name, version: X.version ?? "1.0.0" }, { capabilities: { tools: X.tools ? {} : void 0 } });
  if (X.tools) X.tools.forEach(($) => {
    Q.tool($.name, $.description, $.inputSchema, $.handler);
  });
  return { type: "sdk", name: X.name, instance: Q };
}
function o_({ prompt: X, options: Q }) {
  let { systemPrompt: $, settingSources: Y, sandbox: W, ...J } = Q ?? {}, G, H;
  if ($ === void 0) G = "";
  else if (typeof $ === "string") G = $;
  else if ($.type === "preset") H = $.append;
  let B = J.pathToClaudeCodeExecutable;
  if (!B) {
    let q6 = (0, import_url.fileURLToPath)(import_meta.url), F6 = (0, import_path.join)(q6, "..");
    B = (0, import_path.join)(F6, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.22";
  let { abortController: z2 = N6(), additionalDirectories: K = [], agent: V, agents: L, allowedTools: U = [], betas: F, canUseTool: q, continue: N, cwd: A, disallowedTools: M = [], tools: R, env: S, executable: C = j6() ? "bun" : "node", executableArgs: K0 = [], extraArgs: U0 = {}, fallbackModel: s, enableFileCheckpointing: D0, forkSession: q0, hooks: W1, includePartialMessages: P1, persistSession: U6, maxThinkingTokens: d, maxTurns: Q9, maxBudgetUsd: o6, mcpServers: V6, model: t6, outputFormat: a6, permissionMode: B4 = "default", allowDangerouslySkipPermissions: S0 = false, permissionPromptToolName: S1, plugins: s6, resume: tz, resumeSessionAt: az, stderr: sz, strictMcpConfig: ez } = J, G7 = a6?.type === "json_schema" ? a6.schema : void 0, L6 = S;
  if (!L6) L6 = { ...process.env };
  if (!L6.CLAUDE_CODE_ENTRYPOINT) L6.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  if (D0) L6.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  if (!B) throw Error("pathToClaudeCodeExecutable is required");
  let $9 = {}, H7 = /* @__PURE__ */ new Map();
  if (V6) for (let [q6, F6] of Object.entries(V6)) if (F6.type === "sdk" && "instance" in F6) H7.set(q6, F6.instance), $9[q6] = { type: "sdk", name: q6 };
  else $9[q6] = F6;
  let XK = typeof X === "string", B7 = new XX({ abortController: z2, additionalDirectories: K, agent: V, betas: F, cwd: A, executable: C, executableArgs: K0, extraArgs: U0, pathToClaudeCodeExecutable: B, env: L6, forkSession: q0, stderr: sz, maxThinkingTokens: d, maxTurns: Q9, maxBudgetUsd: o6, model: t6, fallbackModel: s, jsonSchema: G7, permissionMode: B4, allowDangerouslySkipPermissions: S0, permissionPromptToolName: S1, continueConversation: N, resume: tz, resumeSessionAt: az, settingSources: Y ?? [], allowedTools: U, disallowedTools: M, tools: R, mcpServers: $9, strictMcpConfig: ez, canUseTool: !!q, hooks: !!W1, includePartialMessages: P1, persistSession: U6, plugins: s6, sandbox: W, spawnClaudeCodeProcess: J.spawnClaudeCodeProcess }), z7 = new $X(B7, XK, q, W1, z2, H7, G7, { systemPrompt: G, appendSystemPrompt: H, agents: L });
  if (typeof X === "string") B7.write(Z0({ type: "user", session_id: "", message: { role: "user", content: [{ type: "text", text: X }] }, parent_tool_use_id: null }) + `
`);
  else z7.streamInput(X);
  return z7;
}
function t_(X) {
  return V9(X);
}
function a_(X, Q) {
  return KW(X, Q);
}
async function s_(X, Q) {
  let Y = [];
  try {
    const $ = V7(Y, V9(Q), 1);
    await $.send(X);
    for await (let B of $.stream()) if (B.type === "result") return B;
    throw Error("Session ended without result message");
  } catch (W) {
    var J = W, G = 1;
  } finally {
    var H = L7(Y, J, G);
    H && await H;
  }
}
var import_path, import_url, import_events, import_child_process2, import_readline, h, import_promises, import_path2, import_os, import_path3, import_process, import_fs, import_crypto, import_crypto2, import_fs2, import_path4, import_crypto3, import_path5, import_url2, import_meta, QK, $K, Y9, YK, WK, K7, P, U7, JK, GK, V7, L7, hX, $Y, c, e, R1, lX, mG, KY, UY, mX, Y3, d0, V3, N3, DY, A3, cX, iX, v8, nX, _8, o3, a3, JH, UH, LH, NH, EH, bH, vH, _H, yH, fH, lH, cH, dH, nH, oH, aH, d8, QB, YB, JB, HB, yY, gY, NB, AB, MB, PB, CB, hY, xB, uB, mB, pB, iB, rB, sB, Xz, $z, Wz, Gz, zz, Vz, Nz, Az, wz, cY, kz, Tz, gz, BK, zK, q7, KK, UK, O6, VK, D6, F7, LK, qK, e6, N7, NK, OK, O7, AK, wK, D7, A7, z4, RK, EK, IK, bK, w7, SK, K4, M7, j7, CK, kK, R7, TK, _K, xK, yK, gK, fK, hK, E7, I7, U4, cK, q1, b7, P7, iK, nK, rK, S7, tK, aK, Z7, eK, C7, W9, k7, v7, Z1, WU, JU, T7, _7, x7, y7, g7, KU, f7, h7, u7, C1, l7, m7, c7, p7, J9, DU, k1, i7, o7, Eb, t7, SU, e7, B9, L4, CU, kU, YW, WW, TU, q4, xU, mU, cU, pU, dU, F1, F4, HW, XX, QX, K9, $X, U9, n, UW, E, O1, w, h0, $V, T1, YV, N4, I0, g, R6, C0, L9, q9, o1, WX, Z, r0, VW, p, WV, JV, GV, HV, BV, zV, KV, UV, VV, F9, LV, qV, FV, NV, OV, DV, LW, AV, A1, I6, b6, O4, GX, D4, HX, BX, A4, t1, w1, w4, J1, V0, zX, D1, O9, KX, M1, M4, j4, P6, JX, UX, VX, a1, LX, S6, H1, G1, _1, qX, FX, R4, D9, E4, NX, A2, j, w2, M2, j2, R2, E2, I2, b2, P2, S2, Z2, C2, k2, v2, T2, NW, _2, x2, y2, g2, f2, h2, u2, l2, m2, c2, p2, d2, i2, n2, r2, o2, t2, a2, s2, bV, x1, I4, i, P4, R9, gV, E9, OW, b9, DW, wW, MW, Z4, RX, C9, k9, v9, T9, _9, X6, x9, Q6, jW, RW, EW, IW, bW, PW, SW, ZW, y9, CW, vW, TW, _W, xW, yW, g9, gW, fW, hW, uW, pW, dW, iW, nW, rW, oW, tW, w0, aW, f9, h9, sW, eW, XJ, QJ, $J, EX, YJ, WJ, JJ, GJ, HJ, BJ, zJ, u9, UJ, X0, IX, W0, m9, c9, p9, d9, i9, n9, r9, o9, t9, a9, s9, MJ, jJ, RJ, EJ, e9, XQ, QQ, $Q, YQ, WQ, JQ, GQ, v4, HQ, BQ, zQ, KQ, UQ, VQ, T4, _4, LQ, qQ, FQ, NQ, OQ, DQ, AQ, wQ, MQ, jQ, RQ, EQ, IQ, bQ, PQ, oV, tV, x4, g1, F$, TL, _L, SX, xJ, yJ, gJ, fJ, hJ, WZ, ZX, uJ, lJ, mJ, cJ, z0, nJ, cL, H0, pL, pJ, d4, dL, iL, nL, rL, oL, tL, aL, sL, eL, Xq, Qq, $q, Yq, Wq, Jq, Gq, rJ, Hq, Bq, zq, Kq, Uq, Lq, oJ, tJ, qq, Fq, Nq, j$, Oq, Dq, sJ, Aq, wq, jq, eJ, Iq, Pq, Sq, X5, P$, $5, K1, r4, z1, Y5, W5, Tq, S$, _q, _0, R0, W6, p0, b0, o4, J5, Z$, G5, H5, B5, CX, x, z5, K5, DZ, t4, xq, a4, yq, kX, _6, U5, gq, fq, hq, uq, lq, mq, C$, cq, pq, k$, s4, dq, iq, e4, nq, vX, TX, _X, x6, rq, xX, X8, Q8, $8, Y8, W8, V5, L5, q5, F5, v$, N5, y6, O5, oq, J8, tq, G8, aq, T$, sq, H8, eq, XF, QF, $F, YF, WF, JF, GF, HF, BF, B8, zF, KF, z8, _$, x$, y$, UF, VF, LF, g$, qF, FF, NF, OF, DF, D5, K8, AF, U8, AZ, wF, g6, MF, yX, jF, f$, RF, EF, IF, bF, PF, SF, ZF, n4, CF, kF, vF, h$, u$, TF, _F, xF, yF, gF, fF, hF, uF, lF, mF, cF, pF, dF, iF, nF, rF, oF, tF, V8, aF, sF, eF, L8, XN, QN, $N, l$, YN, wZ, MZ, jZ, RZ, EZ, IZ, k, M5, R5, j5, E5, I5, q8, Z5, WN, JN, p$, t0, GN, gX, u5, d5, i5, s5, e5, KN, UN, i$, LN, t$, fz, hz, eY, X7, Q7, cz, mz, jE, Y7, J7, IE, H4;
var init_sdk = __esm({
  "node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs"() {
    import_path = require("path");
    import_url = require("url");
    import_events = require("events");
    import_child_process2 = require("child_process");
    import_readline = require("readline");
    h = __toESM(require("fs"), 1);
    import_promises = require("fs/promises");
    import_path2 = require("path");
    import_os = require("os");
    import_path3 = require("path");
    import_process = require("process");
    import_fs = require("fs");
    import_crypto = require("crypto");
    import_crypto2 = require("crypto");
    import_fs2 = require("fs");
    import_path4 = require("path");
    import_crypto3 = require("crypto");
    import_path5 = require("path");
    import_url2 = require("url");
    import_meta = {};
    QK = Object.create;
    ({ getPrototypeOf: $K, defineProperty: Y9, getOwnPropertyNames: YK } = Object);
    WK = Object.prototype.hasOwnProperty;
    K7 = (X, Q, $) => {
      $ = X != null ? QK($K(X)) : {};
      let Y = Q || !X || !X.__esModule ? Y9($, "default", { value: X, enumerable: true }) : $;
      for (let W of YK(X)) if (!WK.call(Y, W)) Y9(Y, W, { get: () => X[W], enumerable: true });
      return Y;
    };
    P = (X, Q) => () => (Q || X((Q = { exports: {} }).exports, Q), Q.exports);
    U7 = (X, Q) => {
      for (var $ in Q) Y9(X, $, { get: Q[$], enumerable: true, configurable: true, set: (Y) => Q[$] = () => Y });
    };
    JK = Symbol.dispose || /* @__PURE__ */ Symbol.for("Symbol.dispose");
    GK = Symbol.asyncDispose || /* @__PURE__ */ Symbol.for("Symbol.asyncDispose");
    V7 = (X, Q, $) => {
      if (Q != null) {
        if (typeof Q !== "object" && typeof Q !== "function") throw TypeError('Object expected to be assigned to "using" declaration');
        var Y;
        if ($) Y = Q[GK];
        if (Y === void 0) Y = Q[JK];
        if (typeof Y !== "function") throw TypeError("Object not disposable");
        X.push([$, Y, Q]);
      } else if ($) X.push([$]);
      return Q;
    };
    L7 = (X, Q, $) => {
      var Y = typeof SuppressedError === "function" ? SuppressedError : function(G, H, B, z2) {
        return z2 = Error(B), z2.name = "SuppressedError", z2.error = G, z2.suppressed = H, z2;
      }, W = (G) => Q = $ ? new Y(G, Q, "An error was suppressed during disposal") : ($ = true, G), J = (G) => {
        while (G = X.pop()) try {
          var H = G[1] && G[1].call(G[2]);
          if (G[0]) return Promise.resolve(H).then(J, (B) => (W(B), J()));
        } catch (B) {
          W(B);
        }
        if ($) throw Q;
      };
      return J();
    };
    hX = P((WG) => {
      Object.defineProperty(WG, "__esModule", { value: true });
      WG.regexpCode = WG.getEsmExportName = WG.getProperty = WG.safeStringify = WG.stringify = WG.strConcat = WG.addCodeArg = WG.str = WG._ = WG.nil = WG._Code = WG.Name = WG.IDENTIFIER = WG._CodeOrName = void 0;
      class D8 {
      }
      WG._CodeOrName = D8;
      WG.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class f6 extends D8 {
        constructor(X) {
          super();
          if (!WG.IDENTIFIER.test(X)) throw Error("CodeGen: name must be a valid identifier");
          this.str = X;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      WG.Name = f6;
      class s0 extends D8 {
        constructor(X) {
          super();
          this._items = typeof X === "string" ? [X] : X;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1) return false;
          let X = this._items[0];
          return X === "" || X === '""';
        }
        get str() {
          var X;
          return (X = this._str) !== null && X !== void 0 ? X : this._str = this._items.reduce((Q, $) => `${Q}${$}`, "");
        }
        get names() {
          var X;
          return (X = this._names) !== null && X !== void 0 ? X : this._names = this._items.reduce((Q, $) => {
            if ($ instanceof f6) Q[$.str] = (Q[$.str] || 0) + 1;
            return Q;
          }, {});
        }
      }
      WG._Code = s0;
      WG.nil = new s0("");
      function $G(X, ...Q) {
        let $ = [X[0]], Y = 0;
        while (Y < Q.length) s$($, Q[Y]), $.push(X[++Y]);
        return new s0($);
      }
      WG._ = $G;
      var a$ = new s0("+");
      function YG(X, ...Q) {
        let $ = [fX(X[0])], Y = 0;
        while (Y < Q.length) $.push(a$), s$($, Q[Y]), $.push(a$, fX(X[++Y]));
        return qN($), new s0($);
      }
      WG.str = YG;
      function s$(X, Q) {
        if (Q instanceof s0) X.push(...Q._items);
        else if (Q instanceof f6) X.push(Q);
        else X.push(ON(Q));
      }
      WG.addCodeArg = s$;
      function qN(X) {
        let Q = 1;
        while (Q < X.length - 1) {
          if (X[Q] === a$) {
            let $ = FN(X[Q - 1], X[Q + 1]);
            if ($ !== void 0) {
              X.splice(Q - 1, 3, $);
              continue;
            }
            X[Q++] = "+";
          }
          Q++;
        }
      }
      function FN(X, Q) {
        if (Q === '""') return X;
        if (X === '""') return Q;
        if (typeof X == "string") {
          if (Q instanceof f6 || X[X.length - 1] !== '"') return;
          if (typeof Q != "string") return `${X.slice(0, -1)}${Q}"`;
          if (Q[0] === '"') return X.slice(0, -1) + Q.slice(1);
          return;
        }
        if (typeof Q == "string" && Q[0] === '"' && !(X instanceof f6)) return `"${X}${Q.slice(1)}`;
        return;
      }
      function NN(X, Q) {
        return Q.emptyStr() ? X : X.emptyStr() ? Q : YG`${X}${Q}`;
      }
      WG.strConcat = NN;
      function ON(X) {
        return typeof X == "number" || typeof X == "boolean" || X === null ? X : fX(Array.isArray(X) ? X.join(",") : X);
      }
      function DN(X) {
        return new s0(fX(X));
      }
      WG.stringify = DN;
      function fX(X) {
        return JSON.stringify(X).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      WG.safeStringify = fX;
      function AN(X) {
        return typeof X == "string" && WG.IDENTIFIER.test(X) ? new s0(`.${X}`) : $G`[${X}]`;
      }
      WG.getProperty = AN;
      function wN(X) {
        if (typeof X == "string" && WG.IDENTIFIER.test(X)) return new s0(`${X}`);
        throw Error(`CodeGen: invalid export name: ${X}, use explicit $id name mapping`);
      }
      WG.getEsmExportName = wN;
      function MN(X) {
        return new s0(X.toString());
      }
      WG.regexpCode = MN;
    });
    $Y = P((BG) => {
      Object.defineProperty(BG, "__esModule", { value: true });
      BG.ValueScope = BG.ValueScopeName = BG.Scope = BG.varKinds = BG.UsedValueState = void 0;
      var x0 = hX();
      class GG extends Error {
        constructor(X) {
          super(`CodeGen: "code" for ${X} not defined`);
          this.value = X.value;
        }
      }
      var w8;
      (function(X) {
        X[X.Started = 0] = "Started", X[X.Completed = 1] = "Completed";
      })(w8 || (BG.UsedValueState = w8 = {}));
      BG.varKinds = { const: new x0.Name("const"), let: new x0.Name("let"), var: new x0.Name("var") };
      class XY {
        constructor({ prefixes: X, parent: Q } = {}) {
          this._names = {}, this._prefixes = X, this._parent = Q;
        }
        toName(X) {
          return X instanceof x0.Name ? X : this.name(X);
        }
        name(X) {
          return new x0.Name(this._newName(X));
        }
        _newName(X) {
          let Q = this._names[X] || this._nameGroup(X);
          return `${X}${Q.index++}`;
        }
        _nameGroup(X) {
          var Q, $;
          if ((($ = (Q = this._parent) === null || Q === void 0 ? void 0 : Q._prefixes) === null || $ === void 0 ? void 0 : $.has(X)) || this._prefixes && !this._prefixes.has(X)) throw Error(`CodeGen: prefix "${X}" is not allowed in this scope`);
          return this._names[X] = { prefix: X, index: 0 };
        }
      }
      BG.Scope = XY;
      class QY extends x0.Name {
        constructor(X, Q) {
          super(Q);
          this.prefix = X;
        }
        setValue(X, { property: Q, itemIndex: $ }) {
          this.value = X, this.scopePath = x0._`.${new x0.Name(Q)}[${$}]`;
        }
      }
      BG.ValueScopeName = QY;
      var _N = x0._`\n`;
      class HG extends XY {
        constructor(X) {
          super(X);
          this._values = {}, this._scope = X.scope, this.opts = { ...X, _n: X.lines ? _N : x0.nil };
        }
        get() {
          return this._scope;
        }
        name(X) {
          return new QY(X, this._newName(X));
        }
        value(X, Q) {
          var $;
          if (Q.ref === void 0) throw Error("CodeGen: ref must be passed in value");
          let Y = this.toName(X), { prefix: W } = Y, J = ($ = Q.key) !== null && $ !== void 0 ? $ : Q.ref, G = this._values[W];
          if (G) {
            let z2 = G.get(J);
            if (z2) return z2;
          } else G = this._values[W] = /* @__PURE__ */ new Map();
          G.set(J, Y);
          let H = this._scope[W] || (this._scope[W] = []), B = H.length;
          return H[B] = Q.ref, Y.setValue(Q, { property: W, itemIndex: B }), Y;
        }
        getValue(X, Q) {
          let $ = this._values[X];
          if (!$) return;
          return $.get(Q);
        }
        scopeRefs(X, Q = this._values) {
          return this._reduceValues(Q, ($) => {
            if ($.scopePath === void 0) throw Error(`CodeGen: name "${$}" has no value`);
            return x0._`${X}${$.scopePath}`;
          });
        }
        scopeCode(X = this._values, Q, $) {
          return this._reduceValues(X, (Y) => {
            if (Y.value === void 0) throw Error(`CodeGen: name "${Y}" has no value`);
            return Y.value.code;
          }, Q, $);
        }
        _reduceValues(X, Q, $ = {}, Y) {
          let W = x0.nil;
          for (let J in X) {
            let G = X[J];
            if (!G) continue;
            let H = $[J] = $[J] || /* @__PURE__ */ new Map();
            G.forEach((B) => {
              if (H.has(B)) return;
              H.set(B, w8.Started);
              let z2 = Q(B);
              if (z2) {
                let K = this.opts.es5 ? BG.varKinds.var : BG.varKinds.const;
                W = x0._`${W}${K} ${B} = ${z2};${this.opts._n}`;
              } else if (z2 = Y === null || Y === void 0 ? void 0 : Y(B)) W = x0._`${W}${z2}${this.opts._n}`;
              else throw new GG(B);
              H.set(B, w8.Completed);
            });
          }
          return W;
        }
      }
      BG.ValueScope = HG;
    });
    c = P((y0) => {
      Object.defineProperty(y0, "__esModule", { value: true });
      y0.or = y0.and = y0.not = y0.CodeGen = y0.operators = y0.varKinds = y0.ValueScopeName = y0.ValueScope = y0.Scope = y0.Name = y0.regexpCode = y0.stringify = y0.getProperty = y0.nil = y0.strConcat = y0.str = y0._ = void 0;
      var t = hX(), e0 = $Y(), l1 = hX();
      Object.defineProperty(y0, "_", { enumerable: true, get: function() {
        return l1._;
      } });
      Object.defineProperty(y0, "str", { enumerable: true, get: function() {
        return l1.str;
      } });
      Object.defineProperty(y0, "strConcat", { enumerable: true, get: function() {
        return l1.strConcat;
      } });
      Object.defineProperty(y0, "nil", { enumerable: true, get: function() {
        return l1.nil;
      } });
      Object.defineProperty(y0, "getProperty", { enumerable: true, get: function() {
        return l1.getProperty;
      } });
      Object.defineProperty(y0, "stringify", { enumerable: true, get: function() {
        return l1.stringify;
      } });
      Object.defineProperty(y0, "regexpCode", { enumerable: true, get: function() {
        return l1.regexpCode;
      } });
      Object.defineProperty(y0, "Name", { enumerable: true, get: function() {
        return l1.Name;
      } });
      var b8 = $Y();
      Object.defineProperty(y0, "Scope", { enumerable: true, get: function() {
        return b8.Scope;
      } });
      Object.defineProperty(y0, "ValueScope", { enumerable: true, get: function() {
        return b8.ValueScope;
      } });
      Object.defineProperty(y0, "ValueScopeName", { enumerable: true, get: function() {
        return b8.ValueScopeName;
      } });
      Object.defineProperty(y0, "varKinds", { enumerable: true, get: function() {
        return b8.varKinds;
      } });
      y0.operators = { GT: new t._Code(">"), GTE: new t._Code(">="), LT: new t._Code("<"), LTE: new t._Code("<="), EQ: new t._Code("==="), NEQ: new t._Code("!=="), NOT: new t._Code("!"), OR: new t._Code("||"), AND: new t._Code("&&"), ADD: new t._Code("+") };
      class m1 {
        optimizeNodes() {
          return this;
        }
        optimizeNames(X, Q) {
          return this;
        }
      }
      class KG extends m1 {
        constructor(X, Q, $) {
          super();
          this.varKind = X, this.name = Q, this.rhs = $;
        }
        render({ es5: X, _n: Q }) {
          let $ = X ? e0.varKinds.var : this.varKind, Y = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${$} ${this.name}${Y};` + Q;
        }
        optimizeNames(X, Q) {
          if (!X[this.name.str]) return;
          if (this.rhs) this.rhs = u6(this.rhs, X, Q);
          return this;
        }
        get names() {
          return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
        }
      }
      class JY extends m1 {
        constructor(X, Q, $) {
          super();
          this.lhs = X, this.rhs = Q, this.sideEffects = $;
        }
        render({ _n: X }) {
          return `${this.lhs} = ${this.rhs};` + X;
        }
        optimizeNames(X, Q) {
          if (this.lhs instanceof t.Name && !X[this.lhs.str] && !this.sideEffects) return;
          return this.rhs = u6(this.rhs, X, Q), this;
        }
        get names() {
          let X = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
          return I8(X, this.rhs);
        }
      }
      class UG extends JY {
        constructor(X, Q, $, Y) {
          super(X, $, Y);
          this.op = Q;
        }
        render({ _n: X }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + X;
        }
      }
      class VG extends m1 {
        constructor(X) {
          super();
          this.label = X, this.names = {};
        }
        render({ _n: X }) {
          return `${this.label}:` + X;
        }
      }
      class LG extends m1 {
        constructor(X) {
          super();
          this.label = X, this.names = {};
        }
        render({ _n: X }) {
          return `break${this.label ? ` ${this.label}` : ""};` + X;
        }
      }
      class qG extends m1 {
        constructor(X) {
          super();
          this.error = X;
        }
        render({ _n: X }) {
          return `throw ${this.error};` + X;
        }
        get names() {
          return this.error.names;
        }
      }
      class FG extends m1 {
        constructor(X) {
          super();
          this.code = X;
        }
        render({ _n: X }) {
          return `${this.code};` + X;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(X, Q) {
          return this.code = u6(this.code, X, Q), this;
        }
        get names() {
          return this.code instanceof t._CodeOrName ? this.code.names : {};
        }
      }
      class P8 extends m1 {
        constructor(X = []) {
          super();
          this.nodes = X;
        }
        render(X) {
          return this.nodes.reduce((Q, $) => Q + $.render(X), "");
        }
        optimizeNodes() {
          let { nodes: X } = this, Q = X.length;
          while (Q--) {
            let $ = X[Q].optimizeNodes();
            if (Array.isArray($)) X.splice(Q, 1, ...$);
            else if ($) X[Q] = $;
            else X.splice(Q, 1);
          }
          return X.length > 0 ? this : void 0;
        }
        optimizeNames(X, Q) {
          let { nodes: $ } = this, Y = $.length;
          while (Y--) {
            let W = $[Y];
            if (W.optimizeNames(X, Q)) continue;
            fN(X, W.names), $.splice(Y, 1);
          }
          return $.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((X, Q) => J6(X, Q.names), {});
        }
      }
      class c1 extends P8 {
        render(X) {
          return "{" + X._n + super.render(X) + "}" + X._n;
        }
      }
      class NG extends P8 {
      }
      class uX extends c1 {
      }
      uX.kind = "else";
      class j1 extends c1 {
        constructor(X, Q) {
          super(Q);
          this.condition = X;
        }
        render(X) {
          let Q = `if(${this.condition})` + super.render(X);
          if (this.else) Q += "else " + this.else.render(X);
          return Q;
        }
        optimizeNodes() {
          super.optimizeNodes();
          let X = this.condition;
          if (X === true) return this.nodes;
          let Q = this.else;
          if (Q) {
            let $ = Q.optimizeNodes();
            Q = this.else = Array.isArray($) ? new uX($) : $;
          }
          if (Q) {
            if (X === false) return Q instanceof j1 ? Q : Q.nodes;
            if (this.nodes.length) return this;
            return new j1(MG(X), Q instanceof j1 ? [Q] : Q.nodes);
          }
          if (X === false || !this.nodes.length) return;
          return this;
        }
        optimizeNames(X, Q) {
          var $;
          if (this.else = ($ = this.else) === null || $ === void 0 ? void 0 : $.optimizeNames(X, Q), !(super.optimizeNames(X, Q) || this.else)) return;
          return this.condition = u6(this.condition, X, Q), this;
        }
        get names() {
          let X = super.names;
          if (I8(X, this.condition), this.else) J6(X, this.else.names);
          return X;
        }
      }
      j1.kind = "if";
      class h6 extends c1 {
      }
      h6.kind = "for";
      class OG extends h6 {
        constructor(X) {
          super();
          this.iteration = X;
        }
        render(X) {
          return `for(${this.iteration})` + super.render(X);
        }
        optimizeNames(X, Q) {
          if (!super.optimizeNames(X, Q)) return;
          return this.iteration = u6(this.iteration, X, Q), this;
        }
        get names() {
          return J6(super.names, this.iteration.names);
        }
      }
      class DG extends h6 {
        constructor(X, Q, $, Y) {
          super();
          this.varKind = X, this.name = Q, this.from = $, this.to = Y;
        }
        render(X) {
          let Q = X.es5 ? e0.varKinds.var : this.varKind, { name: $, from: Y, to: W } = this;
          return `for(${Q} ${$}=${Y}; ${$}<${W}; ${$}++)` + super.render(X);
        }
        get names() {
          let X = I8(super.names, this.from);
          return I8(X, this.to);
        }
      }
      class YY extends h6 {
        constructor(X, Q, $, Y) {
          super();
          this.loop = X, this.varKind = Q, this.name = $, this.iterable = Y;
        }
        render(X) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(X);
        }
        optimizeNames(X, Q) {
          if (!super.optimizeNames(X, Q)) return;
          return this.iterable = u6(this.iterable, X, Q), this;
        }
        get names() {
          return J6(super.names, this.iterable.names);
        }
      }
      class M8 extends c1 {
        constructor(X, Q, $) {
          super();
          this.name = X, this.args = Q, this.async = $;
        }
        render(X) {
          return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(X);
        }
      }
      M8.kind = "func";
      class j8 extends P8 {
        render(X) {
          return "return " + super.render(X);
        }
      }
      j8.kind = "return";
      class AG extends c1 {
        render(X) {
          let Q = "try" + super.render(X);
          if (this.catch) Q += this.catch.render(X);
          if (this.finally) Q += this.finally.render(X);
          return Q;
        }
        optimizeNodes() {
          var X, Q;
          return super.optimizeNodes(), (X = this.catch) === null || X === void 0 || X.optimizeNodes(), (Q = this.finally) === null || Q === void 0 || Q.optimizeNodes(), this;
        }
        optimizeNames(X, Q) {
          var $, Y;
          return super.optimizeNames(X, Q), ($ = this.catch) === null || $ === void 0 || $.optimizeNames(X, Q), (Y = this.finally) === null || Y === void 0 || Y.optimizeNames(X, Q), this;
        }
        get names() {
          let X = super.names;
          if (this.catch) J6(X, this.catch.names);
          if (this.finally) J6(X, this.finally.names);
          return X;
        }
      }
      class R8 extends c1 {
        constructor(X) {
          super();
          this.error = X;
        }
        render(X) {
          return `catch(${this.error})` + super.render(X);
        }
      }
      R8.kind = "catch";
      class E8 extends c1 {
        render(X) {
          return "finally" + super.render(X);
        }
      }
      E8.kind = "finally";
      class wG {
        constructor(X, Q = {}) {
          this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Q, _n: Q.lines ? `
` : "" }, this._extScope = X, this._scope = new e0.Scope({ parent: X }), this._nodes = [new NG()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        name(X) {
          return this._scope.name(X);
        }
        scopeName(X) {
          return this._extScope.name(X);
        }
        scopeValue(X, Q) {
          let $ = this._extScope.value(X, Q);
          return (this._values[$.prefix] || (this._values[$.prefix] = /* @__PURE__ */ new Set())).add($), $;
        }
        getScopeValue(X, Q) {
          return this._extScope.getValue(X, Q);
        }
        scopeRefs(X) {
          return this._extScope.scopeRefs(X, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(X, Q, $, Y) {
          let W = this._scope.toName(Q);
          if ($ !== void 0 && Y) this._constants[W.str] = $;
          return this._leafNode(new KG(X, W, $)), W;
        }
        const(X, Q, $) {
          return this._def(e0.varKinds.const, X, Q, $);
        }
        let(X, Q, $) {
          return this._def(e0.varKinds.let, X, Q, $);
        }
        var(X, Q, $) {
          return this._def(e0.varKinds.var, X, Q, $);
        }
        assign(X, Q, $) {
          return this._leafNode(new JY(X, Q, $));
        }
        add(X, Q) {
          return this._leafNode(new UG(X, y0.operators.ADD, Q));
        }
        code(X) {
          if (typeof X == "function") X();
          else if (X !== t.nil) this._leafNode(new FG(X));
          return this;
        }
        object(...X) {
          let Q = ["{"];
          for (let [$, Y] of X) {
            if (Q.length > 1) Q.push(",");
            if (Q.push($), $ !== Y || this.opts.es5) Q.push(":"), (0, t.addCodeArg)(Q, Y);
          }
          return Q.push("}"), new t._Code(Q);
        }
        if(X, Q, $) {
          if (this._blockNode(new j1(X)), Q && $) this.code(Q).else().code($).endIf();
          else if (Q) this.code(Q).endIf();
          else if ($) throw Error('CodeGen: "else" body without "then" body');
          return this;
        }
        elseIf(X) {
          return this._elseNode(new j1(X));
        }
        else() {
          return this._elseNode(new uX());
        }
        endIf() {
          return this._endBlockNode(j1, uX);
        }
        _for(X, Q) {
          if (this._blockNode(X), Q) this.code(Q).endFor();
          return this;
        }
        for(X, Q) {
          return this._for(new OG(X), Q);
        }
        forRange(X, Q, $, Y, W = this.opts.es5 ? e0.varKinds.var : e0.varKinds.let) {
          let J = this._scope.toName(X);
          return this._for(new DG(W, J, Q, $), () => Y(J));
        }
        forOf(X, Q, $, Y = e0.varKinds.const) {
          let W = this._scope.toName(X);
          if (this.opts.es5) {
            let J = Q instanceof t.Name ? Q : this.var("_arr", Q);
            return this.forRange("_i", 0, t._`${J}.length`, (G) => {
              this.var(W, t._`${J}[${G}]`), $(W);
            });
          }
          return this._for(new YY("of", Y, W, Q), () => $(W));
        }
        forIn(X, Q, $, Y = this.opts.es5 ? e0.varKinds.var : e0.varKinds.const) {
          if (this.opts.ownProperties) return this.forOf(X, t._`Object.keys(${Q})`, $);
          let W = this._scope.toName(X);
          return this._for(new YY("in", Y, W, Q), () => $(W));
        }
        endFor() {
          return this._endBlockNode(h6);
        }
        label(X) {
          return this._leafNode(new VG(X));
        }
        break(X) {
          return this._leafNode(new LG(X));
        }
        return(X) {
          let Q = new j8();
          if (this._blockNode(Q), this.code(X), Q.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
          return this._endBlockNode(j8);
        }
        try(X, Q, $) {
          if (!Q && !$) throw Error('CodeGen: "try" without "catch" and "finally"');
          let Y = new AG();
          if (this._blockNode(Y), this.code(X), Q) {
            let W = this.name("e");
            this._currNode = Y.catch = new R8(W), Q(W);
          }
          if ($) this._currNode = Y.finally = new E8(), this.code($);
          return this._endBlockNode(R8, E8);
        }
        throw(X) {
          return this._leafNode(new qG(X));
        }
        block(X, Q) {
          if (this._blockStarts.push(this._nodes.length), X) this.code(X).endBlock(Q);
          return this;
        }
        endBlock(X) {
          let Q = this._blockStarts.pop();
          if (Q === void 0) throw Error("CodeGen: not in self-balancing block");
          let $ = this._nodes.length - Q;
          if ($ < 0 || X !== void 0 && $ !== X) throw Error(`CodeGen: wrong number of nodes: ${$} vs ${X} expected`);
          return this._nodes.length = Q, this;
        }
        func(X, Q = t.nil, $, Y) {
          if (this._blockNode(new M8(X, Q, $)), Y) this.code(Y).endFunc();
          return this;
        }
        endFunc() {
          return this._endBlockNode(M8);
        }
        optimize(X = 1) {
          while (X-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
        }
        _leafNode(X) {
          return this._currNode.nodes.push(X), this;
        }
        _blockNode(X) {
          this._currNode.nodes.push(X), this._nodes.push(X);
        }
        _endBlockNode(X, Q) {
          let $ = this._currNode;
          if ($ instanceof X || Q && $ instanceof Q) return this._nodes.pop(), this;
          throw Error(`CodeGen: not in block "${Q ? `${X.kind}/${Q.kind}` : X.kind}"`);
        }
        _elseNode(X) {
          let Q = this._currNode;
          if (!(Q instanceof j1)) throw Error('CodeGen: "else" without "if"');
          return this._currNode = Q.else = X, this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          let X = this._nodes;
          return X[X.length - 1];
        }
        set _currNode(X) {
          let Q = this._nodes;
          Q[Q.length - 1] = X;
        }
      }
      y0.CodeGen = wG;
      function J6(X, Q) {
        for (let $ in Q) X[$] = (X[$] || 0) + (Q[$] || 0);
        return X;
      }
      function I8(X, Q) {
        return Q instanceof t._CodeOrName ? J6(X, Q.names) : X;
      }
      function u6(X, Q, $) {
        if (X instanceof t.Name) return Y(X);
        if (!W(X)) return X;
        return new t._Code(X._items.reduce((J, G) => {
          if (G instanceof t.Name) G = Y(G);
          if (G instanceof t._Code) J.push(...G._items);
          else J.push(G);
          return J;
        }, []));
        function Y(J) {
          let G = $[J.str];
          if (G === void 0 || Q[J.str] !== 1) return J;
          return delete Q[J.str], G;
        }
        function W(J) {
          return J instanceof t._Code && J._items.some((G) => G instanceof t.Name && Q[G.str] === 1 && $[G.str] !== void 0);
        }
      }
      function fN(X, Q) {
        for (let $ in Q) X[$] = (X[$] || 0) - (Q[$] || 0);
      }
      function MG(X) {
        return typeof X == "boolean" || typeof X == "number" || X === null ? !X : t._`!${WY(X)}`;
      }
      y0.not = MG;
      var hN = jG(y0.operators.AND);
      function uN(...X) {
        return X.reduce(hN);
      }
      y0.and = uN;
      var lN = jG(y0.operators.OR);
      function mN(...X) {
        return X.reduce(lN);
      }
      y0.or = mN;
      function jG(X) {
        return (Q, $) => Q === t.nil ? $ : $ === t.nil ? Q : t._`${WY(Q)} ${X} ${WY($)}`;
      }
      function WY(X) {
        return X instanceof t.Name ? X : t._`(${X})`;
      }
    });
    e = P((kG) => {
      Object.defineProperty(kG, "__esModule", { value: true });
      kG.checkStrictMode = kG.getErrorPath = kG.Type = kG.useFunc = kG.setEvaluated = kG.evaluatedPropsToName = kG.mergeEvaluated = kG.eachItem = kG.unescapeJsonPointer = kG.escapeJsonPointer = kG.escapeFragment = kG.unescapeFragment = kG.schemaRefOrVal = kG.schemaHasRulesButRef = kG.schemaHasRules = kG.checkUnknownRules = kG.alwaysValidSchema = kG.toHash = void 0;
      var $0 = c(), iN = hX();
      function nN(X) {
        let Q = {};
        for (let $ of X) Q[$] = true;
        return Q;
      }
      kG.toHash = nN;
      function rN(X, Q) {
        if (typeof Q == "boolean") return Q;
        if (Object.keys(Q).length === 0) return true;
        return bG(X, Q), !PG(Q, X.self.RULES.all);
      }
      kG.alwaysValidSchema = rN;
      function bG(X, Q = X.schema) {
        let { opts: $, self: Y } = X;
        if (!$.strictSchema) return;
        if (typeof Q === "boolean") return;
        let W = Y.RULES.keywords;
        for (let J in Q) if (!W[J]) CG(X, `unknown keyword: "${J}"`);
      }
      kG.checkUnknownRules = bG;
      function PG(X, Q) {
        if (typeof X == "boolean") return !X;
        for (let $ in X) if (Q[$]) return true;
        return false;
      }
      kG.schemaHasRules = PG;
      function oN(X, Q) {
        if (typeof X == "boolean") return !X;
        for (let $ in X) if ($ !== "$ref" && Q.all[$]) return true;
        return false;
      }
      kG.schemaHasRulesButRef = oN;
      function tN({ topSchemaRef: X, schemaPath: Q }, $, Y, W) {
        if (!W) {
          if (typeof $ == "number" || typeof $ == "boolean") return $;
          if (typeof $ == "string") return $0._`${$}`;
        }
        return $0._`${X}${Q}${(0, $0.getProperty)(Y)}`;
      }
      kG.schemaRefOrVal = tN;
      function aN(X) {
        return SG(decodeURIComponent(X));
      }
      kG.unescapeFragment = aN;
      function sN(X) {
        return encodeURIComponent(HY(X));
      }
      kG.escapeFragment = sN;
      function HY(X) {
        if (typeof X == "number") return `${X}`;
        return X.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      kG.escapeJsonPointer = HY;
      function SG(X) {
        return X.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      kG.unescapeJsonPointer = SG;
      function eN(X, Q) {
        if (Array.isArray(X)) for (let $ of X) Q($);
        else Q(X);
      }
      kG.eachItem = eN;
      function EG({ mergeNames: X, mergeToName: Q, mergeValues: $, resultToName: Y }) {
        return (W, J, G, H) => {
          let B = G === void 0 ? J : G instanceof $0.Name ? (J instanceof $0.Name ? X(W, J, G) : Q(W, J, G), G) : J instanceof $0.Name ? (Q(W, G, J), J) : $(J, G);
          return H === $0.Name && !(B instanceof $0.Name) ? Y(W, B) : B;
        };
      }
      kG.mergeEvaluated = { props: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => {
        X.if($0._`${Q} === true`, () => X.assign($, true), () => X.assign($, $0._`${$} || {}`).code($0._`Object.assign(${$}, ${Q})`));
      }), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => {
        if (Q === true) X.assign($, true);
        else X.assign($, $0._`${$} || {}`), BY(X, $, Q);
      }), mergeValues: (X, Q) => X === true ? true : { ...X, ...Q }, resultToName: ZG }), items: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => X.assign($, $0._`${Q} === true ? true : ${$} > ${Q} ? ${$} : ${Q}`)), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => X.assign($, Q === true ? true : $0._`${$} > ${Q} ? ${$} : ${Q}`)), mergeValues: (X, Q) => X === true ? true : Math.max(X, Q), resultToName: (X, Q) => X.var("items", Q) }) };
      function ZG(X, Q) {
        if (Q === true) return X.var("props", true);
        let $ = X.var("props", $0._`{}`);
        if (Q !== void 0) BY(X, $, Q);
        return $;
      }
      kG.evaluatedPropsToName = ZG;
      function BY(X, Q, $) {
        Object.keys($).forEach((Y) => X.assign($0._`${Q}${(0, $0.getProperty)(Y)}`, true));
      }
      kG.setEvaluated = BY;
      var IG = {};
      function XO(X, Q) {
        return X.scopeValue("func", { ref: Q, code: IG[Q.code] || (IG[Q.code] = new iN._Code(Q.code)) });
      }
      kG.useFunc = XO;
      var GY;
      (function(X) {
        X[X.Num = 0] = "Num", X[X.Str = 1] = "Str";
      })(GY || (kG.Type = GY = {}));
      function QO(X, Q, $) {
        if (X instanceof $0.Name) {
          let Y = Q === GY.Num;
          return $ ? Y ? $0._`"[" + ${X} + "]"` : $0._`"['" + ${X} + "']"` : Y ? $0._`"/" + ${X}` : $0._`"/" + ${X}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return $ ? (0, $0.getProperty)(X).toString() : "/" + HY(X);
      }
      kG.getErrorPath = QO;
      function CG(X, Q, $ = X.opts.strictSchema) {
        if (!$) return;
        if (Q = `strict mode: ${Q}`, $ === true) throw Error(Q);
        X.self.logger.warn(Q);
      }
      kG.checkStrictMode = CG;
    });
    R1 = P((TG) => {
      Object.defineProperty(TG, "__esModule", { value: true });
      var P0 = c(), AO = { data: new P0.Name("data"), valCxt: new P0.Name("valCxt"), instancePath: new P0.Name("instancePath"), parentData: new P0.Name("parentData"), parentDataProperty: new P0.Name("parentDataProperty"), rootData: new P0.Name("rootData"), dynamicAnchors: new P0.Name("dynamicAnchors"), vErrors: new P0.Name("vErrors"), errors: new P0.Name("errors"), this: new P0.Name("this"), self: new P0.Name("self"), scope: new P0.Name("scope"), json: new P0.Name("json"), jsonPos: new P0.Name("jsonPos"), jsonLen: new P0.Name("jsonLen"), jsonPart: new P0.Name("jsonPart") };
      TG.default = AO;
    });
    lX = P((gG) => {
      Object.defineProperty(gG, "__esModule", { value: true });
      gG.extendErrors = gG.resetErrorsCount = gG.reportExtraError = gG.reportError = gG.keyword$DataError = gG.keywordError = void 0;
      var a = c(), Z8 = e(), v0 = R1();
      gG.keywordError = { message: ({ keyword: X }) => a.str`must pass "${X}" keyword validation` };
      gG.keyword$DataError = { message: ({ keyword: X, schemaType: Q }) => Q ? a.str`"${X}" keyword must be ${Q} ($data)` : a.str`"${X}" keyword is invalid ($data)` };
      function MO(X, Q = gG.keywordError, $, Y) {
        let { it: W } = X, { gen: J, compositeRule: G, allErrors: H } = W, B = yG(X, Q, $);
        if (Y !== null && Y !== void 0 ? Y : G || H) _G(J, B);
        else xG(W, a._`[${B}]`);
      }
      gG.reportError = MO;
      function jO(X, Q = gG.keywordError, $) {
        let { it: Y } = X, { gen: W, compositeRule: J, allErrors: G } = Y, H = yG(X, Q, $);
        if (_G(W, H), !(J || G)) xG(Y, v0.default.vErrors);
      }
      gG.reportExtraError = jO;
      function RO(X, Q) {
        X.assign(v0.default.errors, Q), X.if(a._`${v0.default.vErrors} !== null`, () => X.if(Q, () => X.assign(a._`${v0.default.vErrors}.length`, Q), () => X.assign(v0.default.vErrors, null)));
      }
      gG.resetErrorsCount = RO;
      function EO({ gen: X, keyword: Q, schemaValue: $, data: Y, errsCount: W, it: J }) {
        if (W === void 0) throw Error("ajv implementation error");
        let G = X.name("err");
        X.forRange("i", W, v0.default.errors, (H) => {
          if (X.const(G, a._`${v0.default.vErrors}[${H}]`), X.if(a._`${G}.instancePath === undefined`, () => X.assign(a._`${G}.instancePath`, (0, a.strConcat)(v0.default.instancePath, J.errorPath))), X.assign(a._`${G}.schemaPath`, a.str`${J.errSchemaPath}/${Q}`), J.opts.verbose) X.assign(a._`${G}.schema`, $), X.assign(a._`${G}.data`, Y);
        });
      }
      gG.extendErrors = EO;
      function _G(X, Q) {
        let $ = X.const("err", Q);
        X.if(a._`${v0.default.vErrors} === null`, () => X.assign(v0.default.vErrors, a._`[${$}]`), a._`${v0.default.vErrors}.push(${$})`), X.code(a._`${v0.default.errors}++`);
      }
      function xG(X, Q) {
        let { gen: $, validateName: Y, schemaEnv: W } = X;
        if (W.$async) $.throw(a._`new ${X.ValidationError}(${Q})`);
        else $.assign(a._`${Y}.errors`, Q), $.return(false);
      }
      var G6 = { keyword: new a.Name("keyword"), schemaPath: new a.Name("schemaPath"), params: new a.Name("params"), propertyName: new a.Name("propertyName"), message: new a.Name("message"), schema: new a.Name("schema"), parentSchema: new a.Name("parentSchema") };
      function yG(X, Q, $) {
        let { createErrors: Y } = X.it;
        if (Y === false) return a._`{}`;
        return IO(X, Q, $);
      }
      function IO(X, Q, $ = {}) {
        let { gen: Y, it: W } = X, J = [bO(W, $), PO(X, $)];
        return SO(X, Q, J), Y.object(...J);
      }
      function bO({ errorPath: X }, { instancePath: Q }) {
        let $ = Q ? a.str`${X}${(0, Z8.getErrorPath)(Q, Z8.Type.Str)}` : X;
        return [v0.default.instancePath, (0, a.strConcat)(v0.default.instancePath, $)];
      }
      function PO({ keyword: X, it: { errSchemaPath: Q } }, { schemaPath: $, parentSchema: Y }) {
        let W = Y ? Q : a.str`${Q}/${X}`;
        if ($) W = a.str`${W}${(0, Z8.getErrorPath)($, Z8.Type.Str)}`;
        return [G6.schemaPath, W];
      }
      function SO(X, { params: Q, message: $ }, Y) {
        let { keyword: W, data: J, schemaValue: G, it: H } = X, { opts: B, propertyName: z2, topSchemaRef: K, schemaPath: V } = H;
        if (Y.push([G6.keyword, W], [G6.params, typeof Q == "function" ? Q(X) : Q || a._`{}`]), B.messages) Y.push([G6.message, typeof $ == "function" ? $(X) : $]);
        if (B.verbose) Y.push([G6.schema, G], [G6.parentSchema, a._`${K}${V}`], [v0.default.data, J]);
        if (z2) Y.push([G6.propertyName, z2]);
      }
    });
    mG = P((uG) => {
      Object.defineProperty(uG, "__esModule", { value: true });
      uG.boolOrEmptySchema = uG.topBoolOrEmptySchema = void 0;
      var TO = lX(), _O = c(), xO = R1(), yO = { message: "boolean schema is false" };
      function gO(X) {
        let { gen: Q, schema: $, validateName: Y } = X;
        if ($ === false) hG(X, false);
        else if (typeof $ == "object" && $.$async === true) Q.return(xO.default.data);
        else Q.assign(_O._`${Y}.errors`, null), Q.return(true);
      }
      uG.topBoolOrEmptySchema = gO;
      function fO(X, Q) {
        let { gen: $, schema: Y } = X;
        if (Y === false) $.var(Q, false), hG(X);
        else $.var(Q, true);
      }
      uG.boolOrEmptySchema = fO;
      function hG(X, Q) {
        let { gen: $, data: Y } = X, W = { gen: $, keyword: "false schema", data: Y, schema: false, schemaCode: false, schemaValue: false, params: {}, it: X };
        (0, TO.reportError)(W, yO, void 0, Q);
      }
    });
    KY = P((cG) => {
      Object.defineProperty(cG, "__esModule", { value: true });
      cG.getRules = cG.isJSONType = void 0;
      var uO = ["string", "number", "integer", "boolean", "null", "object", "array"], lO = new Set(uO);
      function mO(X) {
        return typeof X == "string" && lO.has(X);
      }
      cG.isJSONType = mO;
      function cO() {
        let X = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } };
        return { types: { ...X, integer: true, boolean: true, null: true }, rules: [{ rules: [] }, X.number, X.string, X.array, X.object], post: { rules: [] }, all: {}, keywords: {} };
      }
      cG.getRules = cO;
    });
    UY = P((nG) => {
      Object.defineProperty(nG, "__esModule", { value: true });
      nG.shouldUseRule = nG.shouldUseGroup = nG.schemaHasRulesForType = void 0;
      function dO({ schema: X, self: Q }, $) {
        let Y = Q.RULES.types[$];
        return Y && Y !== true && dG(X, Y);
      }
      nG.schemaHasRulesForType = dO;
      function dG(X, Q) {
        return Q.rules.some(($) => iG(X, $));
      }
      nG.shouldUseGroup = dG;
      function iG(X, Q) {
        var $;
        return X[Q.keyword] !== void 0 || (($ = Q.definition.implements) === null || $ === void 0 ? void 0 : $.some((Y) => X[Y] !== void 0));
      }
      nG.shouldUseRule = iG;
    });
    mX = P((sG) => {
      Object.defineProperty(sG, "__esModule", { value: true });
      sG.reportTypeError = sG.checkDataTypes = sG.checkDataType = sG.coerceAndCheckDataType = sG.getJSONTypes = sG.getSchemaTypes = sG.DataType = void 0;
      var rO = KY(), oO = UY(), tO = lX(), m = c(), oG = e(), l6;
      (function(X) {
        X[X.Correct = 0] = "Correct", X[X.Wrong = 1] = "Wrong";
      })(l6 || (sG.DataType = l6 = {}));
      function aO(X) {
        let Q = tG(X.type);
        if (Q.includes("null")) {
          if (X.nullable === false) throw Error("type: null contradicts nullable: false");
        } else {
          if (!Q.length && X.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
          if (X.nullable === true) Q.push("null");
        }
        return Q;
      }
      sG.getSchemaTypes = aO;
      function tG(X) {
        let Q = Array.isArray(X) ? X : X ? [X] : [];
        if (Q.every(rO.isJSONType)) return Q;
        throw Error("type must be JSONType or JSONType[]: " + Q.join(","));
      }
      sG.getJSONTypes = tG;
      function sO(X, Q) {
        let { gen: $, data: Y, opts: W } = X, J = eO(Q, W.coerceTypes), G = Q.length > 0 && !(J.length === 0 && Q.length === 1 && (0, oO.schemaHasRulesForType)(X, Q[0]));
        if (G) {
          let H = LY(Q, Y, W.strictNumbers, l6.Wrong);
          $.if(H, () => {
            if (J.length) XD(X, Q, J);
            else qY(X);
          });
        }
        return G;
      }
      sG.coerceAndCheckDataType = sO;
      var aG = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function eO(X, Q) {
        return Q ? X.filter(($) => aG.has($) || Q === "array" && $ === "array") : [];
      }
      function XD(X, Q, $) {
        let { gen: Y, data: W, opts: J } = X, G = Y.let("dataType", m._`typeof ${W}`), H = Y.let("coerced", m._`undefined`);
        if (J.coerceTypes === "array") Y.if(m._`${G} == 'object' && Array.isArray(${W}) && ${W}.length == 1`, () => Y.assign(W, m._`${W}[0]`).assign(G, m._`typeof ${W}`).if(LY(Q, W, J.strictNumbers), () => Y.assign(H, W)));
        Y.if(m._`${H} !== undefined`);
        for (let z2 of $) if (aG.has(z2) || z2 === "array" && J.coerceTypes === "array") B(z2);
        Y.else(), qY(X), Y.endIf(), Y.if(m._`${H} !== undefined`, () => {
          Y.assign(W, H), QD(X, H);
        });
        function B(z2) {
          switch (z2) {
            case "string":
              Y.elseIf(m._`${G} == "number" || ${G} == "boolean"`).assign(H, m._`"" + ${W}`).elseIf(m._`${W} === null`).assign(H, m._`""`);
              return;
            case "number":
              Y.elseIf(m._`${G} == "boolean" || ${W} === null
              || (${G} == "string" && ${W} && ${W} == +${W})`).assign(H, m._`+${W}`);
              return;
            case "integer":
              Y.elseIf(m._`${G} === "boolean" || ${W} === null
              || (${G} === "string" && ${W} && ${W} == +${W} && !(${W} % 1))`).assign(H, m._`+${W}`);
              return;
            case "boolean":
              Y.elseIf(m._`${W} === "false" || ${W} === 0 || ${W} === null`).assign(H, false).elseIf(m._`${W} === "true" || ${W} === 1`).assign(H, true);
              return;
            case "null":
              Y.elseIf(m._`${W} === "" || ${W} === 0 || ${W} === false`), Y.assign(H, null);
              return;
            case "array":
              Y.elseIf(m._`${G} === "string" || ${G} === "number"
              || ${G} === "boolean" || ${W} === null`).assign(H, m._`[${W}]`);
          }
        }
      }
      function QD({ gen: X, parentData: Q, parentDataProperty: $ }, Y) {
        X.if(m._`${Q} !== undefined`, () => X.assign(m._`${Q}[${$}]`, Y));
      }
      function VY(X, Q, $, Y = l6.Correct) {
        let W = Y === l6.Correct ? m.operators.EQ : m.operators.NEQ, J;
        switch (X) {
          case "null":
            return m._`${Q} ${W} null`;
          case "array":
            J = m._`Array.isArray(${Q})`;
            break;
          case "object":
            J = m._`${Q} && typeof ${Q} == "object" && !Array.isArray(${Q})`;
            break;
          case "integer":
            J = G(m._`!(${Q} % 1) && !isNaN(${Q})`);
            break;
          case "number":
            J = G();
            break;
          default:
            return m._`typeof ${Q} ${W} ${X}`;
        }
        return Y === l6.Correct ? J : (0, m.not)(J);
        function G(H = m.nil) {
          return (0, m.and)(m._`typeof ${Q} == "number"`, H, $ ? m._`isFinite(${Q})` : m.nil);
        }
      }
      sG.checkDataType = VY;
      function LY(X, Q, $, Y) {
        if (X.length === 1) return VY(X[0], Q, $, Y);
        let W, J = (0, oG.toHash)(X);
        if (J.array && J.object) {
          let G = m._`typeof ${Q} != "object"`;
          W = J.null ? G : m._`!${Q} || ${G}`, delete J.null, delete J.array, delete J.object;
        } else W = m.nil;
        if (J.number) delete J.integer;
        for (let G in J) W = (0, m.and)(W, VY(G, Q, $, Y));
        return W;
      }
      sG.checkDataTypes = LY;
      var $D = { message: ({ schema: X }) => `must be ${X}`, params: ({ schema: X, schemaValue: Q }) => typeof X == "string" ? m._`{type: ${X}}` : m._`{type: ${Q}}` };
      function qY(X) {
        let Q = YD(X);
        (0, tO.reportError)(Q, $D);
      }
      sG.reportTypeError = qY;
      function YD(X) {
        let { gen: Q, data: $, schema: Y } = X, W = (0, oG.schemaRefOrVal)(X, Y, "type");
        return { gen: Q, keyword: "type", data: $, schema: Y.type, schemaCode: W, schemaValue: W, parentSchema: Y, params: {}, it: X };
      }
    });
    Y3 = P((Q3) => {
      Object.defineProperty(Q3, "__esModule", { value: true });
      Q3.assignDefaults = void 0;
      var m6 = c(), KD = e();
      function UD(X, Q) {
        let { properties: $, items: Y } = X.schema;
        if (Q === "object" && $) for (let W in $) X3(X, W, $[W].default);
        else if (Q === "array" && Array.isArray(Y)) Y.forEach((W, J) => X3(X, J, W.default));
      }
      Q3.assignDefaults = UD;
      function X3(X, Q, $) {
        let { gen: Y, compositeRule: W, data: J, opts: G } = X;
        if ($ === void 0) return;
        let H = m6._`${J}${(0, m6.getProperty)(Q)}`;
        if (W) {
          (0, KD.checkStrictMode)(X, `default is ignored for: ${H}`);
          return;
        }
        let B = m6._`${H} === undefined`;
        if (G.useDefaults === "empty") B = m6._`${B} || ${H} === null || ${H} === ""`;
        Y.if(B, m6._`${H} = ${(0, m6.stringify)($)}`);
      }
    });
    d0 = P((G3) => {
      Object.defineProperty(G3, "__esModule", { value: true });
      G3.validateUnion = G3.validateArray = G3.usePattern = G3.callValidateCode = G3.schemaProperties = G3.allSchemaProperties = G3.noPropertyInData = G3.propertyInData = G3.isOwnProperty = G3.hasPropFunc = G3.reportMissingProp = G3.checkMissingProp = G3.checkReportMissingProp = void 0;
      var G0 = c(), FY = e(), p1 = R1(), VD = e();
      function LD(X, Q) {
        let { gen: $, data: Y, it: W } = X;
        $.if(OY($, Y, Q, W.opts.ownProperties), () => {
          X.setParams({ missingProperty: G0._`${Q}` }, true), X.error();
        });
      }
      G3.checkReportMissingProp = LD;
      function qD({ gen: X, data: Q, it: { opts: $ } }, Y, W) {
        return (0, G0.or)(...Y.map((J) => (0, G0.and)(OY(X, Q, J, $.ownProperties), G0._`${W} = ${J}`)));
      }
      G3.checkMissingProp = qD;
      function FD(X, Q) {
        X.setParams({ missingProperty: Q }, true), X.error();
      }
      G3.reportMissingProp = FD;
      function W3(X) {
        return X.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: G0._`Object.prototype.hasOwnProperty` });
      }
      G3.hasPropFunc = W3;
      function NY(X, Q, $) {
        return G0._`${W3(X)}.call(${Q}, ${$})`;
      }
      G3.isOwnProperty = NY;
      function ND(X, Q, $, Y) {
        let W = G0._`${Q}${(0, G0.getProperty)($)} !== undefined`;
        return Y ? G0._`${W} && ${NY(X, Q, $)}` : W;
      }
      G3.propertyInData = ND;
      function OY(X, Q, $, Y) {
        let W = G0._`${Q}${(0, G0.getProperty)($)} === undefined`;
        return Y ? (0, G0.or)(W, (0, G0.not)(NY(X, Q, $))) : W;
      }
      G3.noPropertyInData = OY;
      function J3(X) {
        return X ? Object.keys(X).filter((Q) => Q !== "__proto__") : [];
      }
      G3.allSchemaProperties = J3;
      function OD(X, Q) {
        return J3(Q).filter(($) => !(0, FY.alwaysValidSchema)(X, Q[$]));
      }
      G3.schemaProperties = OD;
      function DD({ schemaCode: X, data: Q, it: { gen: $, topSchemaRef: Y, schemaPath: W, errorPath: J }, it: G }, H, B, z2) {
        let K = z2 ? G0._`${X}, ${Q}, ${Y}${W}` : Q, V = [[p1.default.instancePath, (0, G0.strConcat)(p1.default.instancePath, J)], [p1.default.parentData, G.parentData], [p1.default.parentDataProperty, G.parentDataProperty], [p1.default.rootData, p1.default.rootData]];
        if (G.opts.dynamicRef) V.push([p1.default.dynamicAnchors, p1.default.dynamicAnchors]);
        let L = G0._`${K}, ${$.object(...V)}`;
        return B !== G0.nil ? G0._`${H}.call(${B}, ${L})` : G0._`${H}(${L})`;
      }
      G3.callValidateCode = DD;
      var AD = G0._`new RegExp`;
      function wD({ gen: X, it: { opts: Q } }, $) {
        let Y = Q.unicodeRegExp ? "u" : "", { regExp: W } = Q.code, J = W($, Y);
        return X.scopeValue("pattern", { key: J.toString(), ref: J, code: G0._`${W.code === "new RegExp" ? AD : (0, VD.useFunc)(X, W)}(${$}, ${Y})` });
      }
      G3.usePattern = wD;
      function MD(X) {
        let { gen: Q, data: $, keyword: Y, it: W } = X, J = Q.name("valid");
        if (W.allErrors) {
          let H = Q.let("valid", true);
          return G(() => Q.assign(H, false)), H;
        }
        return Q.var(J, true), G(() => Q.break()), J;
        function G(H) {
          let B = Q.const("len", G0._`${$}.length`);
          Q.forRange("i", 0, B, (z2) => {
            X.subschema({ keyword: Y, dataProp: z2, dataPropType: FY.Type.Num }, J), Q.if((0, G0.not)(J), H);
          });
        }
      }
      G3.validateArray = MD;
      function jD(X) {
        let { gen: Q, schema: $, keyword: Y, it: W } = X;
        if (!Array.isArray($)) throw Error("ajv implementation error");
        if ($.some((B) => (0, FY.alwaysValidSchema)(W, B)) && !W.opts.unevaluated) return;
        let G = Q.let("valid", false), H = Q.name("_valid");
        Q.block(() => $.forEach((B, z2) => {
          let K = X.subschema({ keyword: Y, schemaProp: z2, compositeRule: true }, H);
          if (Q.assign(G, G0._`${G} || ${H}`), !X.mergeValidEvaluated(K, H)) Q.if((0, G0.not)(G));
        })), X.result(G, () => X.reset(), () => X.error(true));
      }
      G3.validateUnion = jD;
    });
    V3 = P((K3) => {
      Object.defineProperty(K3, "__esModule", { value: true });
      K3.validateKeywordUsage = K3.validSchemaType = K3.funcKeywordCode = K3.macroKeywordCode = void 0;
      var T0 = c(), H6 = R1(), xD = d0(), yD = lX();
      function gD(X, Q) {
        let { gen: $, keyword: Y, schema: W, parentSchema: J, it: G } = X, H = Q.macro.call(G.self, W, J, G), B = z3($, Y, H);
        if (G.opts.validateSchema !== false) G.self.validateSchema(H, true);
        let z2 = $.name("valid");
        X.subschema({ schema: H, schemaPath: T0.nil, errSchemaPath: `${G.errSchemaPath}/${Y}`, topSchemaRef: B, compositeRule: true }, z2), X.pass(z2, () => X.error(true));
      }
      K3.macroKeywordCode = gD;
      function fD(X, Q) {
        var $;
        let { gen: Y, keyword: W, schema: J, parentSchema: G, $data: H, it: B } = X;
        uD(B, Q);
        let z2 = !H && Q.compile ? Q.compile.call(B.self, J, G, B) : Q.validate, K = z3(Y, W, z2), V = Y.let("valid");
        X.block$data(V, L), X.ok(($ = Q.valid) !== null && $ !== void 0 ? $ : V);
        function L() {
          if (Q.errors === false) {
            if (q(), Q.modifying) B3(X);
            N(() => X.error());
          } else {
            let A = Q.async ? U() : F();
            if (Q.modifying) B3(X);
            N(() => hD(X, A));
          }
        }
        function U() {
          let A = Y.let("ruleErrs", null);
          return Y.try(() => q(T0._`await `), (M) => Y.assign(V, false).if(T0._`${M} instanceof ${B.ValidationError}`, () => Y.assign(A, T0._`${M}.errors`), () => Y.throw(M))), A;
        }
        function F() {
          let A = T0._`${K}.errors`;
          return Y.assign(A, null), q(T0.nil), A;
        }
        function q(A = Q.async ? T0._`await ` : T0.nil) {
          let M = B.opts.passContext ? H6.default.this : H6.default.self, R = !("compile" in Q && !H || Q.schema === false);
          Y.assign(V, T0._`${A}${(0, xD.callValidateCode)(X, K, M, R)}`, Q.modifying);
        }
        function N(A) {
          var M;
          Y.if((0, T0.not)((M = Q.valid) !== null && M !== void 0 ? M : V), A);
        }
      }
      K3.funcKeywordCode = fD;
      function B3(X) {
        let { gen: Q, data: $, it: Y } = X;
        Q.if(Y.parentData, () => Q.assign($, T0._`${Y.parentData}[${Y.parentDataProperty}]`));
      }
      function hD(X, Q) {
        let { gen: $ } = X;
        $.if(T0._`Array.isArray(${Q})`, () => {
          $.assign(H6.default.vErrors, T0._`${H6.default.vErrors} === null ? ${Q} : ${H6.default.vErrors}.concat(${Q})`).assign(H6.default.errors, T0._`${H6.default.vErrors}.length`), (0, yD.extendErrors)(X);
        }, () => X.error());
      }
      function uD({ schemaEnv: X }, Q) {
        if (Q.async && !X.$async) throw Error("async keyword in sync schema");
      }
      function z3(X, Q, $) {
        if ($ === void 0) throw Error(`keyword "${Q}" failed to compile`);
        return X.scopeValue("keyword", typeof $ == "function" ? { ref: $ } : { ref: $, code: (0, T0.stringify)($) });
      }
      function lD(X, Q, $ = false) {
        return !Q.length || Q.some((Y) => Y === "array" ? Array.isArray(X) : Y === "object" ? X && typeof X == "object" && !Array.isArray(X) : typeof X == Y || $ && typeof X > "u");
      }
      K3.validSchemaType = lD;
      function mD({ schema: X, opts: Q, self: $, errSchemaPath: Y }, W, J) {
        if (Array.isArray(W.keyword) ? !W.keyword.includes(J) : W.keyword !== J) throw Error("ajv implementation error");
        let G = W.dependencies;
        if (G === null || G === void 0 ? void 0 : G.some((H) => !Object.prototype.hasOwnProperty.call(X, H))) throw Error(`parent schema must have dependencies of ${J}: ${G.join(",")}`);
        if (W.validateSchema) {
          if (!W.validateSchema(X[J])) {
            let B = `keyword "${J}" value is invalid at path "${Y}": ` + $.errorsText(W.validateSchema.errors);
            if (Q.validateSchema === "log") $.logger.error(B);
            else throw Error(B);
          }
        }
      }
      K3.validateKeywordUsage = mD;
    });
    N3 = P((q3) => {
      Object.defineProperty(q3, "__esModule", { value: true });
      q3.extendSubschemaMode = q3.extendSubschemaData = q3.getSubschema = void 0;
      var U1 = c(), L3 = e();
      function iD(X, { keyword: Q, schemaProp: $, schema: Y, schemaPath: W, errSchemaPath: J, topSchemaRef: G }) {
        if (Q !== void 0 && Y !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
        if (Q !== void 0) {
          let H = X.schema[Q];
          return $ === void 0 ? { schema: H, schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}`, errSchemaPath: `${X.errSchemaPath}/${Q}` } : { schema: H[$], schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}${(0, U1.getProperty)($)}`, errSchemaPath: `${X.errSchemaPath}/${Q}/${(0, L3.escapeFragment)($)}` };
        }
        if (Y !== void 0) {
          if (W === void 0 || J === void 0 || G === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
          return { schema: Y, schemaPath: W, topSchemaRef: G, errSchemaPath: J };
        }
        throw Error('either "keyword" or "schema" must be passed');
      }
      q3.getSubschema = iD;
      function nD(X, Q, { dataProp: $, dataPropType: Y, data: W, dataTypes: J, propertyName: G }) {
        if (W !== void 0 && $ !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
        let { gen: H } = Q;
        if ($ !== void 0) {
          let { errorPath: z2, dataPathArr: K, opts: V } = Q, L = H.let("data", U1._`${Q.data}${(0, U1.getProperty)($)}`, true);
          B(L), X.errorPath = U1.str`${z2}${(0, L3.getErrorPath)($, Y, V.jsPropertySyntax)}`, X.parentDataProperty = U1._`${$}`, X.dataPathArr = [...K, X.parentDataProperty];
        }
        if (W !== void 0) {
          let z2 = W instanceof U1.Name ? W : H.let("data", W, true);
          if (B(z2), G !== void 0) X.propertyName = G;
        }
        if (J) X.dataTypes = J;
        function B(z2) {
          X.data = z2, X.dataLevel = Q.dataLevel + 1, X.dataTypes = [], Q.definedProperties = /* @__PURE__ */ new Set(), X.parentData = Q.data, X.dataNames = [...Q.dataNames, z2];
        }
      }
      q3.extendSubschemaData = nD;
      function rD(X, { jtdDiscriminator: Q, jtdMetadata: $, compositeRule: Y, createErrors: W, allErrors: J }) {
        if (Y !== void 0) X.compositeRule = Y;
        if (W !== void 0) X.createErrors = W;
        if (J !== void 0) X.allErrors = J;
        X.jtdDiscriminator = Q, X.jtdMetadata = $;
      }
      q3.extendSubschemaMode = rD;
    });
    DY = P((ev, O3) => {
      O3.exports = function X(Q, $) {
        if (Q === $) return true;
        if (Q && $ && typeof Q == "object" && typeof $ == "object") {
          if (Q.constructor !== $.constructor) return false;
          var Y, W, J;
          if (Array.isArray(Q)) {
            if (Y = Q.length, Y != $.length) return false;
            for (W = Y; W-- !== 0; ) if (!X(Q[W], $[W])) return false;
            return true;
          }
          if (Q.constructor === RegExp) return Q.source === $.source && Q.flags === $.flags;
          if (Q.valueOf !== Object.prototype.valueOf) return Q.valueOf() === $.valueOf();
          if (Q.toString !== Object.prototype.toString) return Q.toString() === $.toString();
          if (J = Object.keys(Q), Y = J.length, Y !== Object.keys($).length) return false;
          for (W = Y; W-- !== 0; ) if (!Object.prototype.hasOwnProperty.call($, J[W])) return false;
          for (W = Y; W-- !== 0; ) {
            var G = J[W];
            if (!X(Q[G], $[G])) return false;
          }
          return true;
        }
        return Q !== Q && $ !== $;
      };
    });
    A3 = P((XT, D3) => {
      var d1 = D3.exports = function(X, Q, $) {
        if (typeof Q == "function") $ = Q, Q = {};
        $ = Q.cb || $;
        var Y = typeof $ == "function" ? $ : $.pre || function() {
        }, W = $.post || function() {
        };
        C8(Q, Y, W, X, "", X);
      };
      d1.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true, if: true, then: true, else: true };
      d1.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true };
      d1.propsKeywords = { $defs: true, definitions: true, properties: true, patternProperties: true, dependencies: true };
      d1.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
      function C8(X, Q, $, Y, W, J, G, H, B, z2) {
        if (Y && typeof Y == "object" && !Array.isArray(Y)) {
          Q(Y, W, J, G, H, B, z2);
          for (var K in Y) {
            var V = Y[K];
            if (Array.isArray(V)) {
              if (K in d1.arrayKeywords) for (var L = 0; L < V.length; L++) C8(X, Q, $, V[L], W + "/" + K + "/" + L, J, W, K, Y, L);
            } else if (K in d1.propsKeywords) {
              if (V && typeof V == "object") for (var U in V) C8(X, Q, $, V[U], W + "/" + K + "/" + aD(U), J, W, K, Y, U);
            } else if (K in d1.keywords || X.allKeys && !(K in d1.skipKeywords)) C8(X, Q, $, V, W + "/" + K, J, W, K, Y);
          }
          $(Y, W, J, G, H, B, z2);
        }
      }
      function aD(X) {
        return X.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    });
    cX = P((R3) => {
      Object.defineProperty(R3, "__esModule", { value: true });
      R3.getSchemaRefs = R3.resolveUrl = R3.normalizeId = R3._getFullPath = R3.getFullPath = R3.inlineRef = void 0;
      var sD = e(), eD = DY(), XA = A3(), QA = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
      function $A(X, Q = true) {
        if (typeof X == "boolean") return true;
        if (Q === true) return !AY(X);
        if (!Q) return false;
        return w3(X) <= Q;
      }
      R3.inlineRef = $A;
      var YA = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
      function AY(X) {
        for (let Q in X) {
          if (YA.has(Q)) return true;
          let $ = X[Q];
          if (Array.isArray($) && $.some(AY)) return true;
          if (typeof $ == "object" && AY($)) return true;
        }
        return false;
      }
      function w3(X) {
        let Q = 0;
        for (let $ in X) {
          if ($ === "$ref") return 1 / 0;
          if (Q++, QA.has($)) continue;
          if (typeof X[$] == "object") (0, sD.eachItem)(X[$], (Y) => Q += w3(Y));
          if (Q === 1 / 0) return 1 / 0;
        }
        return Q;
      }
      function M3(X, Q = "", $) {
        if ($ !== false) Q = c6(Q);
        let Y = X.parse(Q);
        return j3(X, Y);
      }
      R3.getFullPath = M3;
      function j3(X, Q) {
        return X.serialize(Q).split("#")[0] + "#";
      }
      R3._getFullPath = j3;
      var WA = /#\/?$/;
      function c6(X) {
        return X ? X.replace(WA, "") : "";
      }
      R3.normalizeId = c6;
      function JA(X, Q, $) {
        return $ = c6($), X.resolve(Q, $);
      }
      R3.resolveUrl = JA;
      var GA = /^[a-z_][-a-z0-9._]*$/i;
      function HA(X, Q) {
        if (typeof X == "boolean") return {};
        let { schemaId: $, uriResolver: Y } = this.opts, W = c6(X[$] || Q), J = { "": W }, G = M3(Y, W, false), H = {}, B = /* @__PURE__ */ new Set();
        return XA(X, { allKeys: true }, (V, L, U, F) => {
          if (F === void 0) return;
          let q = G + L, N = J[F];
          if (typeof V[$] == "string") N = A.call(this, V[$]);
          M.call(this, V.$anchor), M.call(this, V.$dynamicAnchor), J[L] = N;
          function A(R) {
            let S = this.opts.uriResolver.resolve;
            if (R = c6(N ? S(N, R) : R), B.has(R)) throw K(R);
            B.add(R);
            let C = this.refs[R];
            if (typeof C == "string") C = this.refs[C];
            if (typeof C == "object") z2(V, C.schema, R);
            else if (R !== c6(q)) if (R[0] === "#") z2(V, H[R], R), H[R] = V;
            else this.refs[R] = q;
            return R;
          }
          function M(R) {
            if (typeof R == "string") {
              if (!GA.test(R)) throw Error(`invalid anchor "${R}"`);
              A.call(this, `#${R}`);
            }
          }
        }), H;
        function z2(V, L, U) {
          if (L !== void 0 && !eD(V, L)) throw K(U);
        }
        function K(V) {
          return Error(`reference "${V}" resolves to more than one schema`);
        }
      }
      R3.getSchemaRefs = HA;
    });
    iX = P((h3) => {
      Object.defineProperty(h3, "__esModule", { value: true });
      h3.getData = h3.KeywordCxt = h3.validateFunctionCode = void 0;
      var Z3 = mG(), I3 = mX(), MY = UY(), k8 = mX(), LA = Y3(), dX = V3(), wY = N3(), _ = c(), u = R1(), qA = cX(), E1 = e(), pX = lX();
      function FA(X) {
        if (v3(X)) {
          if (T3(X), k3(X)) {
            DA(X);
            return;
          }
        }
        C3(X, () => (0, Z3.topBoolOrEmptySchema)(X));
      }
      h3.validateFunctionCode = FA;
      function C3({ gen: X, validateName: Q, schema: $, schemaEnv: Y, opts: W }, J) {
        if (W.code.es5) X.func(Q, _._`${u.default.data}, ${u.default.valCxt}`, Y.$async, () => {
          X.code(_._`"use strict"; ${b3($, W)}`), OA(X, W), X.code(J);
        });
        else X.func(Q, _._`${u.default.data}, ${NA(W)}`, Y.$async, () => X.code(b3($, W)).code(J));
      }
      function NA(X) {
        return _._`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${X.dynamicRef ? _._`, ${u.default.dynamicAnchors}={}` : _.nil}}={}`;
      }
      function OA(X, Q) {
        X.if(u.default.valCxt, () => {
          if (X.var(u.default.instancePath, _._`${u.default.valCxt}.${u.default.instancePath}`), X.var(u.default.parentData, _._`${u.default.valCxt}.${u.default.parentData}`), X.var(u.default.parentDataProperty, _._`${u.default.valCxt}.${u.default.parentDataProperty}`), X.var(u.default.rootData, _._`${u.default.valCxt}.${u.default.rootData}`), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`${u.default.valCxt}.${u.default.dynamicAnchors}`);
        }, () => {
          if (X.var(u.default.instancePath, _._`""`), X.var(u.default.parentData, _._`undefined`), X.var(u.default.parentDataProperty, _._`undefined`), X.var(u.default.rootData, u.default.data), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`{}`);
        });
      }
      function DA(X) {
        let { schema: Q, opts: $, gen: Y } = X;
        C3(X, () => {
          if ($.$comment && Q.$comment) x3(X);
          if (RA(X), Y.let(u.default.vErrors, null), Y.let(u.default.errors, 0), $.unevaluated) AA(X);
          _3(X), bA(X);
        });
        return;
      }
      function AA(X) {
        let { gen: Q, validateName: $ } = X;
        X.evaluated = Q.const("evaluated", _._`${$}.evaluated`), Q.if(_._`${X.evaluated}.dynamicProps`, () => Q.assign(_._`${X.evaluated}.props`, _._`undefined`)), Q.if(_._`${X.evaluated}.dynamicItems`, () => Q.assign(_._`${X.evaluated}.items`, _._`undefined`));
      }
      function b3(X, Q) {
        let $ = typeof X == "object" && X[Q.schemaId];
        return $ && (Q.code.source || Q.code.process) ? _._`/*# sourceURL=${$} */` : _.nil;
      }
      function wA(X, Q) {
        if (v3(X)) {
          if (T3(X), k3(X)) {
            MA(X, Q);
            return;
          }
        }
        (0, Z3.boolOrEmptySchema)(X, Q);
      }
      function k3({ schema: X, self: Q }) {
        if (typeof X == "boolean") return !X;
        for (let $ in X) if (Q.RULES.all[$]) return true;
        return false;
      }
      function v3(X) {
        return typeof X.schema != "boolean";
      }
      function MA(X, Q) {
        let { schema: $, gen: Y, opts: W } = X;
        if (W.$comment && $.$comment) x3(X);
        EA(X), IA(X);
        let J = Y.const("_errs", u.default.errors);
        _3(X, J), Y.var(Q, _._`${J} === ${u.default.errors}`);
      }
      function T3(X) {
        (0, E1.checkUnknownRules)(X), jA(X);
      }
      function _3(X, Q) {
        if (X.opts.jtd) return P3(X, [], false, Q);
        let $ = (0, I3.getSchemaTypes)(X.schema), Y = (0, I3.coerceAndCheckDataType)(X, $);
        P3(X, $, !Y, Q);
      }
      function jA(X) {
        let { schema: Q, errSchemaPath: $, opts: Y, self: W } = X;
        if (Q.$ref && Y.ignoreKeywordsWithRef && (0, E1.schemaHasRulesButRef)(Q, W.RULES)) W.logger.warn(`$ref: keywords ignored in schema at path "${$}"`);
      }
      function RA(X) {
        let { schema: Q, opts: $ } = X;
        if (Q.default !== void 0 && $.useDefaults && $.strictSchema) (0, E1.checkStrictMode)(X, "default is ignored in the schema root");
      }
      function EA(X) {
        let Q = X.schema[X.opts.schemaId];
        if (Q) X.baseId = (0, qA.resolveUrl)(X.opts.uriResolver, X.baseId, Q);
      }
      function IA(X) {
        if (X.schema.$async && !X.schemaEnv.$async) throw Error("async schema in sync schema");
      }
      function x3({ gen: X, schemaEnv: Q, schema: $, errSchemaPath: Y, opts: W }) {
        let J = $.$comment;
        if (W.$comment === true) X.code(_._`${u.default.self}.logger.log(${J})`);
        else if (typeof W.$comment == "function") {
          let G = _.str`${Y}/$comment`, H = X.scopeValue("root", { ref: Q.root });
          X.code(_._`${u.default.self}.opts.$comment(${J}, ${G}, ${H}.schema)`);
        }
      }
      function bA(X) {
        let { gen: Q, schemaEnv: $, validateName: Y, ValidationError: W, opts: J } = X;
        if ($.$async) Q.if(_._`${u.default.errors} === 0`, () => Q.return(u.default.data), () => Q.throw(_._`new ${W}(${u.default.vErrors})`));
        else {
          if (Q.assign(_._`${Y}.errors`, u.default.vErrors), J.unevaluated) PA(X);
          Q.return(_._`${u.default.errors} === 0`);
        }
      }
      function PA({ gen: X, evaluated: Q, props: $, items: Y }) {
        if ($ instanceof _.Name) X.assign(_._`${Q}.props`, $);
        if (Y instanceof _.Name) X.assign(_._`${Q}.items`, Y);
      }
      function P3(X, Q, $, Y) {
        let { gen: W, schema: J, data: G, allErrors: H, opts: B, self: z2 } = X, { RULES: K } = z2;
        if (J.$ref && (B.ignoreKeywordsWithRef || !(0, E1.schemaHasRulesButRef)(J, K))) {
          W.block(() => g3(X, "$ref", K.all.$ref.definition));
          return;
        }
        if (!B.jtd) SA(X, Q);
        W.block(() => {
          for (let L of K.rules) V(L);
          V(K.post);
        });
        function V(L) {
          if (!(0, MY.shouldUseGroup)(J, L)) return;
          if (L.type) {
            if (W.if((0, k8.checkDataType)(L.type, G, B.strictNumbers)), S3(X, L), Q.length === 1 && Q[0] === L.type && $) W.else(), (0, k8.reportTypeError)(X);
            W.endIf();
          } else S3(X, L);
          if (!H) W.if(_._`${u.default.errors} === ${Y || 0}`);
        }
      }
      function S3(X, Q) {
        let { gen: $, schema: Y, opts: { useDefaults: W } } = X;
        if (W) (0, LA.assignDefaults)(X, Q.type);
        $.block(() => {
          for (let J of Q.rules) if ((0, MY.shouldUseRule)(Y, J)) g3(X, J.keyword, J.definition, Q.type);
        });
      }
      function SA(X, Q) {
        if (X.schemaEnv.meta || !X.opts.strictTypes) return;
        if (ZA(X, Q), !X.opts.allowUnionTypes) CA(X, Q);
        kA(X, X.dataTypes);
      }
      function ZA(X, Q) {
        if (!Q.length) return;
        if (!X.dataTypes.length) {
          X.dataTypes = Q;
          return;
        }
        Q.forEach(($) => {
          if (!y3(X.dataTypes, $)) jY(X, `type "${$}" not allowed by context "${X.dataTypes.join(",")}"`);
        }), TA(X, Q);
      }
      function CA(X, Q) {
        if (Q.length > 1 && !(Q.length === 2 && Q.includes("null"))) jY(X, "use allowUnionTypes to allow union type keyword");
      }
      function kA(X, Q) {
        let $ = X.self.RULES.all;
        for (let Y in $) {
          let W = $[Y];
          if (typeof W == "object" && (0, MY.shouldUseRule)(X.schema, W)) {
            let { type: J } = W.definition;
            if (J.length && !J.some((G) => vA(Q, G))) jY(X, `missing type "${J.join(",")}" for keyword "${Y}"`);
          }
        }
      }
      function vA(X, Q) {
        return X.includes(Q) || Q === "number" && X.includes("integer");
      }
      function y3(X, Q) {
        return X.includes(Q) || Q === "integer" && X.includes("number");
      }
      function TA(X, Q) {
        let $ = [];
        for (let Y of X.dataTypes) if (y3(Q, Y)) $.push(Y);
        else if (Q.includes("integer") && Y === "number") $.push("integer");
        X.dataTypes = $;
      }
      function jY(X, Q) {
        let $ = X.schemaEnv.baseId + X.errSchemaPath;
        Q += ` at "${$}" (strictTypes)`, (0, E1.checkStrictMode)(X, Q, X.opts.strictTypes);
      }
      class RY {
        constructor(X, Q, $) {
          if ((0, dX.validateKeywordUsage)(X, Q, $), this.gen = X.gen, this.allErrors = X.allErrors, this.keyword = $, this.data = X.data, this.schema = X.schema[$], this.$data = Q.$data && X.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, E1.schemaRefOrVal)(X, this.schema, $, this.$data), this.schemaType = Q.schemaType, this.parentSchema = X.schema, this.params = {}, this.it = X, this.def = Q, this.$data) this.schemaCode = X.gen.const("vSchema", f3(this.$data, X));
          else if (this.schemaCode = this.schemaValue, !(0, dX.validSchemaType)(this.schema, Q.schemaType, Q.allowUndefined)) throw Error(`${$} value must be ${JSON.stringify(Q.schemaType)}`);
          if ("code" in Q ? Q.trackErrors : Q.errors !== false) this.errsCount = X.gen.const("_errs", u.default.errors);
        }
        result(X, Q, $) {
          this.failResult((0, _.not)(X), Q, $);
        }
        failResult(X, Q, $) {
          if (this.gen.if(X), $) $();
          else this.error();
          if (Q) {
            if (this.gen.else(), Q(), this.allErrors) this.gen.endIf();
          } else if (this.allErrors) this.gen.endIf();
          else this.gen.else();
        }
        pass(X, Q) {
          this.failResult((0, _.not)(X), void 0, Q);
        }
        fail(X) {
          if (X === void 0) {
            if (this.error(), !this.allErrors) this.gen.if(false);
            return;
          }
          if (this.gen.if(X), this.error(), this.allErrors) this.gen.endIf();
          else this.gen.else();
        }
        fail$data(X) {
          if (!this.$data) return this.fail(X);
          let { schemaCode: Q } = this;
          this.fail(_._`${Q} !== undefined && (${(0, _.or)(this.invalid$data(), X)})`);
        }
        error(X, Q, $) {
          if (Q) {
            this.setParams(Q), this._error(X, $), this.setParams({});
            return;
          }
          this._error(X, $);
        }
        _error(X, Q) {
          (X ? pX.reportExtraError : pX.reportError)(this, this.def.error, Q);
        }
        $dataError() {
          (0, pX.reportError)(this, this.def.$dataError || pX.keyword$DataError);
        }
        reset() {
          if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
          (0, pX.resetErrorsCount)(this.gen, this.errsCount);
        }
        ok(X) {
          if (!this.allErrors) this.gen.if(X);
        }
        setParams(X, Q) {
          if (Q) Object.assign(this.params, X);
          else this.params = X;
        }
        block$data(X, Q, $ = _.nil) {
          this.gen.block(() => {
            this.check$data(X, $), Q();
          });
        }
        check$data(X = _.nil, Q = _.nil) {
          if (!this.$data) return;
          let { gen: $, schemaCode: Y, schemaType: W, def: J } = this;
          if ($.if((0, _.or)(_._`${Y} === undefined`, Q)), X !== _.nil) $.assign(X, true);
          if (W.length || J.validateSchema) {
            if ($.elseIf(this.invalid$data()), this.$dataError(), X !== _.nil) $.assign(X, false);
          }
          $.else();
        }
        invalid$data() {
          let { gen: X, schemaCode: Q, schemaType: $, def: Y, it: W } = this;
          return (0, _.or)(J(), G());
          function J() {
            if ($.length) {
              if (!(Q instanceof _.Name)) throw Error("ajv implementation error");
              let H = Array.isArray($) ? $ : [$];
              return _._`${(0, k8.checkDataTypes)(H, Q, W.opts.strictNumbers, k8.DataType.Wrong)}`;
            }
            return _.nil;
          }
          function G() {
            if (Y.validateSchema) {
              let H = X.scopeValue("validate$data", { ref: Y.validateSchema });
              return _._`!${H}(${Q})`;
            }
            return _.nil;
          }
        }
        subschema(X, Q) {
          let $ = (0, wY.getSubschema)(this.it, X);
          (0, wY.extendSubschemaData)($, this.it, X), (0, wY.extendSubschemaMode)($, X);
          let Y = { ...this.it, ...$, items: void 0, props: void 0 };
          return wA(Y, Q), Y;
        }
        mergeEvaluated(X, Q) {
          let { it: $, gen: Y } = this;
          if (!$.opts.unevaluated) return;
          if ($.props !== true && X.props !== void 0) $.props = E1.mergeEvaluated.props(Y, X.props, $.props, Q);
          if ($.items !== true && X.items !== void 0) $.items = E1.mergeEvaluated.items(Y, X.items, $.items, Q);
        }
        mergeValidEvaluated(X, Q) {
          let { it: $, gen: Y } = this;
          if ($.opts.unevaluated && ($.props !== true || $.items !== true)) return Y.if(Q, () => this.mergeEvaluated(X, _.Name)), true;
        }
      }
      h3.KeywordCxt = RY;
      function g3(X, Q, $, Y) {
        let W = new RY(X, $, Q);
        if ("code" in $) $.code(W, Y);
        else if (W.$data && $.validate) (0, dX.funcKeywordCode)(W, $);
        else if ("macro" in $) (0, dX.macroKeywordCode)(W, $);
        else if ($.compile || $.validate) (0, dX.funcKeywordCode)(W, $);
      }
      var _A = /^\/(?:[^~]|~0|~1)*$/, xA = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function f3(X, { dataLevel: Q, dataNames: $, dataPathArr: Y }) {
        let W, J;
        if (X === "") return u.default.rootData;
        if (X[0] === "/") {
          if (!_A.test(X)) throw Error(`Invalid JSON-pointer: ${X}`);
          W = X, J = u.default.rootData;
        } else {
          let z2 = xA.exec(X);
          if (!z2) throw Error(`Invalid JSON-pointer: ${X}`);
          let K = +z2[1];
          if (W = z2[2], W === "#") {
            if (K >= Q) throw Error(B("property/index", K));
            return Y[Q - K];
          }
          if (K > Q) throw Error(B("data", K));
          if (J = $[Q - K], !W) return J;
        }
        let G = J, H = W.split("/");
        for (let z2 of H) if (z2) J = _._`${J}${(0, _.getProperty)((0, E1.unescapeJsonPointer)(z2))}`, G = _._`${G} && ${J}`;
        return G;
        function B(z2, K) {
          return `Cannot access ${z2} ${K} levels up, current level is ${Q}`;
        }
      }
      h3.getData = f3;
    });
    v8 = P((m3) => {
      Object.defineProperty(m3, "__esModule", { value: true });
      class l3 extends Error {
        constructor(X) {
          super("validation failed");
          this.errors = X, this.ajv = this.validation = true;
        }
      }
      m3.default = l3;
    });
    nX = P((p3) => {
      Object.defineProperty(p3, "__esModule", { value: true });
      var EY = cX();
      class c3 extends Error {
        constructor(X, Q, $, Y) {
          super(Y || `can't resolve reference ${$} from id ${Q}`);
          this.missingRef = (0, EY.resolveUrl)(X, Q, $), this.missingSchema = (0, EY.normalizeId)((0, EY.getFullPath)(X, this.missingRef));
        }
      }
      p3.default = c3;
    });
    _8 = P((n3) => {
      Object.defineProperty(n3, "__esModule", { value: true });
      n3.resolveSchema = n3.getCompilingSchema = n3.resolveRef = n3.compileSchema = n3.SchemaEnv = void 0;
      var X1 = c(), uA = v8(), B6 = R1(), Q1 = cX(), d3 = e(), lA = iX();
      class rX {
        constructor(X) {
          var Q;
          this.refs = {}, this.dynamicAnchors = {};
          let $;
          if (typeof X.schema == "object") $ = X.schema;
          this.schema = X.schema, this.schemaId = X.schemaId, this.root = X.root || this, this.baseId = (Q = X.baseId) !== null && Q !== void 0 ? Q : (0, Q1.normalizeId)($ === null || $ === void 0 ? void 0 : $[X.schemaId || "$id"]), this.schemaPath = X.schemaPath, this.localRefs = X.localRefs, this.meta = X.meta, this.$async = $ === null || $ === void 0 ? void 0 : $.$async, this.refs = {};
        }
      }
      n3.SchemaEnv = rX;
      function bY(X) {
        let Q = i3.call(this, X);
        if (Q) return Q;
        let $ = (0, Q1.getFullPath)(this.opts.uriResolver, X.root.baseId), { es5: Y, lines: W } = this.opts.code, { ownProperties: J } = this.opts, G = new X1.CodeGen(this.scope, { es5: Y, lines: W, ownProperties: J }), H;
        if (X.$async) H = G.scopeValue("Error", { ref: uA.default, code: X1._`require("ajv/dist/runtime/validation_error").default` });
        let B = G.scopeName("validate");
        X.validateName = B;
        let z2 = { gen: G, allErrors: this.opts.allErrors, data: B6.default.data, parentData: B6.default.parentData, parentDataProperty: B6.default.parentDataProperty, dataNames: [B6.default.data], dataPathArr: [X1.nil], dataLevel: 0, dataTypes: [], definedProperties: /* @__PURE__ */ new Set(), topSchemaRef: G.scopeValue("schema", this.opts.code.source === true ? { ref: X.schema, code: (0, X1.stringify)(X.schema) } : { ref: X.schema }), validateName: B, ValidationError: H, schema: X.schema, schemaEnv: X, rootId: $, baseId: X.baseId || $, schemaPath: X1.nil, errSchemaPath: X.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: X1._`""`, opts: this.opts, self: this }, K;
        try {
          this._compilations.add(X), (0, lA.validateFunctionCode)(z2), G.optimize(this.opts.code.optimize);
          let V = G.toString();
          if (K = `${G.scopeRefs(B6.default.scope)}return ${V}`, this.opts.code.process) K = this.opts.code.process(K, X);
          let U = Function(`${B6.default.self}`, `${B6.default.scope}`, K)(this, this.scope.get());
          if (this.scope.value(B, { ref: U }), U.errors = null, U.schema = X.schema, U.schemaEnv = X, X.$async) U.$async = true;
          if (this.opts.code.source === true) U.source = { validateName: B, validateCode: V, scopeValues: G._values };
          if (this.opts.unevaluated) {
            let { props: F, items: q } = z2;
            if (U.evaluated = { props: F instanceof X1.Name ? void 0 : F, items: q instanceof X1.Name ? void 0 : q, dynamicProps: F instanceof X1.Name, dynamicItems: q instanceof X1.Name }, U.source) U.source.evaluated = (0, X1.stringify)(U.evaluated);
          }
          return X.validate = U, X;
        } catch (V) {
          if (delete X.validate, delete X.validateName, K) this.logger.error("Error compiling schema, function code:", K);
          throw V;
        } finally {
          this._compilations.delete(X);
        }
      }
      n3.compileSchema = bY;
      function mA(X, Q, $) {
        var Y;
        $ = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $);
        let W = X.refs[$];
        if (W) return W;
        let J = dA.call(this, X, $);
        if (J === void 0) {
          let G = (Y = X.localRefs) === null || Y === void 0 ? void 0 : Y[$], { schemaId: H } = this.opts;
          if (G) J = new rX({ schema: G, schemaId: H, root: X, baseId: Q });
        }
        if (J === void 0) return;
        return X.refs[$] = cA.call(this, J);
      }
      n3.resolveRef = mA;
      function cA(X) {
        if ((0, Q1.inlineRef)(X.schema, this.opts.inlineRefs)) return X.schema;
        return X.validate ? X : bY.call(this, X);
      }
      function i3(X) {
        for (let Q of this._compilations) if (pA(Q, X)) return Q;
      }
      n3.getCompilingSchema = i3;
      function pA(X, Q) {
        return X.schema === Q.schema && X.root === Q.root && X.baseId === Q.baseId;
      }
      function dA(X, Q) {
        let $;
        while (typeof ($ = this.refs[Q]) == "string") Q = $;
        return $ || this.schemas[Q] || T8.call(this, X, Q);
      }
      function T8(X, Q) {
        let $ = this.opts.uriResolver.parse(Q), Y = (0, Q1._getFullPath)(this.opts.uriResolver, $), W = (0, Q1.getFullPath)(this.opts.uriResolver, X.baseId, void 0);
        if (Object.keys(X.schema).length > 0 && Y === W) return IY.call(this, $, X);
        let J = (0, Q1.normalizeId)(Y), G = this.refs[J] || this.schemas[J];
        if (typeof G == "string") {
          let H = T8.call(this, X, G);
          if (typeof (H === null || H === void 0 ? void 0 : H.schema) !== "object") return;
          return IY.call(this, $, H);
        }
        if (typeof (G === null || G === void 0 ? void 0 : G.schema) !== "object") return;
        if (!G.validate) bY.call(this, G);
        if (J === (0, Q1.normalizeId)(Q)) {
          let { schema: H } = G, { schemaId: B } = this.opts, z2 = H[B];
          if (z2) W = (0, Q1.resolveUrl)(this.opts.uriResolver, W, z2);
          return new rX({ schema: H, schemaId: B, root: X, baseId: W });
        }
        return IY.call(this, $, G);
      }
      n3.resolveSchema = T8;
      var iA = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function IY(X, { baseId: Q, schema: $, root: Y }) {
        var W;
        if (((W = X.fragment) === null || W === void 0 ? void 0 : W[0]) !== "/") return;
        for (let H of X.fragment.slice(1).split("/")) {
          if (typeof $ === "boolean") return;
          let B = $[(0, d3.unescapeFragment)(H)];
          if (B === void 0) return;
          $ = B;
          let z2 = typeof $ === "object" && $[this.opts.schemaId];
          if (!iA.has(H) && z2) Q = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, z2);
        }
        let J;
        if (typeof $ != "boolean" && $.$ref && !(0, d3.schemaHasRulesButRef)($, this.RULES)) {
          let H = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $.$ref);
          J = T8.call(this, Y, H);
        }
        let { schemaId: G } = this.opts;
        if (J = J || new rX({ schema: $, schemaId: G, root: Y, baseId: Q }), J.schema !== J.root.schema) return J;
        return;
      }
    });
    o3 = P((GT, aA) => {
      aA.exports = { $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON AnySchema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
    });
    a3 = P((HT, t3) => {
      var sA = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
      t3.exports = { HEX: sA };
    });
    JH = P((BT, WH) => {
      var { HEX: eA } = a3(), Xw = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
      function QH(X) {
        if (YH(X, ".") < 3) return { host: X, isIPV4: false };
        let Q = X.match(Xw) || [], [$] = Q;
        if ($) return { host: $w($, "."), isIPV4: true };
        else return { host: X, isIPV4: false };
      }
      function PY(X, Q = false) {
        let $ = "", Y = true;
        for (let W of X) {
          if (eA[W] === void 0) return;
          if (W !== "0" && Y === true) Y = false;
          if (!Y) $ += W;
        }
        if (Q && $.length === 0) $ = "0";
        return $;
      }
      function Qw(X) {
        let Q = 0, $ = { error: false, address: "", zone: "" }, Y = [], W = [], J = false, G = false, H = false;
        function B() {
          if (W.length) {
            if (J === false) {
              let z2 = PY(W);
              if (z2 !== void 0) Y.push(z2);
              else return $.error = true, false;
            }
            W.length = 0;
          }
          return true;
        }
        for (let z2 = 0; z2 < X.length; z2++) {
          let K = X[z2];
          if (K === "[" || K === "]") continue;
          if (K === ":") {
            if (G === true) H = true;
            if (!B()) break;
            if (Q++, Y.push(":"), Q > 7) {
              $.error = true;
              break;
            }
            if (z2 - 1 >= 0 && X[z2 - 1] === ":") G = true;
            continue;
          } else if (K === "%") {
            if (!B()) break;
            J = true;
          } else {
            W.push(K);
            continue;
          }
        }
        if (W.length) if (J) $.zone = W.join("");
        else if (H) Y.push(W.join(""));
        else Y.push(PY(W));
        return $.address = Y.join(""), $;
      }
      function $H(X) {
        if (YH(X, ":") < 2) return { host: X, isIPV6: false };
        let Q = Qw(X);
        if (!Q.error) {
          let { address: $, address: Y } = Q;
          if (Q.zone) $ += "%" + Q.zone, Y += "%25" + Q.zone;
          return { host: $, escapedHost: Y, isIPV6: true };
        } else return { host: X, isIPV6: false };
      }
      function $w(X, Q) {
        let $ = "", Y = true, W = X.length;
        for (let J = 0; J < W; J++) {
          let G = X[J];
          if (G === "0" && Y) {
            if (J + 1 <= W && X[J + 1] === Q || J + 1 === W) $ += G, Y = false;
          } else {
            if (G === Q) Y = true;
            else Y = false;
            $ += G;
          }
        }
        return $;
      }
      function YH(X, Q) {
        let $ = 0;
        for (let Y = 0; Y < X.length; Y++) if (X[Y] === Q) $++;
        return $;
      }
      var s3 = /^\.\.?\//u, e3 = /^\/\.(?:\/|$)/u, XH = /^\/\.\.(?:\/|$)/u, Yw = /^\/?(?:.|\n)*?(?=\/|$)/u;
      function Ww(X) {
        let Q = [];
        while (X.length) if (X.match(s3)) X = X.replace(s3, "");
        else if (X.match(e3)) X = X.replace(e3, "/");
        else if (X.match(XH)) X = X.replace(XH, "/"), Q.pop();
        else if (X === "." || X === "..") X = "";
        else {
          let $ = X.match(Yw);
          if ($) {
            let Y = $[0];
            X = X.slice(Y.length), Q.push(Y);
          } else throw Error("Unexpected dot segment condition");
        }
        return Q.join("");
      }
      function Jw(X, Q) {
        let $ = Q !== true ? escape : unescape;
        if (X.scheme !== void 0) X.scheme = $(X.scheme);
        if (X.userinfo !== void 0) X.userinfo = $(X.userinfo);
        if (X.host !== void 0) X.host = $(X.host);
        if (X.path !== void 0) X.path = $(X.path);
        if (X.query !== void 0) X.query = $(X.query);
        if (X.fragment !== void 0) X.fragment = $(X.fragment);
        return X;
      }
      function Gw(X) {
        let Q = [];
        if (X.userinfo !== void 0) Q.push(X.userinfo), Q.push("@");
        if (X.host !== void 0) {
          let $ = unescape(X.host), Y = QH($);
          if (Y.isIPV4) $ = Y.host;
          else {
            let W = $H(Y.host);
            if (W.isIPV6 === true) $ = `[${W.escapedHost}]`;
            else $ = X.host;
          }
          Q.push($);
        }
        if (typeof X.port === "number" || typeof X.port === "string") Q.push(":"), Q.push(String(X.port));
        return Q.length ? Q.join("") : void 0;
      }
      WH.exports = { recomposeAuthority: Gw, normalizeComponentEncoding: Jw, removeDotSegments: Ww, normalizeIPv4: QH, normalizeIPv6: $H, stringArrayToHexStripped: PY };
    });
    UH = P((zT, KH) => {
      var Hw = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, Bw = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
      function GH(X) {
        return typeof X.secure === "boolean" ? X.secure : String(X.scheme).toLowerCase() === "wss";
      }
      function HH(X) {
        if (!X.host) X.error = X.error || "HTTP URIs must have a host.";
        return X;
      }
      function BH(X) {
        let Q = String(X.scheme).toLowerCase() === "https";
        if (X.port === (Q ? 443 : 80) || X.port === "") X.port = void 0;
        if (!X.path) X.path = "/";
        return X;
      }
      function zw(X) {
        return X.secure = GH(X), X.resourceName = (X.path || "/") + (X.query ? "?" + X.query : ""), X.path = void 0, X.query = void 0, X;
      }
      function Kw(X) {
        if (X.port === (GH(X) ? 443 : 80) || X.port === "") X.port = void 0;
        if (typeof X.secure === "boolean") X.scheme = X.secure ? "wss" : "ws", X.secure = void 0;
        if (X.resourceName) {
          let [Q, $] = X.resourceName.split("?");
          X.path = Q && Q !== "/" ? Q : void 0, X.query = $, X.resourceName = void 0;
        }
        return X.fragment = void 0, X;
      }
      function Uw(X, Q) {
        if (!X.path) return X.error = "URN can not be parsed", X;
        let $ = X.path.match(Bw);
        if ($) {
          let Y = Q.scheme || X.scheme || "urn";
          X.nid = $[1].toLowerCase(), X.nss = $[2];
          let W = `${Y}:${Q.nid || X.nid}`, J = SY[W];
          if (X.path = void 0, J) X = J.parse(X, Q);
        } else X.error = X.error || "URN can not be parsed.";
        return X;
      }
      function Vw(X, Q) {
        let $ = Q.scheme || X.scheme || "urn", Y = X.nid.toLowerCase(), W = `${$}:${Q.nid || Y}`, J = SY[W];
        if (J) X = J.serialize(X, Q);
        let G = X, H = X.nss;
        return G.path = `${Y || Q.nid}:${H}`, Q.skipEscape = true, G;
      }
      function Lw(X, Q) {
        let $ = X;
        if ($.uuid = $.nss, $.nss = void 0, !Q.tolerant && (!$.uuid || !Hw.test($.uuid))) $.error = $.error || "UUID is not valid.";
        return $;
      }
      function qw(X) {
        let Q = X;
        return Q.nss = (X.uuid || "").toLowerCase(), Q;
      }
      var zH = { scheme: "http", domainHost: true, parse: HH, serialize: BH }, Fw = { scheme: "https", domainHost: zH.domainHost, parse: HH, serialize: BH }, x8 = { scheme: "ws", domainHost: true, parse: zw, serialize: Kw }, Nw = { scheme: "wss", domainHost: x8.domainHost, parse: x8.parse, serialize: x8.serialize }, Ow = { scheme: "urn", parse: Uw, serialize: Vw, skipNormalize: true }, Dw = { scheme: "urn:uuid", parse: Lw, serialize: qw, skipNormalize: true }, SY = { http: zH, https: Fw, ws: x8, wss: Nw, urn: Ow, "urn:uuid": Dw };
      KH.exports = SY;
    });
    LH = P((KT, g8) => {
      var { normalizeIPv6: Aw, normalizeIPv4: ww, removeDotSegments: oX, recomposeAuthority: Mw, normalizeComponentEncoding: y8 } = JH(), ZY = UH();
      function jw(X, Q) {
        if (typeof X === "string") X = V1(I1(X, Q), Q);
        else if (typeof X === "object") X = I1(V1(X, Q), Q);
        return X;
      }
      function Rw(X, Q, $) {
        let Y = Object.assign({ scheme: "null" }, $), W = VH(I1(X, Y), I1(Q, Y), Y, true);
        return V1(W, { ...Y, skipEscape: true });
      }
      function VH(X, Q, $, Y) {
        let W = {};
        if (!Y) X = I1(V1(X, $), $), Q = I1(V1(Q, $), $);
        if ($ = $ || {}, !$.tolerant && Q.scheme) W.scheme = Q.scheme, W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
        else {
          if (Q.userinfo !== void 0 || Q.host !== void 0 || Q.port !== void 0) W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
          else {
            if (!Q.path) if (W.path = X.path, Q.query !== void 0) W.query = Q.query;
            else W.query = X.query;
            else {
              if (Q.path.charAt(0) === "/") W.path = oX(Q.path);
              else {
                if ((X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0) && !X.path) W.path = "/" + Q.path;
                else if (!X.path) W.path = Q.path;
                else W.path = X.path.slice(0, X.path.lastIndexOf("/") + 1) + Q.path;
                W.path = oX(W.path);
              }
              W.query = Q.query;
            }
            W.userinfo = X.userinfo, W.host = X.host, W.port = X.port;
          }
          W.scheme = X.scheme;
        }
        return W.fragment = Q.fragment, W;
      }
      function Ew(X, Q, $) {
        if (typeof X === "string") X = unescape(X), X = V1(y8(I1(X, $), true), { ...$, skipEscape: true });
        else if (typeof X === "object") X = V1(y8(X, true), { ...$, skipEscape: true });
        if (typeof Q === "string") Q = unescape(Q), Q = V1(y8(I1(Q, $), true), { ...$, skipEscape: true });
        else if (typeof Q === "object") Q = V1(y8(Q, true), { ...$, skipEscape: true });
        return X.toLowerCase() === Q.toLowerCase();
      }
      function V1(X, Q) {
        let $ = { host: X.host, scheme: X.scheme, userinfo: X.userinfo, port: X.port, path: X.path, query: X.query, nid: X.nid, nss: X.nss, uuid: X.uuid, fragment: X.fragment, reference: X.reference, resourceName: X.resourceName, secure: X.secure, error: "" }, Y = Object.assign({}, Q), W = [], J = ZY[(Y.scheme || $.scheme || "").toLowerCase()];
        if (J && J.serialize) J.serialize($, Y);
        if ($.path !== void 0) if (!Y.skipEscape) {
          if ($.path = escape($.path), $.scheme !== void 0) $.path = $.path.split("%3A").join(":");
        } else $.path = unescape($.path);
        if (Y.reference !== "suffix" && $.scheme) W.push($.scheme, ":");
        let G = Mw($);
        if (G !== void 0) {
          if (Y.reference !== "suffix") W.push("//");
          if (W.push(G), $.path && $.path.charAt(0) !== "/") W.push("/");
        }
        if ($.path !== void 0) {
          let H = $.path;
          if (!Y.absolutePath && (!J || !J.absolutePath)) H = oX(H);
          if (G === void 0) H = H.replace(/^\/\//u, "/%2F");
          W.push(H);
        }
        if ($.query !== void 0) W.push("?", $.query);
        if ($.fragment !== void 0) W.push("#", $.fragment);
        return W.join("");
      }
      var Iw = Array.from({ length: 127 }, (X, Q) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(Q)));
      function bw(X) {
        let Q = 0;
        for (let $ = 0, Y = X.length; $ < Y; ++$) if (Q = X.charCodeAt($), Q > 126 || Iw[Q]) return true;
        return false;
      }
      var Pw = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
      function I1(X, Q) {
        let $ = Object.assign({}, Q), Y = { scheme: void 0, userinfo: void 0, host: "", port: void 0, path: "", query: void 0, fragment: void 0 }, W = X.indexOf("%") !== -1, J = false;
        if ($.reference === "suffix") X = ($.scheme ? $.scheme + ":" : "") + "//" + X;
        let G = X.match(Pw);
        if (G) {
          if (Y.scheme = G[1], Y.userinfo = G[3], Y.host = G[4], Y.port = parseInt(G[5], 10), Y.path = G[6] || "", Y.query = G[7], Y.fragment = G[8], isNaN(Y.port)) Y.port = G[5];
          if (Y.host) {
            let B = ww(Y.host);
            if (B.isIPV4 === false) {
              let z2 = Aw(B.host);
              Y.host = z2.host.toLowerCase(), J = z2.isIPV6;
            } else Y.host = B.host, J = true;
          }
          if (Y.scheme === void 0 && Y.userinfo === void 0 && Y.host === void 0 && Y.port === void 0 && Y.query === void 0 && !Y.path) Y.reference = "same-document";
          else if (Y.scheme === void 0) Y.reference = "relative";
          else if (Y.fragment === void 0) Y.reference = "absolute";
          else Y.reference = "uri";
          if ($.reference && $.reference !== "suffix" && $.reference !== Y.reference) Y.error = Y.error || "URI is not a " + $.reference + " reference.";
          let H = ZY[($.scheme || Y.scheme || "").toLowerCase()];
          if (!$.unicodeSupport && (!H || !H.unicodeSupport)) {
            if (Y.host && ($.domainHost || H && H.domainHost) && J === false && bw(Y.host)) try {
              Y.host = URL.domainToASCII(Y.host.toLowerCase());
            } catch (B) {
              Y.error = Y.error || "Host's domain name can not be converted to ASCII: " + B;
            }
          }
          if (!H || H && !H.skipNormalize) {
            if (W && Y.scheme !== void 0) Y.scheme = unescape(Y.scheme);
            if (W && Y.host !== void 0) Y.host = unescape(Y.host);
            if (Y.path) Y.path = escape(unescape(Y.path));
            if (Y.fragment) Y.fragment = encodeURI(decodeURIComponent(Y.fragment));
          }
          if (H && H.parse) H.parse(Y, $);
        } else Y.error = Y.error || "URI can not be parsed.";
        return Y;
      }
      var CY = { SCHEMES: ZY, normalize: jw, resolve: Rw, resolveComponents: VH, equal: Ew, serialize: V1, parse: I1 };
      g8.exports = CY;
      g8.exports.default = CY;
      g8.exports.fastUri = CY;
    });
    NH = P((FH) => {
      Object.defineProperty(FH, "__esModule", { value: true });
      var qH = LH();
      qH.code = 'require("ajv/dist/runtime/uri").default';
      FH.default = qH;
    });
    EH = P((b1) => {
      Object.defineProperty(b1, "__esModule", { value: true });
      b1.CodeGen = b1.Name = b1.nil = b1.stringify = b1.str = b1._ = b1.KeywordCxt = void 0;
      var Zw = iX();
      Object.defineProperty(b1, "KeywordCxt", { enumerable: true, get: function() {
        return Zw.KeywordCxt;
      } });
      var p6 = c();
      Object.defineProperty(b1, "_", { enumerable: true, get: function() {
        return p6._;
      } });
      Object.defineProperty(b1, "str", { enumerable: true, get: function() {
        return p6.str;
      } });
      Object.defineProperty(b1, "stringify", { enumerable: true, get: function() {
        return p6.stringify;
      } });
      Object.defineProperty(b1, "nil", { enumerable: true, get: function() {
        return p6.nil;
      } });
      Object.defineProperty(b1, "Name", { enumerable: true, get: function() {
        return p6.Name;
      } });
      Object.defineProperty(b1, "CodeGen", { enumerable: true, get: function() {
        return p6.CodeGen;
      } });
      var Cw = v8(), MH = nX(), kw = KY(), tX = _8(), vw = c(), aX = cX(), f8 = mX(), vY = e(), OH = o3(), Tw = NH(), jH = (X, Q) => new RegExp(X, Q);
      jH.code = "new RegExp";
      var _w = ["removeAdditional", "useDefaults", "coerceTypes"], xw = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), yw = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, gw = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' }, DH = 200;
      function fw(X) {
        var Q, $, Y, W, J, G, H, B, z2, K, V, L, U, F, q, N, A, M, R, S, C, K0, U0, s, D0;
        let q0 = X.strict, W1 = (Q = X.code) === null || Q === void 0 ? void 0 : Q.optimize, P1 = W1 === true || W1 === void 0 ? 1 : W1 || 0, U6 = (Y = ($ = X.code) === null || $ === void 0 ? void 0 : $.regExp) !== null && Y !== void 0 ? Y : jH, d = (W = X.uriResolver) !== null && W !== void 0 ? W : Tw.default;
        return { strictSchema: (G = (J = X.strictSchema) !== null && J !== void 0 ? J : q0) !== null && G !== void 0 ? G : true, strictNumbers: (B = (H = X.strictNumbers) !== null && H !== void 0 ? H : q0) !== null && B !== void 0 ? B : true, strictTypes: (K = (z2 = X.strictTypes) !== null && z2 !== void 0 ? z2 : q0) !== null && K !== void 0 ? K : "log", strictTuples: (L = (V = X.strictTuples) !== null && V !== void 0 ? V : q0) !== null && L !== void 0 ? L : "log", strictRequired: (F = (U = X.strictRequired) !== null && U !== void 0 ? U : q0) !== null && F !== void 0 ? F : false, code: X.code ? { ...X.code, optimize: P1, regExp: U6 } : { optimize: P1, regExp: U6 }, loopRequired: (q = X.loopRequired) !== null && q !== void 0 ? q : DH, loopEnum: (N = X.loopEnum) !== null && N !== void 0 ? N : DH, meta: (A = X.meta) !== null && A !== void 0 ? A : true, messages: (M = X.messages) !== null && M !== void 0 ? M : true, inlineRefs: (R = X.inlineRefs) !== null && R !== void 0 ? R : true, schemaId: (S = X.schemaId) !== null && S !== void 0 ? S : "$id", addUsedSchema: (C = X.addUsedSchema) !== null && C !== void 0 ? C : true, validateSchema: (K0 = X.validateSchema) !== null && K0 !== void 0 ? K0 : true, validateFormats: (U0 = X.validateFormats) !== null && U0 !== void 0 ? U0 : true, unicodeRegExp: (s = X.unicodeRegExp) !== null && s !== void 0 ? s : true, int32range: (D0 = X.int32range) !== null && D0 !== void 0 ? D0 : true, uriResolver: d };
      }
      class h8 {
        constructor(X = {}) {
          this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), X = this.opts = { ...X, ...fw(X) };
          let { es5: Q, lines: $ } = this.opts.code;
          this.scope = new vw.ValueScope({ scope: {}, prefixes: xw, es5: Q, lines: $ }), this.logger = pw(X.logger);
          let Y = X.validateFormats;
          if (X.validateFormats = false, this.RULES = (0, kw.getRules)(), AH.call(this, yw, X, "NOT SUPPORTED"), AH.call(this, gw, X, "DEPRECATED", "warn"), this._metaOpts = mw.call(this), X.formats) uw.call(this);
          if (this._addVocabularies(), this._addDefaultMetaSchema(), X.keywords) lw.call(this, X.keywords);
          if (typeof X.meta == "object") this.addMetaSchema(X.meta);
          hw.call(this), X.validateFormats = Y;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          let { $data: X, meta: Q, schemaId: $ } = this.opts, Y = OH;
          if ($ === "id") Y = { ...OH }, Y.id = Y.$id, delete Y.$id;
          if (Q && X) this.addMetaSchema(Y, Y[$], false);
        }
        defaultMeta() {
          let { meta: X, schemaId: Q } = this.opts;
          return this.opts.defaultMeta = typeof X == "object" ? X[Q] || X : void 0;
        }
        validate(X, Q) {
          let $;
          if (typeof X == "string") {
            if ($ = this.getSchema(X), !$) throw Error(`no schema with key or ref "${X}"`);
          } else $ = this.compile(X);
          let Y = $(Q);
          if (!("$async" in $)) this.errors = $.errors;
          return Y;
        }
        compile(X, Q) {
          let $ = this._addSchema(X, Q);
          return $.validate || this._compileSchemaEnv($);
        }
        compileAsync(X, Q) {
          if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
          let { loadSchema: $ } = this.opts;
          return Y.call(this, X, Q);
          async function Y(z2, K) {
            await W.call(this, z2.$schema);
            let V = this._addSchema(z2, K);
            return V.validate || J.call(this, V);
          }
          async function W(z2) {
            if (z2 && !this.getSchema(z2)) await Y.call(this, { $ref: z2 }, true);
          }
          async function J(z2) {
            try {
              return this._compileSchemaEnv(z2);
            } catch (K) {
              if (!(K instanceof MH.default)) throw K;
              return G.call(this, K), await H.call(this, K.missingSchema), J.call(this, z2);
            }
          }
          function G({ missingSchema: z2, missingRef: K }) {
            if (this.refs[z2]) throw Error(`AnySchema ${z2} is loaded but ${K} cannot be resolved`);
          }
          async function H(z2) {
            let K = await B.call(this, z2);
            if (!this.refs[z2]) await W.call(this, K.$schema);
            if (!this.refs[z2]) this.addSchema(K, z2, Q);
          }
          async function B(z2) {
            let K = this._loading[z2];
            if (K) return K;
            try {
              return await (this._loading[z2] = $(z2));
            } finally {
              delete this._loading[z2];
            }
          }
        }
        addSchema(X, Q, $, Y = this.opts.validateSchema) {
          if (Array.isArray(X)) {
            for (let J of X) this.addSchema(J, void 0, $, Y);
            return this;
          }
          let W;
          if (typeof X === "object") {
            let { schemaId: J } = this.opts;
            if (W = X[J], W !== void 0 && typeof W != "string") throw Error(`schema ${J} must be string`);
          }
          return Q = (0, aX.normalizeId)(Q || W), this._checkUnique(Q), this.schemas[Q] = this._addSchema(X, $, Q, Y, true), this;
        }
        addMetaSchema(X, Q, $ = this.opts.validateSchema) {
          return this.addSchema(X, Q, true, $), this;
        }
        validateSchema(X, Q) {
          if (typeof X == "boolean") return true;
          let $;
          if ($ = X.$schema, $ !== void 0 && typeof $ != "string") throw Error("$schema must be a string");
          if ($ = $ || this.opts.defaultMeta || this.defaultMeta(), !$) return this.logger.warn("meta-schema not available"), this.errors = null, true;
          let Y = this.validate($, X);
          if (!Y && Q) {
            let W = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log") this.logger.error(W);
            else throw Error(W);
          }
          return Y;
        }
        getSchema(X) {
          let Q;
          while (typeof (Q = wH.call(this, X)) == "string") X = Q;
          if (Q === void 0) {
            let { schemaId: $ } = this.opts, Y = new tX.SchemaEnv({ schema: {}, schemaId: $ });
            if (Q = tX.resolveSchema.call(this, Y, X), !Q) return;
            this.refs[X] = Q;
          }
          return Q.validate || this._compileSchemaEnv(Q);
        }
        removeSchema(X) {
          if (X instanceof RegExp) return this._removeAllSchemas(this.schemas, X), this._removeAllSchemas(this.refs, X), this;
          switch (typeof X) {
            case "undefined":
              return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
            case "string": {
              let Q = wH.call(this, X);
              if (typeof Q == "object") this._cache.delete(Q.schema);
              return delete this.schemas[X], delete this.refs[X], this;
            }
            case "object": {
              let Q = X;
              this._cache.delete(Q);
              let $ = X[this.opts.schemaId];
              if ($) $ = (0, aX.normalizeId)($), delete this.schemas[$], delete this.refs[$];
              return this;
            }
            default:
              throw Error("ajv.removeSchema: invalid parameter");
          }
        }
        addVocabulary(X) {
          for (let Q of X) this.addKeyword(Q);
          return this;
        }
        addKeyword(X, Q) {
          let $;
          if (typeof X == "string") {
            if ($ = X, typeof Q == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), Q.keyword = $;
          } else if (typeof X == "object" && Q === void 0) {
            if (Q = X, $ = Q.keyword, Array.isArray($) && !$.length) throw Error("addKeywords: keyword must be string or non-empty array");
          } else throw Error("invalid addKeywords parameters");
          if (iw.call(this, $, Q), !Q) return (0, vY.eachItem)($, (W) => kY.call(this, W)), this;
          rw.call(this, Q);
          let Y = { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) };
          return (0, vY.eachItem)($, Y.type.length === 0 ? (W) => kY.call(this, W, Y) : (W) => Y.type.forEach((J) => kY.call(this, W, Y, J))), this;
        }
        getKeyword(X) {
          let Q = this.RULES.all[X];
          return typeof Q == "object" ? Q.definition : !!Q;
        }
        removeKeyword(X) {
          let { RULES: Q } = this;
          delete Q.keywords[X], delete Q.all[X];
          for (let $ of Q.rules) {
            let Y = $.rules.findIndex((W) => W.keyword === X);
            if (Y >= 0) $.rules.splice(Y, 1);
          }
          return this;
        }
        addFormat(X, Q) {
          if (typeof Q == "string") Q = new RegExp(Q);
          return this.formats[X] = Q, this;
        }
        errorsText(X = this.errors, { separator: Q = ", ", dataVar: $ = "data" } = {}) {
          if (!X || X.length === 0) return "No errors";
          return X.map((Y) => `${$}${Y.instancePath} ${Y.message}`).reduce((Y, W) => Y + Q + W);
        }
        $dataMetaSchema(X, Q) {
          let $ = this.RULES.all;
          X = JSON.parse(JSON.stringify(X));
          for (let Y of Q) {
            let W = Y.split("/").slice(1), J = X;
            for (let G of W) J = J[G];
            for (let G in $) {
              let H = $[G];
              if (typeof H != "object") continue;
              let { $data: B } = H.definition, z2 = J[G];
              if (B && z2) J[G] = RH(z2);
            }
          }
          return X;
        }
        _removeAllSchemas(X, Q) {
          for (let $ in X) {
            let Y = X[$];
            if (!Q || Q.test($)) {
              if (typeof Y == "string") delete X[$];
              else if (Y && !Y.meta) this._cache.delete(Y.schema), delete X[$];
            }
          }
        }
        _addSchema(X, Q, $, Y = this.opts.validateSchema, W = this.opts.addUsedSchema) {
          let J, { schemaId: G } = this.opts;
          if (typeof X == "object") J = X[G];
          else if (this.opts.jtd) throw Error("schema must be object");
          else if (typeof X != "boolean") throw Error("schema must be object or boolean");
          let H = this._cache.get(X);
          if (H !== void 0) return H;
          $ = (0, aX.normalizeId)(J || $);
          let B = aX.getSchemaRefs.call(this, X, $);
          if (H = new tX.SchemaEnv({ schema: X, schemaId: G, meta: Q, baseId: $, localRefs: B }), this._cache.set(H.schema, H), W && !$.startsWith("#")) {
            if ($) this._checkUnique($);
            this.refs[$] = H;
          }
          if (Y) this.validateSchema(X, true);
          return H;
        }
        _checkUnique(X) {
          if (this.schemas[X] || this.refs[X]) throw Error(`schema with key or id "${X}" already exists`);
        }
        _compileSchemaEnv(X) {
          if (X.meta) this._compileMetaSchema(X);
          else tX.compileSchema.call(this, X);
          if (!X.validate) throw Error("ajv implementation error");
          return X.validate;
        }
        _compileMetaSchema(X) {
          let Q = this.opts;
          this.opts = this._metaOpts;
          try {
            tX.compileSchema.call(this, X);
          } finally {
            this.opts = Q;
          }
        }
      }
      h8.ValidationError = Cw.default;
      h8.MissingRefError = MH.default;
      b1.default = h8;
      function AH(X, Q, $, Y = "error") {
        for (let W in X) {
          let J = W;
          if (J in Q) this.logger[Y](`${$}: option ${W}. ${X[J]}`);
        }
      }
      function wH(X) {
        return X = (0, aX.normalizeId)(X), this.schemas[X] || this.refs[X];
      }
      function hw() {
        let X = this.opts.schemas;
        if (!X) return;
        if (Array.isArray(X)) this.addSchema(X);
        else for (let Q in X) this.addSchema(X[Q], Q);
      }
      function uw() {
        for (let X in this.opts.formats) {
          let Q = this.opts.formats[X];
          if (Q) this.addFormat(X, Q);
        }
      }
      function lw(X) {
        if (Array.isArray(X)) {
          this.addVocabulary(X);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (let Q in X) {
          let $ = X[Q];
          if (!$.keyword) $.keyword = Q;
          this.addKeyword($);
        }
      }
      function mw() {
        let X = { ...this.opts };
        for (let Q of _w) delete X[Q];
        return X;
      }
      var cw = { log() {
      }, warn() {
      }, error() {
      } };
      function pw(X) {
        if (X === false) return cw;
        if (X === void 0) return console;
        if (X.log && X.warn && X.error) return X;
        throw Error("logger must implement log, warn and error methods");
      }
      var dw = /^[a-z_$][a-z0-9_$:-]*$/i;
      function iw(X, Q) {
        let { RULES: $ } = this;
        if ((0, vY.eachItem)(X, (Y) => {
          if ($.keywords[Y]) throw Error(`Keyword ${Y} is already defined`);
          if (!dw.test(Y)) throw Error(`Keyword ${Y} has invalid name`);
        }), !Q) return;
        if (Q.$data && !("code" in Q || "validate" in Q)) throw Error('$data keyword must have "code" or "validate" function');
      }
      function kY(X, Q, $) {
        var Y;
        let W = Q === null || Q === void 0 ? void 0 : Q.post;
        if ($ && W) throw Error('keyword with "post" flag cannot have "type"');
        let { RULES: J } = this, G = W ? J.post : J.rules.find(({ type: B }) => B === $);
        if (!G) G = { type: $, rules: [] }, J.rules.push(G);
        if (J.keywords[X] = true, !Q) return;
        let H = { keyword: X, definition: { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) } };
        if (Q.before) nw.call(this, G, H, Q.before);
        else G.rules.push(H);
        J.all[X] = H, (Y = Q.implements) === null || Y === void 0 || Y.forEach((B) => this.addKeyword(B));
      }
      function nw(X, Q, $) {
        let Y = X.rules.findIndex((W) => W.keyword === $);
        if (Y >= 0) X.rules.splice(Y, 0, Q);
        else X.rules.push(Q), this.logger.warn(`rule ${$} is not defined`);
      }
      function rw(X) {
        let { metaSchema: Q } = X;
        if (Q === void 0) return;
        if (X.$data && this.opts.$data) Q = RH(Q);
        X.validateSchema = this.compile(Q, true);
      }
      var ow = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
      function RH(X) {
        return { anyOf: [X, ow] };
      }
    });
    bH = P((IH) => {
      Object.defineProperty(IH, "__esModule", { value: true });
      var sw = { keyword: "id", code() {
        throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      } };
      IH.default = sw;
    });
    vH = P((CH) => {
      Object.defineProperty(CH, "__esModule", { value: true });
      CH.callRef = CH.getValidate = void 0;
      var XM = nX(), PH = d0(), g0 = c(), d6 = R1(), SH = _8(), u8 = e(), QM = { keyword: "$ref", schemaType: "string", code(X) {
        let { gen: Q, schema: $, it: Y } = X, { baseId: W, schemaEnv: J, validateName: G, opts: H, self: B } = Y, { root: z2 } = J;
        if (($ === "#" || $ === "#/") && W === z2.baseId) return V();
        let K = SH.resolveRef.call(B, z2, W, $);
        if (K === void 0) throw new XM.default(Y.opts.uriResolver, W, $);
        if (K instanceof SH.SchemaEnv) return L(K);
        return U(K);
        function V() {
          if (J === z2) return l8(X, G, J, J.$async);
          let F = Q.scopeValue("root", { ref: z2 });
          return l8(X, g0._`${F}.validate`, z2, z2.$async);
        }
        function L(F) {
          let q = ZH(X, F);
          l8(X, q, F, F.$async);
        }
        function U(F) {
          let q = Q.scopeValue("schema", H.code.source === true ? { ref: F, code: (0, g0.stringify)(F) } : { ref: F }), N = Q.name("valid"), A = X.subschema({ schema: F, dataTypes: [], schemaPath: g0.nil, topSchemaRef: q, errSchemaPath: $ }, N);
          X.mergeEvaluated(A), X.ok(N);
        }
      } };
      function ZH(X, Q) {
        let { gen: $ } = X;
        return Q.validate ? $.scopeValue("validate", { ref: Q.validate }) : g0._`${$.scopeValue("wrapper", { ref: Q })}.validate`;
      }
      CH.getValidate = ZH;
      function l8(X, Q, $, Y) {
        let { gen: W, it: J } = X, { allErrors: G, schemaEnv: H, opts: B } = J, z2 = B.passContext ? d6.default.this : g0.nil;
        if (Y) K();
        else V();
        function K() {
          if (!H.$async) throw Error("async schema referenced by sync schema");
          let F = W.let("valid");
          W.try(() => {
            if (W.code(g0._`await ${(0, PH.callValidateCode)(X, Q, z2)}`), U(Q), !G) W.assign(F, true);
          }, (q) => {
            if (W.if(g0._`!(${q} instanceof ${J.ValidationError})`, () => W.throw(q)), L(q), !G) W.assign(F, false);
          }), X.ok(F);
        }
        function V() {
          X.result((0, PH.callValidateCode)(X, Q, z2), () => U(Q), () => L(Q));
        }
        function L(F) {
          let q = g0._`${F}.errors`;
          W.assign(d6.default.vErrors, g0._`${d6.default.vErrors} === null ? ${q} : ${d6.default.vErrors}.concat(${q})`), W.assign(d6.default.errors, g0._`${d6.default.vErrors}.length`);
        }
        function U(F) {
          var q;
          if (!J.opts.unevaluated) return;
          let N = (q = $ === null || $ === void 0 ? void 0 : $.validate) === null || q === void 0 ? void 0 : q.evaluated;
          if (J.props !== true) if (N && !N.dynamicProps) {
            if (N.props !== void 0) J.props = u8.mergeEvaluated.props(W, N.props, J.props);
          } else {
            let A = W.var("props", g0._`${F}.evaluated.props`);
            J.props = u8.mergeEvaluated.props(W, A, J.props, g0.Name);
          }
          if (J.items !== true) if (N && !N.dynamicItems) {
            if (N.items !== void 0) J.items = u8.mergeEvaluated.items(W, N.items, J.items);
          } else {
            let A = W.var("items", g0._`${F}.evaluated.items`);
            J.items = u8.mergeEvaluated.items(W, A, J.items, g0.Name);
          }
        }
      }
      CH.callRef = l8;
      CH.default = QM;
    });
    _H = P((TH) => {
      Object.defineProperty(TH, "__esModule", { value: true });
      var WM = bH(), JM = vH(), GM = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", WM.default, JM.default];
      TH.default = GM;
    });
    yH = P((xH) => {
      Object.defineProperty(xH, "__esModule", { value: true });
      var m8 = c(), i1 = m8.operators, c8 = { maximum: { okStr: "<=", ok: i1.LTE, fail: i1.GT }, minimum: { okStr: ">=", ok: i1.GTE, fail: i1.LT }, exclusiveMaximum: { okStr: "<", ok: i1.LT, fail: i1.GTE }, exclusiveMinimum: { okStr: ">", ok: i1.GT, fail: i1.LTE } }, BM = { message: ({ keyword: X, schemaCode: Q }) => m8.str`must be ${c8[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => m8._`{comparison: ${c8[X].okStr}, limit: ${Q}}` }, zM = { keyword: Object.keys(c8), type: "number", schemaType: "number", $data: true, error: BM, code(X) {
        let { keyword: Q, data: $, schemaCode: Y } = X;
        X.fail$data(m8._`${$} ${c8[Q].fail} ${Y} || isNaN(${$})`);
      } };
      xH.default = zM;
    });
    fH = P((gH) => {
      Object.defineProperty(gH, "__esModule", { value: true });
      var sX = c(), UM = { message: ({ schemaCode: X }) => sX.str`must be multiple of ${X}`, params: ({ schemaCode: X }) => sX._`{multipleOf: ${X}}` }, VM = { keyword: "multipleOf", type: "number", schemaType: "number", $data: true, error: UM, code(X) {
        let { gen: Q, data: $, schemaCode: Y, it: W } = X, J = W.opts.multipleOfPrecision, G = Q.let("res"), H = J ? sX._`Math.abs(Math.round(${G}) - ${G}) > 1e-${J}` : sX._`${G} !== parseInt(${G})`;
        X.fail$data(sX._`(${Y} === 0 || (${G} = ${$}/${Y}, ${H}))`);
      } };
      gH.default = VM;
    });
    lH = P((uH) => {
      Object.defineProperty(uH, "__esModule", { value: true });
      function hH(X) {
        let Q = X.length, $ = 0, Y = 0, W;
        while (Y < Q) if ($++, W = X.charCodeAt(Y++), W >= 55296 && W <= 56319 && Y < Q) {
          if (W = X.charCodeAt(Y), (W & 64512) === 56320) Y++;
        }
        return $;
      }
      uH.default = hH;
      hH.code = 'require("ajv/dist/runtime/ucs2length").default';
    });
    cH = P((mH) => {
      Object.defineProperty(mH, "__esModule", { value: true });
      var z6 = c(), FM = e(), NM = lH(), OM = { message({ keyword: X, schemaCode: Q }) {
        let $ = X === "maxLength" ? "more" : "fewer";
        return z6.str`must NOT have ${$} than ${Q} characters`;
      }, params: ({ schemaCode: X }) => z6._`{limit: ${X}}` }, DM = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: true, error: OM, code(X) {
        let { keyword: Q, data: $, schemaCode: Y, it: W } = X, J = Q === "maxLength" ? z6.operators.GT : z6.operators.LT, G = W.opts.unicode === false ? z6._`${$}.length` : z6._`${(0, FM.useFunc)(X.gen, NM.default)}(${$})`;
        X.fail$data(z6._`${G} ${J} ${Y}`);
      } };
      mH.default = DM;
    });
    dH = P((pH) => {
      Object.defineProperty(pH, "__esModule", { value: true });
      var wM = d0(), p8 = c(), MM = { message: ({ schemaCode: X }) => p8.str`must match pattern "${X}"`, params: ({ schemaCode: X }) => p8._`{pattern: ${X}}` }, jM = { keyword: "pattern", type: "string", schemaType: "string", $data: true, error: MM, code(X) {
        let { data: Q, $data: $, schema: Y, schemaCode: W, it: J } = X, G = J.opts.unicodeRegExp ? "u" : "", H = $ ? p8._`(new RegExp(${W}, ${G}))` : (0, wM.usePattern)(X, Y);
        X.fail$data(p8._`!${H}.test(${Q})`);
      } };
      pH.default = jM;
    });
    nH = P((iH) => {
      Object.defineProperty(iH, "__esModule", { value: true });
      var eX = c(), EM = { message({ keyword: X, schemaCode: Q }) {
        let $ = X === "maxProperties" ? "more" : "fewer";
        return eX.str`must NOT have ${$} than ${Q} properties`;
      }, params: ({ schemaCode: X }) => eX._`{limit: ${X}}` }, IM = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: true, error: EM, code(X) {
        let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxProperties" ? eX.operators.GT : eX.operators.LT;
        X.fail$data(eX._`Object.keys(${$}).length ${W} ${Y}`);
      } };
      iH.default = IM;
    });
    oH = P((rH) => {
      Object.defineProperty(rH, "__esModule", { value: true });
      var X4 = d0(), Q4 = c(), PM = e(), SM = { message: ({ params: { missingProperty: X } }) => Q4.str`must have required property '${X}'`, params: ({ params: { missingProperty: X } }) => Q4._`{missingProperty: ${X}}` }, ZM = { keyword: "required", type: "object", schemaType: "array", $data: true, error: SM, code(X) {
        let { gen: Q, schema: $, schemaCode: Y, data: W, $data: J, it: G } = X, { opts: H } = G;
        if (!J && $.length === 0) return;
        let B = $.length >= H.loopRequired;
        if (G.allErrors) z2();
        else K();
        if (H.strictRequired) {
          let U = X.parentSchema.properties, { definedProperties: F } = X.it;
          for (let q of $) if ((U === null || U === void 0 ? void 0 : U[q]) === void 0 && !F.has(q)) {
            let N = G.schemaEnv.baseId + G.errSchemaPath, A = `required property "${q}" is not defined at "${N}" (strictRequired)`;
            (0, PM.checkStrictMode)(G, A, G.opts.strictRequired);
          }
        }
        function z2() {
          if (B || J) X.block$data(Q4.nil, V);
          else for (let U of $) (0, X4.checkReportMissingProp)(X, U);
        }
        function K() {
          let U = Q.let("missing");
          if (B || J) {
            let F = Q.let("valid", true);
            X.block$data(F, () => L(U, F)), X.ok(F);
          } else Q.if((0, X4.checkMissingProp)(X, $, U)), (0, X4.reportMissingProp)(X, U), Q.else();
        }
        function V() {
          Q.forOf("prop", Y, (U) => {
            X.setParams({ missingProperty: U }), Q.if((0, X4.noPropertyInData)(Q, W, U, H.ownProperties), () => X.error());
          });
        }
        function L(U, F) {
          X.setParams({ missingProperty: U }), Q.forOf(U, Y, () => {
            Q.assign(F, (0, X4.propertyInData)(Q, W, U, H.ownProperties)), Q.if((0, Q4.not)(F), () => {
              X.error(), Q.break();
            });
          }, Q4.nil);
        }
      } };
      rH.default = ZM;
    });
    aH = P((tH) => {
      Object.defineProperty(tH, "__esModule", { value: true });
      var $4 = c(), kM = { message({ keyword: X, schemaCode: Q }) {
        let $ = X === "maxItems" ? "more" : "fewer";
        return $4.str`must NOT have ${$} than ${Q} items`;
      }, params: ({ schemaCode: X }) => $4._`{limit: ${X}}` }, vM = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: true, error: kM, code(X) {
        let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxItems" ? $4.operators.GT : $4.operators.LT;
        X.fail$data($4._`${$}.length ${W} ${Y}`);
      } };
      tH.default = vM;
    });
    d8 = P((eH) => {
      Object.defineProperty(eH, "__esModule", { value: true });
      var sH = DY();
      sH.code = 'require("ajv/dist/runtime/equal").default';
      eH.default = sH;
    });
    QB = P((XB) => {
      Object.defineProperty(XB, "__esModule", { value: true });
      var TY = mX(), E0 = c(), xM = e(), yM = d8(), gM = { message: ({ params: { i: X, j: Q } }) => E0.str`must NOT have duplicate items (items ## ${Q} and ${X} are identical)`, params: ({ params: { i: X, j: Q } }) => E0._`{i: ${X}, j: ${Q}}` }, fM = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: true, error: gM, code(X) {
        let { gen: Q, data: $, $data: Y, schema: W, parentSchema: J, schemaCode: G, it: H } = X;
        if (!Y && !W) return;
        let B = Q.let("valid"), z2 = J.items ? (0, TY.getSchemaTypes)(J.items) : [];
        X.block$data(B, K, E0._`${G} === false`), X.ok(B);
        function K() {
          let F = Q.let("i", E0._`${$}.length`), q = Q.let("j");
          X.setParams({ i: F, j: q }), Q.assign(B, true), Q.if(E0._`${F} > 1`, () => (V() ? L : U)(F, q));
        }
        function V() {
          return z2.length > 0 && !z2.some((F) => F === "object" || F === "array");
        }
        function L(F, q) {
          let N = Q.name("item"), A = (0, TY.checkDataTypes)(z2, N, H.opts.strictNumbers, TY.DataType.Wrong), M = Q.const("indices", E0._`{}`);
          Q.for(E0._`;${F}--;`, () => {
            if (Q.let(N, E0._`${$}[${F}]`), Q.if(A, E0._`continue`), z2.length > 1) Q.if(E0._`typeof ${N} == "string"`, E0._`${N} += "_"`);
            Q.if(E0._`typeof ${M}[${N}] == "number"`, () => {
              Q.assign(q, E0._`${M}[${N}]`), X.error(), Q.assign(B, false).break();
            }).code(E0._`${M}[${N}] = ${F}`);
          });
        }
        function U(F, q) {
          let N = (0, xM.useFunc)(Q, yM.default), A = Q.name("outer");
          Q.label(A).for(E0._`;${F}--;`, () => Q.for(E0._`${q} = ${F}; ${q}--;`, () => Q.if(E0._`${N}(${$}[${F}], ${$}[${q}])`, () => {
            X.error(), Q.assign(B, false).break(A);
          })));
        }
      } };
      XB.default = fM;
    });
    YB = P(($B) => {
      Object.defineProperty($B, "__esModule", { value: true });
      var _Y = c(), uM = e(), lM = d8(), mM = { message: "must be equal to constant", params: ({ schemaCode: X }) => _Y._`{allowedValue: ${X}}` }, cM = { keyword: "const", $data: true, error: mM, code(X) {
        let { gen: Q, data: $, $data: Y, schemaCode: W, schema: J } = X;
        if (Y || J && typeof J == "object") X.fail$data(_Y._`!${(0, uM.useFunc)(Q, lM.default)}(${$}, ${W})`);
        else X.fail(_Y._`${J} !== ${$}`);
      } };
      $B.default = cM;
    });
    JB = P((WB) => {
      Object.defineProperty(WB, "__esModule", { value: true });
      var Y4 = c(), dM = e(), iM = d8(), nM = { message: "must be equal to one of the allowed values", params: ({ schemaCode: X }) => Y4._`{allowedValues: ${X}}` }, rM = { keyword: "enum", schemaType: "array", $data: true, error: nM, code(X) {
        let { gen: Q, data: $, $data: Y, schema: W, schemaCode: J, it: G } = X;
        if (!Y && W.length === 0) throw Error("enum must have non-empty array");
        let H = W.length >= G.opts.loopEnum, B, z2 = () => B !== null && B !== void 0 ? B : B = (0, dM.useFunc)(Q, iM.default), K;
        if (H || Y) K = Q.let("valid"), X.block$data(K, V);
        else {
          if (!Array.isArray(W)) throw Error("ajv implementation error");
          let U = Q.const("vSchema", J);
          K = (0, Y4.or)(...W.map((F, q) => L(U, q)));
        }
        X.pass(K);
        function V() {
          Q.assign(K, false), Q.forOf("v", J, (U) => Q.if(Y4._`${z2()}(${$}, ${U})`, () => Q.assign(K, true).break()));
        }
        function L(U, F) {
          let q = W[F];
          return typeof q === "object" && q !== null ? Y4._`${z2()}(${$}, ${U}[${F}])` : Y4._`${$} === ${q}`;
        }
      } };
      WB.default = rM;
    });
    HB = P((GB) => {
      Object.defineProperty(GB, "__esModule", { value: true });
      var tM = yH(), aM = fH(), sM = cH(), eM = dH(), Xj = nH(), Qj = oH(), $j = aH(), Yj = QB(), Wj = YB(), Jj = JB(), Gj = [tM.default, aM.default, sM.default, eM.default, Xj.default, Qj.default, $j.default, Yj.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, Wj.default, Jj.default];
      GB.default = Gj;
    });
    yY = P((zB) => {
      Object.defineProperty(zB, "__esModule", { value: true });
      zB.validateAdditionalItems = void 0;
      var K6 = c(), xY = e(), Bj = { message: ({ params: { len: X } }) => K6.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => K6._`{limit: ${X}}` }, zj = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: Bj, code(X) {
        let { parentSchema: Q, it: $ } = X, { items: Y } = Q;
        if (!Array.isArray(Y)) {
          (0, xY.checkStrictMode)($, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        BB(X, Y);
      } };
      function BB(X, Q) {
        let { gen: $, schema: Y, data: W, keyword: J, it: G } = X;
        G.items = true;
        let H = $.const("len", K6._`${W}.length`);
        if (Y === false) X.setParams({ len: Q.length }), X.pass(K6._`${H} <= ${Q.length}`);
        else if (typeof Y == "object" && !(0, xY.alwaysValidSchema)(G, Y)) {
          let z2 = $.var("valid", K6._`${H} <= ${Q.length}`);
          $.if((0, K6.not)(z2), () => B(z2)), X.ok(z2);
        }
        function B(z2) {
          $.forRange("i", Q.length, H, (K) => {
            if (X.subschema({ keyword: J, dataProp: K, dataPropType: xY.Type.Num }, z2), !G.allErrors) $.if((0, K6.not)(z2), () => $.break());
          });
        }
      }
      zB.validateAdditionalItems = BB;
      zB.default = zj;
    });
    gY = P((LB) => {
      Object.defineProperty(LB, "__esModule", { value: true });
      LB.validateTuple = void 0;
      var UB = c(), i8 = e(), Uj = d0(), Vj = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(X) {
        let { schema: Q, it: $ } = X;
        if (Array.isArray(Q)) return VB(X, "additionalItems", Q);
        if ($.items = true, (0, i8.alwaysValidSchema)($, Q)) return;
        X.ok((0, Uj.validateArray)(X));
      } };
      function VB(X, Q, $ = X.schema) {
        let { gen: Y, parentSchema: W, data: J, keyword: G, it: H } = X;
        if (K(W), H.opts.unevaluated && $.length && H.items !== true) H.items = i8.mergeEvaluated.items(Y, $.length, H.items);
        let B = Y.name("valid"), z2 = Y.const("len", UB._`${J}.length`);
        $.forEach((V, L) => {
          if ((0, i8.alwaysValidSchema)(H, V)) return;
          Y.if(UB._`${z2} > ${L}`, () => X.subschema({ keyword: G, schemaProp: L, dataProp: L }, B)), X.ok(B);
        });
        function K(V) {
          let { opts: L, errSchemaPath: U } = H, F = $.length, q = F === V.minItems && (F === V.maxItems || V[Q] === false);
          if (L.strictTuples && !q) {
            let N = `"${G}" is ${F}-tuple, but minItems or maxItems/${Q} are not specified or different at path "${U}"`;
            (0, i8.checkStrictMode)(H, N, L.strictTuples);
          }
        }
      }
      LB.validateTuple = VB;
      LB.default = Vj;
    });
    NB = P((FB) => {
      Object.defineProperty(FB, "__esModule", { value: true });
      var qj = gY(), Fj = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code: (X) => (0, qj.validateTuple)(X, "items") };
      FB.default = Fj;
    });
    AB = P((DB) => {
      Object.defineProperty(DB, "__esModule", { value: true });
      var OB = c(), Oj = e(), Dj = d0(), Aj = yY(), wj = { message: ({ params: { len: X } }) => OB.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => OB._`{limit: ${X}}` }, Mj = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: wj, code(X) {
        let { schema: Q, parentSchema: $, it: Y } = X, { prefixItems: W } = $;
        if (Y.items = true, (0, Oj.alwaysValidSchema)(Y, Q)) return;
        if (W) (0, Aj.validateAdditionalItems)(X, W);
        else X.ok((0, Dj.validateArray)(X));
      } };
      DB.default = Mj;
    });
    MB = P((wB) => {
      Object.defineProperty(wB, "__esModule", { value: true });
      var i0 = c(), n8 = e(), Rj = { message: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0.str`must contain at least ${X} valid item(s)` : i0.str`must contain at least ${X} and no more than ${Q} valid item(s)`, params: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0._`{minContains: ${X}}` : i0._`{minContains: ${X}, maxContains: ${Q}}` }, Ej = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: true, error: Rj, code(X) {
        let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X, G, H, { minContains: B, maxContains: z2 } = Y;
        if (J.opts.next) G = B === void 0 ? 1 : B, H = z2;
        else G = 1;
        let K = Q.const("len", i0._`${W}.length`);
        if (X.setParams({ min: G, max: H }), H === void 0 && G === 0) {
          (0, n8.checkStrictMode)(J, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (H !== void 0 && G > H) {
          (0, n8.checkStrictMode)(J, '"minContains" > "maxContains" is always invalid'), X.fail();
          return;
        }
        if ((0, n8.alwaysValidSchema)(J, $)) {
          let q = i0._`${K} >= ${G}`;
          if (H !== void 0) q = i0._`${q} && ${K} <= ${H}`;
          X.pass(q);
          return;
        }
        J.items = true;
        let V = Q.name("valid");
        if (H === void 0 && G === 1) U(V, () => Q.if(V, () => Q.break()));
        else if (G === 0) {
          if (Q.let(V, true), H !== void 0) Q.if(i0._`${W}.length > 0`, L);
        } else Q.let(V, false), L();
        X.result(V, () => X.reset());
        function L() {
          let q = Q.name("_valid"), N = Q.let("count", 0);
          U(q, () => Q.if(q, () => F(N)));
        }
        function U(q, N) {
          Q.forRange("i", 0, K, (A) => {
            X.subschema({ keyword: "contains", dataProp: A, dataPropType: n8.Type.Num, compositeRule: true }, q), N();
          });
        }
        function F(q) {
          if (Q.code(i0._`${q}++`), H === void 0) Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true).break());
          else if (Q.if(i0._`${q} > ${H}`, () => Q.assign(V, false).break()), G === 1) Q.assign(V, true);
          else Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true));
        }
      } };
      wB.default = Ej;
    });
    PB = P((EB) => {
      Object.defineProperty(EB, "__esModule", { value: true });
      EB.validateSchemaDeps = EB.validatePropertyDeps = EB.error = void 0;
      var fY = c(), bj = e(), W4 = d0();
      EB.error = { message: ({ params: { property: X, depsCount: Q, deps: $ } }) => {
        let Y = Q === 1 ? "property" : "properties";
        return fY.str`must have ${Y} ${$} when property ${X} is present`;
      }, params: ({ params: { property: X, depsCount: Q, deps: $, missingProperty: Y } }) => fY._`{property: ${X},
    missingProperty: ${Y},
    depsCount: ${Q},
    deps: ${$}}` };
      var Pj = { keyword: "dependencies", type: "object", schemaType: "object", error: EB.error, code(X) {
        let [Q, $] = Sj(X);
        jB(X, Q), RB(X, $);
      } };
      function Sj({ schema: X }) {
        let Q = {}, $ = {};
        for (let Y in X) {
          if (Y === "__proto__") continue;
          let W = Array.isArray(X[Y]) ? Q : $;
          W[Y] = X[Y];
        }
        return [Q, $];
      }
      function jB(X, Q = X.schema) {
        let { gen: $, data: Y, it: W } = X;
        if (Object.keys(Q).length === 0) return;
        let J = $.let("missing");
        for (let G in Q) {
          let H = Q[G];
          if (H.length === 0) continue;
          let B = (0, W4.propertyInData)($, Y, G, W.opts.ownProperties);
          if (X.setParams({ property: G, depsCount: H.length, deps: H.join(", ") }), W.allErrors) $.if(B, () => {
            for (let z2 of H) (0, W4.checkReportMissingProp)(X, z2);
          });
          else $.if(fY._`${B} && (${(0, W4.checkMissingProp)(X, H, J)})`), (0, W4.reportMissingProp)(X, J), $.else();
        }
      }
      EB.validatePropertyDeps = jB;
      function RB(X, Q = X.schema) {
        let { gen: $, data: Y, keyword: W, it: J } = X, G = $.name("valid");
        for (let H in Q) {
          if ((0, bj.alwaysValidSchema)(J, Q[H])) continue;
          $.if((0, W4.propertyInData)($, Y, H, J.opts.ownProperties), () => {
            let B = X.subschema({ keyword: W, schemaProp: H }, G);
            X.mergeValidEvaluated(B, G);
          }, () => $.var(G, true)), X.ok(G);
        }
      }
      EB.validateSchemaDeps = RB;
      EB.default = Pj;
    });
    CB = P((ZB) => {
      Object.defineProperty(ZB, "__esModule", { value: true });
      var SB = c(), kj = e(), vj = { message: "property name must be valid", params: ({ params: X }) => SB._`{propertyName: ${X.propertyName}}` }, Tj = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: vj, code(X) {
        let { gen: Q, schema: $, data: Y, it: W } = X;
        if ((0, kj.alwaysValidSchema)(W, $)) return;
        let J = Q.name("valid");
        Q.forIn("key", Y, (G) => {
          X.setParams({ propertyName: G }), X.subschema({ keyword: "propertyNames", data: G, dataTypes: ["string"], propertyName: G, compositeRule: true }, J), Q.if((0, SB.not)(J), () => {
            if (X.error(true), !W.allErrors) Q.break();
          });
        }), X.ok(J);
      } };
      ZB.default = Tj;
    });
    hY = P((kB) => {
      Object.defineProperty(kB, "__esModule", { value: true });
      var r8 = d0(), $1 = c(), xj = R1(), o8 = e(), yj = { message: "must NOT have additional properties", params: ({ params: X }) => $1._`{additionalProperty: ${X.additionalProperty}}` }, gj = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: true, trackErrors: true, error: yj, code(X) {
        let { gen: Q, schema: $, parentSchema: Y, data: W, errsCount: J, it: G } = X;
        if (!J) throw Error("ajv implementation error");
        let { allErrors: H, opts: B } = G;
        if (G.props = true, B.removeAdditional !== "all" && (0, o8.alwaysValidSchema)(G, $)) return;
        let z2 = (0, r8.allSchemaProperties)(Y.properties), K = (0, r8.allSchemaProperties)(Y.patternProperties);
        V(), X.ok($1._`${J} === ${xj.default.errors}`);
        function V() {
          Q.forIn("key", W, (N) => {
            if (!z2.length && !K.length) F(N);
            else Q.if(L(N), () => F(N));
          });
        }
        function L(N) {
          let A;
          if (z2.length > 8) {
            let M = (0, o8.schemaRefOrVal)(G, Y.properties, "properties");
            A = (0, r8.isOwnProperty)(Q, M, N);
          } else if (z2.length) A = (0, $1.or)(...z2.map((M) => $1._`${N} === ${M}`));
          else A = $1.nil;
          if (K.length) A = (0, $1.or)(A, ...K.map((M) => $1._`${(0, r8.usePattern)(X, M)}.test(${N})`));
          return (0, $1.not)(A);
        }
        function U(N) {
          Q.code($1._`delete ${W}[${N}]`);
        }
        function F(N) {
          if (B.removeAdditional === "all" || B.removeAdditional && $ === false) {
            U(N);
            return;
          }
          if ($ === false) {
            if (X.setParams({ additionalProperty: N }), X.error(), !H) Q.break();
            return;
          }
          if (typeof $ == "object" && !(0, o8.alwaysValidSchema)(G, $)) {
            let A = Q.name("valid");
            if (B.removeAdditional === "failing") q(N, A, false), Q.if((0, $1.not)(A), () => {
              X.reset(), U(N);
            });
            else if (q(N, A), !H) Q.if((0, $1.not)(A), () => Q.break());
          }
        }
        function q(N, A, M) {
          let R = { keyword: "additionalProperties", dataProp: N, dataPropType: o8.Type.Str };
          if (M === false) Object.assign(R, { compositeRule: true, createErrors: false, allErrors: false });
          X.subschema(R, A);
        }
      } };
      kB.default = gj;
    });
    xB = P((_B) => {
      Object.defineProperty(_B, "__esModule", { value: true });
      var hj = iX(), vB = d0(), uY = e(), TB = hY(), uj = { keyword: "properties", type: "object", schemaType: "object", code(X) {
        let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X;
        if (J.opts.removeAdditional === "all" && Y.additionalProperties === void 0) TB.default.code(new hj.KeywordCxt(J, TB.default, "additionalProperties"));
        let G = (0, vB.allSchemaProperties)($);
        for (let V of G) J.definedProperties.add(V);
        if (J.opts.unevaluated && G.length && J.props !== true) J.props = uY.mergeEvaluated.props(Q, (0, uY.toHash)(G), J.props);
        let H = G.filter((V) => !(0, uY.alwaysValidSchema)(J, $[V]));
        if (H.length === 0) return;
        let B = Q.name("valid");
        for (let V of H) {
          if (z2(V)) K(V);
          else {
            if (Q.if((0, vB.propertyInData)(Q, W, V, J.opts.ownProperties)), K(V), !J.allErrors) Q.else().var(B, true);
            Q.endIf();
          }
          X.it.definedProperties.add(V), X.ok(B);
        }
        function z2(V) {
          return J.opts.useDefaults && !J.compositeRule && $[V].default !== void 0;
        }
        function K(V) {
          X.subschema({ keyword: "properties", schemaProp: V, dataProp: V }, B);
        }
      } };
      _B.default = uj;
    });
    uB = P((hB) => {
      Object.defineProperty(hB, "__esModule", { value: true });
      var yB = d0(), t8 = c(), gB = e(), fB = e(), mj = { keyword: "patternProperties", type: "object", schemaType: "object", code(X) {
        let { gen: Q, schema: $, data: Y, parentSchema: W, it: J } = X, { opts: G } = J, H = (0, yB.allSchemaProperties)($), B = H.filter((q) => (0, gB.alwaysValidSchema)(J, $[q]));
        if (H.length === 0 || B.length === H.length && (!J.opts.unevaluated || J.props === true)) return;
        let z2 = G.strictSchema && !G.allowMatchingProperties && W.properties, K = Q.name("valid");
        if (J.props !== true && !(J.props instanceof t8.Name)) J.props = (0, fB.evaluatedPropsToName)(Q, J.props);
        let { props: V } = J;
        L();
        function L() {
          for (let q of H) {
            if (z2) U(q);
            if (J.allErrors) F(q);
            else Q.var(K, true), F(q), Q.if(K);
          }
        }
        function U(q) {
          for (let N in z2) if (new RegExp(q).test(N)) (0, gB.checkStrictMode)(J, `property ${N} matches pattern ${q} (use allowMatchingProperties)`);
        }
        function F(q) {
          Q.forIn("key", Y, (N) => {
            Q.if(t8._`${(0, yB.usePattern)(X, q)}.test(${N})`, () => {
              let A = B.includes(q);
              if (!A) X.subschema({ keyword: "patternProperties", schemaProp: q, dataProp: N, dataPropType: fB.Type.Str }, K);
              if (J.opts.unevaluated && V !== true) Q.assign(t8._`${V}[${N}]`, true);
              else if (!A && !J.allErrors) Q.if((0, t8.not)(K), () => Q.break());
            });
          });
        }
      } };
      hB.default = mj;
    });
    mB = P((lB) => {
      Object.defineProperty(lB, "__esModule", { value: true });
      var pj = e(), dj = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: true, code(X) {
        let { gen: Q, schema: $, it: Y } = X;
        if ((0, pj.alwaysValidSchema)(Y, $)) {
          X.fail();
          return;
        }
        let W = Q.name("valid");
        X.subschema({ keyword: "not", compositeRule: true, createErrors: false, allErrors: false }, W), X.failResult(W, () => X.reset(), () => X.error());
      }, error: { message: "must NOT be valid" } };
      lB.default = dj;
    });
    pB = P((cB) => {
      Object.defineProperty(cB, "__esModule", { value: true });
      var nj = d0(), rj = { keyword: "anyOf", schemaType: "array", trackErrors: true, code: nj.validateUnion, error: { message: "must match a schema in anyOf" } };
      cB.default = rj;
    });
    iB = P((dB) => {
      Object.defineProperty(dB, "__esModule", { value: true });
      var a8 = c(), tj = e(), aj = { message: "must match exactly one schema in oneOf", params: ({ params: X }) => a8._`{passingSchemas: ${X.passing}}` }, sj = { keyword: "oneOf", schemaType: "array", trackErrors: true, error: aj, code(X) {
        let { gen: Q, schema: $, parentSchema: Y, it: W } = X;
        if (!Array.isArray($)) throw Error("ajv implementation error");
        if (W.opts.discriminator && Y.discriminator) return;
        let J = $, G = Q.let("valid", false), H = Q.let("passing", null), B = Q.name("_valid");
        X.setParams({ passing: H }), Q.block(z2), X.result(G, () => X.reset(), () => X.error(true));
        function z2() {
          J.forEach((K, V) => {
            let L;
            if ((0, tj.alwaysValidSchema)(W, K)) Q.var(B, true);
            else L = X.subschema({ keyword: "oneOf", schemaProp: V, compositeRule: true }, B);
            if (V > 0) Q.if(a8._`${B} && ${G}`).assign(G, false).assign(H, a8._`[${H}, ${V}]`).else();
            Q.if(B, () => {
              if (Q.assign(G, true), Q.assign(H, V), L) X.mergeEvaluated(L, a8.Name);
            });
          });
        }
      } };
      dB.default = sj;
    });
    rB = P((nB) => {
      Object.defineProperty(nB, "__esModule", { value: true });
      var XR = e(), QR = { keyword: "allOf", schemaType: "array", code(X) {
        let { gen: Q, schema: $, it: Y } = X;
        if (!Array.isArray($)) throw Error("ajv implementation error");
        let W = Q.name("valid");
        $.forEach((J, G) => {
          if ((0, XR.alwaysValidSchema)(Y, J)) return;
          let H = X.subschema({ keyword: "allOf", schemaProp: G }, W);
          X.ok(W), X.mergeEvaluated(H);
        });
      } };
      nB.default = QR;
    });
    sB = P((aB) => {
      Object.defineProperty(aB, "__esModule", { value: true });
      var s8 = c(), tB = e(), YR = { message: ({ params: X }) => s8.str`must match "${X.ifClause}" schema`, params: ({ params: X }) => s8._`{failingKeyword: ${X.ifClause}}` }, WR = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: true, error: YR, code(X) {
        let { gen: Q, parentSchema: $, it: Y } = X;
        if ($.then === void 0 && $.else === void 0) (0, tB.checkStrictMode)(Y, '"if" without "then" and "else" is ignored');
        let W = oB(Y, "then"), J = oB(Y, "else");
        if (!W && !J) return;
        let G = Q.let("valid", true), H = Q.name("_valid");
        if (B(), X.reset(), W && J) {
          let K = Q.let("ifClause");
          X.setParams({ ifClause: K }), Q.if(H, z2("then", K), z2("else", K));
        } else if (W) Q.if(H, z2("then"));
        else Q.if((0, s8.not)(H), z2("else"));
        X.pass(G, () => X.error(true));
        function B() {
          let K = X.subschema({ keyword: "if", compositeRule: true, createErrors: false, allErrors: false }, H);
          X.mergeEvaluated(K);
        }
        function z2(K, V) {
          return () => {
            let L = X.subschema({ keyword: K }, H);
            if (Q.assign(G, H), X.mergeValidEvaluated(L, G), V) Q.assign(V, s8._`${K}`);
            else X.setParams({ ifClause: K });
          };
        }
      } };
      function oB(X, Q) {
        let $ = X.schema[Q];
        return $ !== void 0 && !(0, tB.alwaysValidSchema)(X, $);
      }
      aB.default = WR;
    });
    Xz = P((eB) => {
      Object.defineProperty(eB, "__esModule", { value: true });
      var GR = e(), HR = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: X, parentSchema: Q, it: $ }) {
        if (Q.if === void 0) (0, GR.checkStrictMode)($, `"${X}" without "if" is ignored`);
      } };
      eB.default = HR;
    });
    $z = P((Qz) => {
      Object.defineProperty(Qz, "__esModule", { value: true });
      var zR = yY(), KR = NB(), UR = gY(), VR = AB(), LR = MB(), qR = PB(), FR = CB(), NR = hY(), OR = xB(), DR = uB(), AR = mB(), wR = pB(), MR = iB(), jR = rB(), RR = sB(), ER = Xz();
      function IR(X = false) {
        let Q = [AR.default, wR.default, MR.default, jR.default, RR.default, ER.default, FR.default, NR.default, qR.default, OR.default, DR.default];
        if (X) Q.push(KR.default, VR.default);
        else Q.push(zR.default, UR.default);
        return Q.push(LR.default), Q;
      }
      Qz.default = IR;
    });
    Wz = P((Yz) => {
      Object.defineProperty(Yz, "__esModule", { value: true });
      var L0 = c(), PR = { message: ({ schemaCode: X }) => L0.str`must match format "${X}"`, params: ({ schemaCode: X }) => L0._`{format: ${X}}` }, SR = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: true, error: PR, code(X, Q) {
        let { gen: $, data: Y, $data: W, schema: J, schemaCode: G, it: H } = X, { opts: B, errSchemaPath: z2, schemaEnv: K, self: V } = H;
        if (!B.validateFormats) return;
        if (W) L();
        else U();
        function L() {
          let F = $.scopeValue("formats", { ref: V.formats, code: B.code.formats }), q = $.const("fDef", L0._`${F}[${G}]`), N = $.let("fType"), A = $.let("format");
          $.if(L0._`typeof ${q} == "object" && !(${q} instanceof RegExp)`, () => $.assign(N, L0._`${q}.type || "string"`).assign(A, L0._`${q}.validate`), () => $.assign(N, L0._`"string"`).assign(A, q)), X.fail$data((0, L0.or)(M(), R()));
          function M() {
            if (B.strictSchema === false) return L0.nil;
            return L0._`${G} && !${A}`;
          }
          function R() {
            let S = K.$async ? L0._`(${q}.async ? await ${A}(${Y}) : ${A}(${Y}))` : L0._`${A}(${Y})`, C = L0._`(typeof ${A} == "function" ? ${S} : ${A}.test(${Y}))`;
            return L0._`${A} && ${A} !== true && ${N} === ${Q} && !${C}`;
          }
        }
        function U() {
          let F = V.formats[J];
          if (!F) {
            M();
            return;
          }
          if (F === true) return;
          let [q, N, A] = R(F);
          if (q === Q) X.pass(S());
          function M() {
            if (B.strictSchema === false) {
              V.logger.warn(C());
              return;
            }
            throw Error(C());
            function C() {
              return `unknown format "${J}" ignored in schema at path "${z2}"`;
            }
          }
          function R(C) {
            let K0 = C instanceof RegExp ? (0, L0.regexpCode)(C) : B.code.formats ? L0._`${B.code.formats}${(0, L0.getProperty)(J)}` : void 0, U0 = $.scopeValue("formats", { key: J, ref: C, code: K0 });
            if (typeof C == "object" && !(C instanceof RegExp)) return [C.type || "string", C.validate, L0._`${U0}.validate`];
            return ["string", C, U0];
          }
          function S() {
            if (typeof F == "object" && !(F instanceof RegExp) && F.async) {
              if (!K.$async) throw Error("async format in sync schema");
              return L0._`await ${A}(${Y})`;
            }
            return typeof N == "function" ? L0._`${A}(${Y})` : L0._`${A}.test(${Y})`;
          }
        }
      } };
      Yz.default = SR;
    });
    Gz = P((Jz) => {
      Object.defineProperty(Jz, "__esModule", { value: true });
      var CR = Wz(), kR = [CR.default];
      Jz.default = kR;
    });
    zz = P((Hz) => {
      Object.defineProperty(Hz, "__esModule", { value: true });
      Hz.contentVocabulary = Hz.metadataVocabulary = void 0;
      Hz.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
      Hz.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
    });
    Vz = P((Uz) => {
      Object.defineProperty(Uz, "__esModule", { value: true });
      var _R = _H(), xR = HB(), yR = $z(), gR = Gz(), Kz = zz(), fR = [_R.default, xR.default, (0, yR.default)(), gR.default, Kz.metadataVocabulary, Kz.contentVocabulary];
      Uz.default = fR;
    });
    Nz = P((qz) => {
      Object.defineProperty(qz, "__esModule", { value: true });
      qz.DiscrError = void 0;
      var Lz;
      (function(X) {
        X.Tag = "tag", X.Mapping = "mapping";
      })(Lz || (qz.DiscrError = Lz = {}));
    });
    Az = P((Dz) => {
      Object.defineProperty(Dz, "__esModule", { value: true });
      var i6 = c(), lY = Nz(), Oz = _8(), uR = nX(), lR = e(), mR = { message: ({ params: { discrError: X, tagName: Q } }) => X === lY.DiscrError.Tag ? `tag "${Q}" must be string` : `value of tag "${Q}" must be in oneOf`, params: ({ params: { discrError: X, tag: Q, tagName: $ } }) => i6._`{error: ${X}, tag: ${$}, tagValue: ${Q}}` }, cR = { keyword: "discriminator", type: "object", schemaType: "object", error: mR, code(X) {
        let { gen: Q, data: $, schema: Y, parentSchema: W, it: J } = X, { oneOf: G } = W;
        if (!J.opts.discriminator) throw Error("discriminator: requires discriminator option");
        let H = Y.propertyName;
        if (typeof H != "string") throw Error("discriminator: requires propertyName");
        if (Y.mapping) throw Error("discriminator: mapping is not supported");
        if (!G) throw Error("discriminator: requires oneOf keyword");
        let B = Q.let("valid", false), z2 = Q.const("tag", i6._`${$}${(0, i6.getProperty)(H)}`);
        Q.if(i6._`typeof ${z2} == "string"`, () => K(), () => X.error(false, { discrError: lY.DiscrError.Tag, tag: z2, tagName: H })), X.ok(B);
        function K() {
          let U = L();
          Q.if(false);
          for (let F in U) Q.elseIf(i6._`${z2} === ${F}`), Q.assign(B, V(U[F]));
          Q.else(), X.error(false, { discrError: lY.DiscrError.Mapping, tag: z2, tagName: H }), Q.endIf();
        }
        function V(U) {
          let F = Q.name("valid"), q = X.subschema({ keyword: "oneOf", schemaProp: U }, F);
          return X.mergeEvaluated(q, i6.Name), F;
        }
        function L() {
          var U;
          let F = {}, q = A(W), N = true;
          for (let S = 0; S < G.length; S++) {
            let C = G[S];
            if ((C === null || C === void 0 ? void 0 : C.$ref) && !(0, lR.schemaHasRulesButRef)(C, J.self.RULES)) {
              let U0 = C.$ref;
              if (C = Oz.resolveRef.call(J.self, J.schemaEnv.root, J.baseId, U0), C instanceof Oz.SchemaEnv) C = C.schema;
              if (C === void 0) throw new uR.default(J.opts.uriResolver, J.baseId, U0);
            }
            let K0 = (U = C === null || C === void 0 ? void 0 : C.properties) === null || U === void 0 ? void 0 : U[H];
            if (typeof K0 != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${H}"`);
            N = N && (q || A(C)), M(K0, S);
          }
          if (!N) throw Error(`discriminator: "${H}" must be required`);
          return F;
          function A({ required: S }) {
            return Array.isArray(S) && S.includes(H);
          }
          function M(S, C) {
            if (S.const) R(S.const, C);
            else if (S.enum) for (let K0 of S.enum) R(K0, C);
            else throw Error(`discriminator: "properties/${H}" must have "const" or "enum"`);
          }
          function R(S, C) {
            if (typeof S != "string" || S in F) throw Error(`discriminator: "${H}" values must be unique strings`);
            F[S] = C;
          }
        }
      } };
      Dz.default = cR;
    });
    wz = P((W_, dR) => {
      dR.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
    });
    cY = P((f0, mY) => {
      Object.defineProperty(f0, "__esModule", { value: true });
      f0.MissingRefError = f0.ValidationError = f0.CodeGen = f0.Name = f0.nil = f0.stringify = f0.str = f0._ = f0.KeywordCxt = f0.Ajv = void 0;
      var iR = EH(), nR = Vz(), rR = Az(), Mz = wz(), oR = ["/properties"], e8 = "http://json-schema.org/draft-07/schema";
      class J4 extends iR.default {
        _addVocabularies() {
          if (super._addVocabularies(), nR.default.forEach((X) => this.addVocabulary(X)), this.opts.discriminator) this.addKeyword(rR.default);
        }
        _addDefaultMetaSchema() {
          if (super._addDefaultMetaSchema(), !this.opts.meta) return;
          let X = this.opts.$data ? this.$dataMetaSchema(Mz, oR) : Mz;
          this.addMetaSchema(X, e8, false), this.refs["http://json-schema.org/schema"] = e8;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(e8) ? e8 : void 0);
        }
      }
      f0.Ajv = J4;
      mY.exports = f0 = J4;
      mY.exports.Ajv = J4;
      Object.defineProperty(f0, "__esModule", { value: true });
      f0.default = J4;
      var tR = iX();
      Object.defineProperty(f0, "KeywordCxt", { enumerable: true, get: function() {
        return tR.KeywordCxt;
      } });
      var n6 = c();
      Object.defineProperty(f0, "_", { enumerable: true, get: function() {
        return n6._;
      } });
      Object.defineProperty(f0, "str", { enumerable: true, get: function() {
        return n6.str;
      } });
      Object.defineProperty(f0, "stringify", { enumerable: true, get: function() {
        return n6.stringify;
      } });
      Object.defineProperty(f0, "nil", { enumerable: true, get: function() {
        return n6.nil;
      } });
      Object.defineProperty(f0, "Name", { enumerable: true, get: function() {
        return n6.Name;
      } });
      Object.defineProperty(f0, "CodeGen", { enumerable: true, get: function() {
        return n6.CodeGen;
      } });
      var aR = v8();
      Object.defineProperty(f0, "ValidationError", { enumerable: true, get: function() {
        return aR.default;
      } });
      var sR = nX();
      Object.defineProperty(f0, "MissingRefError", { enumerable: true, get: function() {
        return sR.default;
      } });
    });
    kz = P((Zz) => {
      Object.defineProperty(Zz, "__esModule", { value: true });
      Zz.formatNames = Zz.fastFormats = Zz.fullFormats = void 0;
      function L1(X, Q) {
        return { validate: X, compare: Q };
      }
      Zz.fullFormats = { date: L1(Iz, nY), time: L1(dY(true), rY), "date-time": L1(jz(true), Pz), "iso-time": L1(dY(), bz), "iso-date-time": L1(jz(), Sz), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: GE, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: LE, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: HE, int32: { type: "number", validate: KE }, int64: { type: "number", validate: UE }, float: { type: "number", validate: Ez }, double: { type: "number", validate: Ez }, password: true, binary: true };
      Zz.fastFormats = { ...Zz.fullFormats, date: L1(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, nY), time: L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, rY), "date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, Pz), "iso-time": L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, bz), "iso-date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Sz), uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i };
      Zz.formatNames = Object.keys(Zz.fullFormats);
      function QE(X) {
        return X % 4 === 0 && (X % 100 !== 0 || X % 400 === 0);
      }
      var $E = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, YE = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function Iz(X) {
        let Q = $E.exec(X);
        if (!Q) return false;
        let $ = +Q[1], Y = +Q[2], W = +Q[3];
        return Y >= 1 && Y <= 12 && W >= 1 && W <= (Y === 2 && QE($) ? 29 : YE[Y]);
      }
      function nY(X, Q) {
        if (!(X && Q)) return;
        if (X > Q) return 1;
        if (X < Q) return -1;
        return 0;
      }
      var pY = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
      function dY(X) {
        return function($) {
          let Y = pY.exec($);
          if (!Y) return false;
          let W = +Y[1], J = +Y[2], G = +Y[3], H = Y[4], B = Y[5] === "-" ? -1 : 1, z2 = +(Y[6] || 0), K = +(Y[7] || 0);
          if (z2 > 23 || K > 59 || X && !H) return false;
          if (W <= 23 && J <= 59 && G < 60) return true;
          let V = J - K * B, L = W - z2 * B - (V < 0 ? 1 : 0);
          return (L === 23 || L === -1) && (V === 59 || V === -1) && G < 61;
        };
      }
      function rY(X, Q) {
        if (!(X && Q)) return;
        let $ = (/* @__PURE__ */ new Date("2020-01-01T" + X)).valueOf(), Y = (/* @__PURE__ */ new Date("2020-01-01T" + Q)).valueOf();
        if (!($ && Y)) return;
        return $ - Y;
      }
      function bz(X, Q) {
        if (!(X && Q)) return;
        let $ = pY.exec(X), Y = pY.exec(Q);
        if (!($ && Y)) return;
        if (X = $[1] + $[2] + $[3], Q = Y[1] + Y[2] + Y[3], X > Q) return 1;
        if (X < Q) return -1;
        return 0;
      }
      var iY = /t|\s/i;
      function jz(X) {
        let Q = dY(X);
        return function(Y) {
          let W = Y.split(iY);
          return W.length === 2 && Iz(W[0]) && Q(W[1]);
        };
      }
      function Pz(X, Q) {
        if (!(X && Q)) return;
        let $ = new Date(X).valueOf(), Y = new Date(Q).valueOf();
        if (!($ && Y)) return;
        return $ - Y;
      }
      function Sz(X, Q) {
        if (!(X && Q)) return;
        let [$, Y] = X.split(iY), [W, J] = Q.split(iY), G = nY($, W);
        if (G === void 0) return;
        return G || rY(Y, J);
      }
      var WE = /\/|:/, JE = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function GE(X) {
        return WE.test(X) && JE.test(X);
      }
      var Rz = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function HE(X) {
        return Rz.lastIndex = 0, Rz.test(X);
      }
      var BE = -2147483648, zE = 2147483647;
      function KE(X) {
        return Number.isInteger(X) && X <= zE && X >= BE;
      }
      function UE(X) {
        return Number.isInteger(X);
      }
      function Ez() {
        return true;
      }
      var VE = /[^\\]\\Z/;
      function LE(X) {
        if (VE.test(X)) return false;
        try {
          return new RegExp(X), true;
        } catch (Q) {
          return false;
        }
      }
    });
    Tz = P((vz) => {
      Object.defineProperty(vz, "__esModule", { value: true });
      vz.formatLimitDefinition = void 0;
      var FE = cY(), Y1 = c(), n1 = Y1.operators, X9 = { formatMaximum: { okStr: "<=", ok: n1.LTE, fail: n1.GT }, formatMinimum: { okStr: ">=", ok: n1.GTE, fail: n1.LT }, formatExclusiveMaximum: { okStr: "<", ok: n1.LT, fail: n1.GTE }, formatExclusiveMinimum: { okStr: ">", ok: n1.GT, fail: n1.LTE } }, NE = { message: ({ keyword: X, schemaCode: Q }) => Y1.str`should be ${X9[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => Y1._`{comparison: ${X9[X].okStr}, limit: ${Q}}` };
      vz.formatLimitDefinition = { keyword: Object.keys(X9), type: "string", schemaType: "string", $data: true, error: NE, code(X) {
        let { gen: Q, data: $, schemaCode: Y, keyword: W, it: J } = X, { opts: G, self: H } = J;
        if (!G.validateFormats) return;
        let B = new FE.KeywordCxt(J, H.RULES.all.format.definition, "format");
        if (B.$data) z2();
        else K();
        function z2() {
          let L = Q.scopeValue("formats", { ref: H.formats, code: G.code.formats }), U = Q.const("fmt", Y1._`${L}[${B.schemaCode}]`);
          X.fail$data((0, Y1.or)(Y1._`typeof ${U} != "object"`, Y1._`${U} instanceof RegExp`, Y1._`typeof ${U}.compare != "function"`, V(U)));
        }
        function K() {
          let L = B.schema, U = H.formats[L];
          if (!U || U === true) return;
          if (typeof U != "object" || U instanceof RegExp || typeof U.compare != "function") throw Error(`"${W}": format "${L}" does not define "compare" function`);
          let F = Q.scopeValue("formats", { key: L, ref: U, code: G.code.formats ? Y1._`${G.code.formats}${(0, Y1.getProperty)(L)}` : void 0 });
          X.fail$data(V(F));
        }
        function V(L) {
          return Y1._`${L}.compare(${$}, ${Y}) ${X9[W].fail} 0`;
        }
      }, dependencies: ["format"] };
      var OE = (X) => {
        return X.addKeyword(vz.formatLimitDefinition), X;
      };
      vz.default = OE;
    });
    gz = P((G4, yz) => {
      Object.defineProperty(G4, "__esModule", { value: true });
      var r6 = kz(), AE = Tz(), aY = c(), _z = new aY.Name("fullFormats"), wE = new aY.Name("fastFormats"), sY = (X, Q = { keywords: true }) => {
        if (Array.isArray(Q)) return xz(X, Q, r6.fullFormats, _z), X;
        let [$, Y] = Q.mode === "fast" ? [r6.fastFormats, wE] : [r6.fullFormats, _z], W = Q.formats || r6.formatNames;
        if (xz(X, W, $, Y), Q.keywords) (0, AE.default)(X);
        return X;
      };
      sY.get = (X, Q = "full") => {
        let Y = (Q === "fast" ? r6.fastFormats : r6.fullFormats)[X];
        if (!Y) throw Error(`Unknown format "${X}"`);
        return Y;
      };
      function xz(X, Q, $, Y) {
        var W, J;
        (W = (J = X.opts.code).formats) !== null && W !== void 0 || (J.formats = aY._`require("ajv-formats/dist/formats").${Y}`);
        for (let G of Q) X.addFormat(G, $[G]);
      }
      yz.exports = G4 = sY;
      Object.defineProperty(G4, "__esModule", { value: true });
      G4.default = sY;
    });
    BK = 50;
    zK = typeof global == "object" && global && global.Object === Object && global;
    q7 = zK;
    KK = typeof self == "object" && self && self.Object === Object && self;
    UK = q7 || KK || Function("return this")();
    O6 = UK;
    VK = O6.Symbol;
    D6 = VK;
    F7 = Object.prototype;
    LK = F7.hasOwnProperty;
    qK = F7.toString;
    e6 = D6 ? D6.toStringTag : void 0;
    N7 = FK;
    NK = Object.prototype;
    OK = NK.toString;
    O7 = DK;
    AK = "[object Null]";
    wK = "[object Undefined]";
    D7 = D6 ? D6.toStringTag : void 0;
    A7 = MK;
    z4 = jK;
    RK = "[object AsyncFunction]";
    EK = "[object Function]";
    IK = "[object GeneratorFunction]";
    bK = "[object Proxy]";
    w7 = PK;
    SK = O6["__core-js_shared__"];
    K4 = SK;
    M7 = (function() {
      var X = /[^.]+$/.exec(K4 && K4.keys && K4.keys.IE_PROTO || "");
      return X ? "Symbol(src)_1." + X : "";
    })();
    j7 = ZK;
    CK = Function.prototype;
    kK = CK.toString;
    R7 = vK;
    TK = /[\\^$.*+?()[\]{}|]/g;
    _K = /^\[object .+?Constructor\]$/;
    xK = Function.prototype;
    yK = Object.prototype;
    gK = xK.toString;
    fK = yK.hasOwnProperty;
    hK = RegExp("^" + gK.call(fK).replace(TK, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    E7 = uK;
    I7 = lK;
    U4 = mK;
    cK = U4(Object, "create");
    q1 = cK;
    b7 = pK;
    P7 = dK;
    iK = "__lodash_hash_undefined__";
    nK = Object.prototype;
    rK = nK.hasOwnProperty;
    S7 = oK;
    tK = Object.prototype;
    aK = tK.hasOwnProperty;
    Z7 = sK;
    eK = "__lodash_hash_undefined__";
    C7 = XU;
    A6.prototype.clear = b7;
    A6.prototype.delete = P7;
    A6.prototype.get = S7;
    A6.prototype.has = Z7;
    A6.prototype.set = C7;
    W9 = A6;
    k7 = QU;
    v7 = $U;
    Z1 = YU;
    WU = Array.prototype;
    JU = WU.splice;
    T7 = GU;
    _7 = HU;
    x7 = BU;
    y7 = zU;
    w6.prototype.clear = k7;
    w6.prototype.delete = T7;
    w6.prototype.get = _7;
    w6.prototype.has = x7;
    w6.prototype.set = y7;
    g7 = w6;
    KU = U4(O6, "Map");
    f7 = KU;
    h7 = UU;
    u7 = VU;
    C1 = LU;
    l7 = qU;
    m7 = FU;
    c7 = NU;
    p7 = OU;
    M6.prototype.clear = h7;
    M6.prototype.delete = l7;
    M6.prototype.get = m7;
    M6.prototype.has = c7;
    M6.prototype.set = p7;
    J9 = M6;
    DU = "Expected a function";
    G9.Cache = J9;
    k1 = G9;
    i7 = k1((X) => {
      if (!X || X.trim() === "") return null;
      let Q = X.split(",").map((J) => J.trim()).filter(Boolean);
      if (Q.length === 0) return null;
      let $ = Q.some((J) => J.startsWith("!")), Y = Q.some((J) => !J.startsWith("!"));
      if ($ && Y) return null;
      let W = Q.map((J) => J.replace(/^!/, "").toLowerCase());
      return { include: $ ? [] : W, exclude: $ ? W : [], isExclusive: $ };
    });
    o7 = r7("BASH_MAX_OUTPUT_LENGTH");
    Eb = r7("TASK_MAX_OUTPUT_LENGTH");
    t7 = { name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS", default: 32e3, validate: (X) => {
      if (!X) return { effective: 32e3, status: "valid" };
      let Y = parseInt(X, 10);
      if (isNaN(Y) || Y <= 0) return { effective: 32e3, status: "invalid", message: `Invalid value "${X}" (using default: 32000)` };
      if (Y > 64e3) return { effective: 64e3, status: "capped", message: `Capped from ${Y} to 64000` };
      return { effective: Y, status: "valid" };
    } };
    SU = PU();
    e7 = /* @__PURE__ */ new Set();
    B9 = 1 / 0;
    L4 = (X, Q) => {
      let $ = typeof X === "string" ? X.length : 0;
      return QW(`JSON.parse(${$} chars)`, () => JSON.parse(X, Q));
    };
    CU = k1(() => {
      return H9(process.env.DEBUG) || H9(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || YW() || process.argv.some((X) => X.startsWith("--debug=")) || WW() !== null;
    });
    kU = k1(() => {
      let X = process.argv.find(($) => $.startsWith("--debug="));
      if (!X) return null;
      let Q = X.substring(8);
      return i7(Q);
    });
    YW = k1(() => {
      return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e");
    });
    WW = k1(() => {
      for (let X = 0; X < process.argv.length; X++) {
        let Q = process.argv[X];
        if (Q.startsWith("--debug-file=")) return Q.substring(13);
        if (Q === "--debug-file" && X + 1 < process.argv.length) return process.argv[X + 1];
      }
      return null;
    });
    TU = false;
    q4 = null;
    xU = k1(() => {
      if (process.argv[2] === "--ripgrep") return;
      try {
        let X = JW(), Q = (0, import_path3.dirname)(X), $ = (0, import_path3.join)(Q, "latest");
        if (!n0().existsSync(Q)) n0().mkdirSync(Q);
        if (n0().existsSync($)) try {
          n0().unlinkSync($);
        } catch {
        }
        n0().symlinkSync(X, $);
      } catch {
      }
    });
    mU = { cwd() {
      return process.cwd();
    }, existsSync(X) {
      return F0(`existsSync(${X})`, () => h.existsSync(X));
    }, async stat(X) {
      return (0, import_promises.stat)(X);
    }, async readdir(X) {
      return (0, import_promises.readdir)(X, { withFileTypes: true });
    }, async unlink(X) {
      return (0, import_promises.unlink)(X);
    }, async rmdir(X) {
      return (0, import_promises.rmdir)(X);
    }, async rm(X, Q) {
      return (0, import_promises.rm)(X, Q);
    }, statSync(X) {
      return F0(`statSync(${X})`, () => h.statSync(X));
    }, lstatSync(X) {
      return F0(`lstatSync(${X})`, () => h.lstatSync(X));
    }, readFileSync(X, Q) {
      return F0(`readFileSync(${X})`, () => h.readFileSync(X, { encoding: Q.encoding }));
    }, readFileBytesSync(X) {
      return F0(`readFileBytesSync(${X})`, () => h.readFileSync(X));
    }, readSync(X, Q) {
      return F0(`readSync(${X}, ${Q.length} bytes)`, () => {
        let $ = void 0;
        try {
          $ = h.openSync(X, "r");
          let Y = Buffer.alloc(Q.length), W = h.readSync($, Y, 0, Q.length, 0);
          return { buffer: Y, bytesRead: W };
        } finally {
          if ($) h.closeSync($);
        }
      });
    }, appendFileSync(X, Q, $) {
      return F0(`appendFileSync(${X}, ${Q.length} chars)`, () => {
        if (!h.existsSync(X) && $?.mode !== void 0) {
          let Y = h.openSync(X, "a", $.mode);
          try {
            h.appendFileSync(Y, Q);
          } finally {
            h.closeSync(Y);
          }
        } else h.appendFileSync(X, Q);
      });
    }, copyFileSync(X, Q) {
      return F0(`copyFileSync(${X} \u2192 ${Q})`, () => h.copyFileSync(X, Q));
    }, unlinkSync(X) {
      return F0(`unlinkSync(${X})`, () => h.unlinkSync(X));
    }, renameSync(X, Q) {
      return F0(`renameSync(${X} \u2192 ${Q})`, () => h.renameSync(X, Q));
    }, linkSync(X, Q) {
      return F0(`linkSync(${X} \u2192 ${Q})`, () => h.linkSync(X, Q));
    }, symlinkSync(X, Q) {
      return F0(`symlinkSync(${X} \u2192 ${Q})`, () => h.symlinkSync(X, Q));
    }, readlinkSync(X) {
      return F0(`readlinkSync(${X})`, () => h.readlinkSync(X));
    }, realpathSync(X) {
      return F0(`realpathSync(${X})`, () => h.realpathSync(X));
    }, mkdirSync(X, Q) {
      return F0(`mkdirSync(${X})`, () => {
        if (!h.existsSync(X)) {
          let $ = { recursive: true };
          if (Q?.mode !== void 0) $.mode = Q.mode;
          h.mkdirSync(X, $);
        }
      });
    }, readdirSync(X) {
      return F0(`readdirSync(${X})`, () => h.readdirSync(X, { withFileTypes: true }));
    }, readdirStringSync(X) {
      return F0(`readdirStringSync(${X})`, () => h.readdirSync(X));
    }, isDirEmptySync(X) {
      return F0(`isDirEmptySync(${X})`, () => {
        return this.readdirSync(X).length === 0;
      });
    }, rmdirSync(X) {
      return F0(`rmdirSync(${X})`, () => h.rmdirSync(X));
    }, rmSync(X, Q) {
      return F0(`rmSync(${X})`, () => h.rmSync(X, Q));
    }, createWriteStream(X) {
      return h.createWriteStream(X);
    } };
    cU = mU;
    pU = ["PreToolUse", "PostToolUse", "PostToolUseFailure", "Notification", "UserPromptSubmit", "SessionStart", "SessionEnd", "Stop", "SubagentStart", "SubagentStop", "PreCompact", "PermissionRequest", "Setup"];
    dU = ["clear", "logout", "prompt_input_exit", "other", "bypass_permissions_disabled"];
    F1 = class extends Error {
    };
    F4 = null;
    HW = false;
    XX = class {
      options;
      process;
      processStdin;
      processStdout;
      ready = false;
      abortController;
      exitError;
      exitListeners = [];
      processExitHandler;
      abortHandler;
      constructor(X) {
        this.options = X;
        this.abortController = X.abortController || N6(), this.initialize();
      }
      getDefaultExecutable() {
        return j6() ? "bun" : "node";
      }
      spawnLocalProcess(X) {
        let { command: Q, args: $, cwd: Y, env: W, signal: J } = X, G = W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore", H = (0, import_child_process2.spawn)(Q, $, { cwd: Y, stdio: ["pipe", "pipe", G], signal: J, env: W, windowsHide: true });
        if (W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) H.stderr.on("data", (z2) => {
          let K = z2.toString();
          if (N1(K), this.options.stderr) this.options.stderr(K);
        });
        return { stdin: H.stdin, stdout: H.stdout, get killed() {
          return H.killed;
        }, get exitCode() {
          return H.exitCode;
        }, kill: H.kill.bind(H), on: H.on.bind(H), once: H.once.bind(H), off: H.off.bind(H) };
      }
      initialize() {
        try {
          let { additionalDirectories: X = [], agent: Q, betas: $, cwd: Y, executable: W = this.getDefaultExecutable(), executableArgs: J = [], extraArgs: G = {}, pathToClaudeCodeExecutable: H, env: B = { ...process.env }, maxThinkingTokens: z2, maxTurns: K, maxBudgetUsd: V, model: L, fallbackModel: U, jsonSchema: F, permissionMode: q, allowDangerouslySkipPermissions: N, permissionPromptToolName: A, continueConversation: M, resume: R, settingSources: S, allowedTools: C = [], disallowedTools: K0 = [], tools: U0, mcpServers: s, strictMcpConfig: D0, canUseTool: q0, includePartialMessages: W1, plugins: P1, sandbox: U6 } = this.options, d = ["--output-format", "stream-json", "--verbose", "--input-format", "stream-json"];
          if (z2 !== void 0) d.push("--max-thinking-tokens", z2.toString());
          if (K) d.push("--max-turns", K.toString());
          if (V !== void 0) d.push("--max-budget-usd", V.toString());
          if (L) d.push("--model", L);
          if (Q) d.push("--agent", Q);
          if ($ && $.length > 0) d.push("--betas", $.join(","));
          if (F) d.push("--json-schema", Z0(F));
          if (B.DEBUG_CLAUDE_AGENT_SDK) d.push("--debug-to-stderr");
          if (q0) {
            if (A) throw Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
            d.push("--permission-prompt-tool", "stdio");
          } else if (A) d.push("--permission-prompt-tool", A);
          if (M) d.push("--continue");
          if (R) d.push("--resume", R);
          if (C.length > 0) d.push("--allowedTools", C.join(","));
          if (K0.length > 0) d.push("--disallowedTools", K0.join(","));
          if (U0 !== void 0) if (Array.isArray(U0)) if (U0.length === 0) d.push("--tools", "");
          else d.push("--tools", U0.join(","));
          else d.push("--tools", "default");
          if (s && Object.keys(s).length > 0) d.push("--mcp-config", Z0({ mcpServers: s }));
          if (S) d.push("--setting-sources", S.join(","));
          if (D0) d.push("--strict-mcp-config");
          if (q) d.push("--permission-mode", q);
          if (N) d.push("--allow-dangerously-skip-permissions");
          if (U) {
            if (L && U === L) throw Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
            d.push("--fallback-model", U);
          }
          if (W1) d.push("--include-partial-messages");
          for (let S0 of X) d.push("--add-dir", S0);
          if (P1 && P1.length > 0) for (let S0 of P1) if (S0.type === "local") d.push("--plugin-dir", S0.path);
          else throw Error(`Unsupported plugin type: ${S0.type}`);
          if (this.options.forkSession) d.push("--fork-session");
          if (this.options.resumeSessionAt) d.push("--resume-session-at", this.options.resumeSessionAt);
          if (this.options.persistSession === false) d.push("--no-session-persistence");
          let Q9 = BW(G ?? {}, U6);
          for (let [S0, S1] of Object.entries(Q9)) if (S1 === null) d.push(`--${S0}`);
          else d.push(`--${S0}`, S1);
          if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
          if (delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK) B.DEBUG = "1";
          else delete B.DEBUG;
          let o6 = eU(H), V6 = o6 ? H : W, t6 = o6 ? [...J, ...d] : [...J, H, ...d], a6 = { command: V6, args: t6, cwd: Y, env: B, signal: this.abortController.signal };
          if (this.options.spawnClaudeCodeProcess) N1(`Spawning Claude Code (custom): ${V6} ${t6.join(" ")}`), this.process = this.options.spawnClaudeCodeProcess(a6);
          else {
            if (!n0().existsSync(H)) {
              let S1 = o6 ? `Claude Code native binary not found at ${H}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${H}. Is options.pathToClaudeCodeExecutable set?`;
              throw ReferenceError(S1);
            }
            N1(`Spawning Claude Code: ${V6} ${t6.join(" ")}`), this.process = this.spawnLocalProcess(a6);
          }
          this.processStdin = this.process.stdin, this.processStdout = this.process.stdout;
          let B4 = () => {
            if (this.process && !this.process.killed) this.process.kill("SIGTERM");
          };
          this.processExitHandler = B4, this.abortHandler = B4, process.on("exit", this.processExitHandler), this.abortController.signal.addEventListener("abort", this.abortHandler), this.process.on("error", (S0) => {
            if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
            else this.exitError = Error(`Failed to spawn Claude Code process: ${S0.message}`), N1(this.exitError.message);
          }), this.process.on("exit", (S0, S1) => {
            if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
            else {
              let s6 = this.getProcessExitError(S0, S1);
              if (s6) this.exitError = s6, N1(s6.message);
            }
          }), this.ready = true;
        } catch (X) {
          throw this.ready = false, X;
        }
      }
      getProcessExitError(X, Q) {
        if (X !== 0 && X !== null) return Error(`Claude Code process exited with code ${X}`);
        else if (Q) return Error(`Claude Code process terminated by signal ${Q}`);
        return;
      }
      write(X) {
        if (this.abortController.signal.aborted) throw new F1("Operation aborted");
        if (!this.ready || !this.processStdin) throw Error("ProcessTransport is not ready for writing");
        if (this.process?.killed || this.process?.exitCode !== null) throw Error("Cannot write to terminated process");
        if (this.exitError) throw Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
        N1(`[ProcessTransport] Writing to stdin: ${X.substring(0, 100)}`);
        try {
          if (!this.processStdin.write(X)) N1("[ProcessTransport] Write buffer full, data queued");
        } catch (Q) {
          throw this.ready = false, Error(`Failed to write to process stdin: ${Q.message}`);
        }
      }
      close() {
        if (this.processStdin) this.processStdin.end(), this.processStdin = void 0;
        if (this.abortHandler) this.abortController.signal.removeEventListener("abort", this.abortHandler), this.abortHandler = void 0;
        for (let { handler: X } of this.exitListeners) this.process?.off("exit", X);
        if (this.exitListeners = [], this.process && !this.process.killed) this.process.kill("SIGTERM"), setTimeout(() => {
          if (this.process && !this.process.killed) this.process.kill("SIGKILL");
        }, 5e3);
        if (this.ready = false, this.processExitHandler) process.off("exit", this.processExitHandler), this.processExitHandler = void 0;
      }
      isReady() {
        return this.ready;
      }
      async *readMessages() {
        if (!this.processStdout) throw Error("ProcessTransport output stream not available");
        let X = (0, import_readline.createInterface)({ input: this.processStdout });
        try {
          for await (let Q of X) if (Q.trim()) try {
            yield L4(Q);
          } catch ($) {
            throw N1(`Non-JSON stdout: ${Q}`), Error(`CLI output was not valid JSON. This may indicate an error during startup. Output: ${Q.slice(0, 200)}${Q.length > 200 ? "..." : ""}`);
          }
          await this.waitForExit();
        } catch (Q) {
          throw Q;
        } finally {
          X.close();
        }
      }
      endInput() {
        if (this.processStdin) this.processStdin.end();
      }
      getInputStream() {
        return this.processStdin;
      }
      onExit(X) {
        if (!this.process) return () => {
        };
        let Q = ($, Y) => {
          let W = this.getProcessExitError($, Y);
          X(W);
        };
        return this.process.on("exit", Q), this.exitListeners.push({ callback: X, handler: Q }), () => {
          if (this.process) this.process.off("exit", Q);
          let $ = this.exitListeners.findIndex((Y) => Y.handler === Q);
          if ($ !== -1) this.exitListeners.splice($, 1);
        };
      }
      async waitForExit() {
        if (!this.process) {
          if (this.exitError) throw this.exitError;
          return;
        }
        if (this.process.exitCode !== null || this.process.killed) {
          if (this.exitError) throw this.exitError;
          return;
        }
        return new Promise((X, Q) => {
          let $ = (W, J) => {
            if (this.abortController.signal.aborted) {
              Q(new F1("Operation aborted"));
              return;
            }
            let G = this.getProcessExitError(W, J);
            if (G) Q(G);
            else X();
          };
          this.process.once("exit", $);
          let Y = (W) => {
            this.process.off("exit", $), Q(W);
          };
          this.process.once("error", Y), this.process.once("exit", () => {
            this.process.off("error", Y);
          });
        });
      }
    };
    QX = class {
      returned;
      queue = [];
      readResolve;
      readReject;
      isDone = false;
      hasError;
      started = false;
      constructor(X) {
        this.returned = X;
      }
      [Symbol.asyncIterator]() {
        if (this.started) throw Error("Stream can only be iterated once");
        return this.started = true, this;
      }
      next() {
        if (this.queue.length > 0) return Promise.resolve({ done: false, value: this.queue.shift() });
        if (this.isDone) return Promise.resolve({ done: true, value: void 0 });
        if (this.hasError) return Promise.reject(this.hasError);
        return new Promise((X, Q) => {
          this.readResolve = X, this.readReject = Q;
        });
      }
      enqueue(X) {
        if (this.readResolve) {
          let Q = this.readResolve;
          this.readResolve = void 0, this.readReject = void 0, Q({ done: false, value: X });
        } else this.queue.push(X);
      }
      done() {
        if (this.isDone = true, this.readResolve) {
          let X = this.readResolve;
          this.readResolve = void 0, this.readReject = void 0, X({ done: true, value: void 0 });
        }
      }
      error(X) {
        if (this.hasError = X, this.readReject) {
          let Q = this.readReject;
          this.readResolve = void 0, this.readReject = void 0, Q(X);
        }
      }
      return() {
        if (this.isDone = true, this.returned) this.returned();
        return Promise.resolve({ done: true, value: void 0 });
      }
    };
    K9 = class {
      sendMcpMessage;
      isClosed = false;
      constructor(X) {
        this.sendMcpMessage = X;
      }
      onclose;
      onerror;
      onmessage;
      async start() {
      }
      async send(X) {
        if (this.isClosed) throw Error("Transport is closed");
        this.sendMcpMessage(X);
      }
      async close() {
        if (this.isClosed) return;
        this.isClosed = true, this.onclose?.();
      }
    };
    $X = class {
      transport;
      isSingleUserTurn;
      canUseTool;
      hooks;
      abortController;
      jsonSchema;
      initConfig;
      pendingControlResponses = /* @__PURE__ */ new Map();
      cleanupPerformed = false;
      sdkMessages;
      inputStream = new QX();
      initialization;
      cancelControllers = /* @__PURE__ */ new Map();
      hookCallbacks = /* @__PURE__ */ new Map();
      nextCallbackId = 0;
      sdkMcpTransports = /* @__PURE__ */ new Map();
      sdkMcpServerInstances = /* @__PURE__ */ new Map();
      pendingMcpResponses = /* @__PURE__ */ new Map();
      firstResultReceivedResolve;
      firstResultReceived = false;
      hasBidirectionalNeeds() {
        return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0;
      }
      constructor(X, Q, $, Y, W, J = /* @__PURE__ */ new Map(), G, H) {
        this.transport = X;
        this.isSingleUserTurn = Q;
        this.canUseTool = $;
        this.hooks = Y;
        this.abortController = W;
        this.jsonSchema = G;
        this.initConfig = H;
        for (let [B, z2] of J) this.connectSdkMcpServer(B, z2);
        this.sdkMessages = this.readSdkMessages(), this.readMessages(), this.initialization = this.initialize(), this.initialization.catch(() => {
        });
      }
      setError(X) {
        this.inputStream.error(X);
      }
      close() {
        this.cleanup();
      }
      cleanup(X) {
        if (this.cleanupPerformed) return;
        this.cleanupPerformed = true;
        try {
          this.transport.close(), this.pendingControlResponses.clear(), this.pendingMcpResponses.clear(), this.cancelControllers.clear(), this.hookCallbacks.clear();
          for (let Q of this.sdkMcpTransports.values()) try {
            Q.close();
          } catch {
          }
          if (this.sdkMcpTransports.clear(), X) this.inputStream.error(X);
          else this.inputStream.done();
        } catch (Q) {
        }
      }
      next(...[X]) {
        return this.sdkMessages.next(...[X]);
      }
      return(X) {
        return this.sdkMessages.return(X);
      }
      throw(X) {
        return this.sdkMessages.throw(X);
      }
      [Symbol.asyncIterator]() {
        return this.sdkMessages;
      }
      [Symbol.asyncDispose]() {
        return this.sdkMessages[Symbol.asyncDispose]();
      }
      async readMessages() {
        try {
          for await (let X of this.transport.readMessages()) {
            if (X.type === "control_response") {
              let Q = this.pendingControlResponses.get(X.response.request_id);
              if (Q) Q(X.response);
              continue;
            } else if (X.type === "control_request") {
              this.handleControlRequest(X);
              continue;
            } else if (X.type === "control_cancel_request") {
              this.handleControlCancelRequest(X);
              continue;
            } else if (X.type === "keep_alive") continue;
            if (X.type === "result") {
              if (this.firstResultReceived = true, this.firstResultReceivedResolve) this.firstResultReceivedResolve();
              if (this.isSingleUserTurn) v1("[Query.readMessages] First result received for single-turn query, closing stdin"), this.transport.endInput();
            }
            this.inputStream.enqueue(X);
          }
          if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
          this.inputStream.done(), this.cleanup();
        } catch (X) {
          if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
          this.inputStream.error(X), this.cleanup(X);
        }
      }
      async handleControlRequest(X) {
        let Q = new AbortController();
        this.cancelControllers.set(X.request_id, Q);
        try {
          let $ = await this.processControlRequest(X, Q.signal), Y = { type: "control_response", response: { subtype: "success", request_id: X.request_id, response: $ } };
          await Promise.resolve(this.transport.write(Z0(Y) + `
`));
        } catch ($) {
          let Y = { type: "control_response", response: { subtype: "error", request_id: X.request_id, error: $.message || String($) } };
          await Promise.resolve(this.transport.write(Z0(Y) + `
`));
        } finally {
          this.cancelControllers.delete(X.request_id);
        }
      }
      handleControlCancelRequest(X) {
        let Q = this.cancelControllers.get(X.request_id);
        if (Q) Q.abort(), this.cancelControllers.delete(X.request_id);
      }
      async processControlRequest(X, Q) {
        if (X.request.subtype === "can_use_tool") {
          if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
          return { ...await this.canUseTool(X.request.tool_name, X.request.input, { signal: Q, suggestions: X.request.permission_suggestions, blockedPath: X.request.blocked_path, decisionReason: X.request.decision_reason, toolUseID: X.request.tool_use_id, agentID: X.request.agent_id }), toolUseID: X.request.tool_use_id };
        } else if (X.request.subtype === "hook_callback") return await this.handleHookCallbacks(X.request.callback_id, X.request.input, X.request.tool_use_id, Q);
        else if (X.request.subtype === "mcp_message") {
          let $ = X.request, Y = this.sdkMcpTransports.get($.server_name);
          if (!Y) throw Error(`SDK MCP server not found: ${$.server_name}`);
          if ("method" in $.message && "id" in $.message && $.message.id !== null) return { mcp_response: await this.handleMcpControlRequest($.server_name, $, Y) };
          else {
            if (Y.onmessage) Y.onmessage($.message);
            return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
          }
        }
        throw Error("Unsupported control request subtype: " + X.request.subtype);
      }
      async *readSdkMessages() {
        for await (let X of this.inputStream) yield X;
      }
      async initialize() {
        let X;
        if (this.hooks) {
          X = {};
          for (let [W, J] of Object.entries(this.hooks)) if (J.length > 0) X[W] = J.map((G) => {
            let H = [];
            for (let B of G.hooks) {
              let z2 = `hook_${this.nextCallbackId++}`;
              this.hookCallbacks.set(z2, B), H.push(z2);
            }
            return { matcher: G.matcher, hookCallbackIds: H, timeout: G.timeout };
          });
        }
        let Q = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0, $ = { subtype: "initialize", hooks: X, sdkMcpServers: Q, jsonSchema: this.jsonSchema, systemPrompt: this.initConfig?.systemPrompt, appendSystemPrompt: this.initConfig?.appendSystemPrompt, agents: this.initConfig?.agents };
        return (await this.request($)).response;
      }
      async interrupt() {
        await this.request({ subtype: "interrupt" });
      }
      async setPermissionMode(X) {
        await this.request({ subtype: "set_permission_mode", mode: X });
      }
      async setModel(X) {
        await this.request({ subtype: "set_model", model: X });
      }
      async setMaxThinkingTokens(X) {
        await this.request({ subtype: "set_max_thinking_tokens", max_thinking_tokens: X });
      }
      async rewindFiles(X, Q) {
        return (await this.request({ subtype: "rewind_files", user_message_id: X, dry_run: Q?.dryRun })).response;
      }
      async processPendingPermissionRequests(X) {
        for (let Q of X) if (Q.request.subtype === "can_use_tool") this.handleControlRequest(Q).catch(() => {
        });
      }
      request(X) {
        let Q = Math.random().toString(36).substring(2, 15), $ = { request_id: Q, type: "control_request", request: X };
        return new Promise((Y, W) => {
          this.pendingControlResponses.set(Q, (J) => {
            if (J.subtype === "success") Y(J);
            else if (W(Error(J.error)), J.pending_permission_requests) this.processPendingPermissionRequests(J.pending_permission_requests);
          }), Promise.resolve(this.transport.write(Z0($) + `
`));
        });
      }
      async supportedCommands() {
        return (await this.initialization).commands;
      }
      async supportedModels() {
        return (await this.initialization).models;
      }
      async reconnectMcpServer(X) {
        await this.request({ subtype: "mcp_reconnect", serverName: X });
      }
      async toggleMcpServer(X, Q) {
        await this.request({ subtype: "mcp_toggle", serverName: X, enabled: Q });
      }
      async mcpServerStatus() {
        return (await this.request({ subtype: "mcp_status" })).response.mcpServers;
      }
      async setMcpServers(X) {
        let Q = {}, $ = {};
        for (let [H, B] of Object.entries(X)) if (B.type === "sdk" && "instance" in B) Q[H] = B.instance;
        else $[H] = B;
        let Y = new Set(this.sdkMcpServerInstances.keys()), W = new Set(Object.keys(Q));
        for (let H of Y) if (!W.has(H)) await this.disconnectSdkMcpServer(H);
        for (let [H, B] of Object.entries(Q)) if (!Y.has(H)) this.connectSdkMcpServer(H, B);
        let J = {};
        for (let H of Object.keys(Q)) J[H] = { type: "sdk", name: H };
        return (await this.request({ subtype: "mcp_set_servers", servers: { ...$, ...J } })).response;
      }
      async accountInfo() {
        return (await this.initialization).account;
      }
      async streamInput(X) {
        v1("[Query.streamInput] Starting to process input stream");
        try {
          let Q = 0;
          for await (let $ of X) {
            if (Q++, v1(`[Query.streamInput] Processing message ${Q}: ${$.type}`), this.abortController?.signal.aborted) break;
            await Promise.resolve(this.transport.write(Z0($) + `
`));
          }
          if (v1(`[Query.streamInput] Finished processing ${Q} messages from input stream`), Q > 0 && this.hasBidirectionalNeeds()) v1("[Query.streamInput] Has bidirectional needs, waiting for first result"), await this.waitForFirstResult();
          v1("[Query] Calling transport.endInput() to close stdin to CLI process"), this.transport.endInput();
        } catch (Q) {
          if (!(Q instanceof F1)) throw Q;
        }
      }
      waitForFirstResult() {
        if (this.firstResultReceived) return v1("[Query.waitForFirstResult] Result already received, returning immediately"), Promise.resolve();
        return new Promise((X) => {
          if (this.abortController?.signal.aborted) {
            X();
            return;
          }
          this.abortController?.signal.addEventListener("abort", () => X(), { once: true }), this.firstResultReceivedResolve = X;
        });
      }
      handleHookCallbacks(X, Q, $, Y) {
        let W = this.hookCallbacks.get(X);
        if (!W) throw Error(`No hook callback found for ID: ${X}`);
        return W(Q, $, { signal: Y });
      }
      connectSdkMcpServer(X, Q) {
        let $ = new K9((Y) => this.sendMcpServerMessageToCli(X, Y));
        this.sdkMcpTransports.set(X, $), this.sdkMcpServerInstances.set(X, Q), Q.connect($);
      }
      async disconnectSdkMcpServer(X) {
        let Q = this.sdkMcpTransports.get(X);
        if (Q) await Q.close(), this.sdkMcpTransports.delete(X);
        this.sdkMcpServerInstances.delete(X);
      }
      sendMcpServerMessageToCli(X, Q) {
        if ("id" in Q && Q.id !== null && Q.id !== void 0) {
          let Y = `${X}:${Q.id}`, W = this.pendingMcpResponses.get(Y);
          if (W) {
            W.resolve(Q), this.pendingMcpResponses.delete(Y);
            return;
          }
        }
        let $ = { type: "control_request", request_id: (0, import_crypto3.randomUUID)(), request: { subtype: "mcp_message", server_name: X, message: Q } };
        this.transport.write(Z0($) + `
`);
      }
      handleMcpControlRequest(X, Q, $) {
        let Y = "id" in Q.message ? Q.message.id : null, W = `${X}:${Y}`;
        return new Promise((J, G) => {
          let H = () => {
            this.pendingMcpResponses.delete(W);
          }, B = (K) => {
            H(), J(K);
          }, z2 = (K) => {
            H(), G(K);
          };
          if (this.pendingMcpResponses.set(W, { resolve: B, reject: z2 }), $.onmessage) $.onmessage(Q.message);
          else {
            H(), G(Error("No message handler registered"));
            return;
          }
        });
      }
    };
    U9 = class {
      closed = false;
      inputStream;
      query;
      queryIterator = null;
      abortController;
      _sessionId = null;
      get sessionId() {
        if (this._sessionId === null) throw Error("Session ID not available until after receiving messages");
        return this._sessionId;
      }
      constructor(X) {
        if (X.resume) this._sessionId = X.resume;
        this.inputStream = new QX();
        let Q = X.pathToClaudeCodeExecutable;
        if (!Q) {
          let W = (0, import_url2.fileURLToPath)(import_meta.url), J = (0, import_path5.join)(W, "..");
          Q = (0, import_path5.join)(J, "cli.js");
        }
        let $ = { ...X.env ?? process.env };
        if (!$.CLAUDE_CODE_ENTRYPOINT) $.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
        this.abortController = N6();
        let Y = new XX({ abortController: this.abortController, pathToClaudeCodeExecutable: Q, env: $, executable: X.executable ?? (j6() ? "bun" : "node"), executableArgs: X.executableArgs ?? [], extraArgs: {}, maxThinkingTokens: void 0, maxTurns: void 0, maxBudgetUsd: void 0, model: X.model, fallbackModel: void 0, permissionMode: X.permissionMode ?? "default", allowDangerouslySkipPermissions: false, continueConversation: false, resume: X.resume, settingSources: [], allowedTools: X.allowedTools ?? [], disallowedTools: X.disallowedTools ?? [], mcpServers: {}, strictMcpConfig: false, canUseTool: !!X.canUseTool, hooks: !!X.hooks, includePartialMessages: false, forkSession: false, resumeSessionAt: void 0 });
        this.query = new $X(Y, false, X.canUseTool, X.hooks, this.abortController, /* @__PURE__ */ new Map()), this.query.streamInput(this.inputStream);
      }
      async send(X) {
        if (this.closed) throw Error("Cannot send to closed session");
        let Q = typeof X === "string" ? { type: "user", session_id: "", message: { role: "user", content: [{ type: "text", text: X }] }, parent_tool_use_id: null } : X;
        this.inputStream.enqueue(Q);
      }
      async *stream() {
        if (!this.queryIterator) this.queryIterator = this.query[Symbol.asyncIterator]();
        while (true) {
          let { value: X, done: Q } = await this.queryIterator.next();
          if (Q) return;
          if (X.type === "system" && X.subtype === "init") this._sessionId = X.session_id;
          if (yield X, X.type === "result") return;
        }
      }
      close() {
        if (this.closed) return;
        this.closed = true, this.inputStream.done(), this.abortController.abort();
      }
      async [Symbol.asyncDispose]() {
        this.close();
      }
    };
    (function(X) {
      X.assertEqual = (W) => {
      };
      function Q(W) {
      }
      X.assertIs = Q;
      function $(W) {
        throw Error();
      }
      X.assertNever = $, X.arrayToEnum = (W) => {
        let J = {};
        for (let G of W) J[G] = G;
        return J;
      }, X.getValidEnumValues = (W) => {
        let J = X.objectKeys(W).filter((H) => typeof W[W[H]] !== "number"), G = {};
        for (let H of J) G[H] = W[H];
        return X.objectValues(G);
      }, X.objectValues = (W) => {
        return X.objectKeys(W).map(function(J) {
          return W[J];
        });
      }, X.objectKeys = typeof Object.keys === "function" ? (W) => Object.keys(W) : (W) => {
        let J = [];
        for (let G in W) if (Object.prototype.hasOwnProperty.call(W, G)) J.push(G);
        return J;
      }, X.find = (W, J) => {
        for (let G of W) if (J(G)) return G;
        return;
      }, X.isInteger = typeof Number.isInteger === "function" ? (W) => Number.isInteger(W) : (W) => typeof W === "number" && Number.isFinite(W) && Math.floor(W) === W;
      function Y(W, J = " | ") {
        return W.map((G) => typeof G === "string" ? `'${G}'` : G).join(J);
      }
      X.joinValues = Y, X.jsonStringifyReplacer = (W, J) => {
        if (typeof J === "bigint") return J.toString();
        return J;
      };
    })(n || (n = {}));
    (function(X) {
      X.mergeShapes = (Q, $) => {
        return { ...Q, ...$ };
      };
    })(UW || (UW = {}));
    E = n.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
    O1 = (X) => {
      switch (typeof X) {
        case "undefined":
          return E.undefined;
        case "string":
          return E.string;
        case "number":
          return Number.isNaN(X) ? E.nan : E.number;
        case "boolean":
          return E.boolean;
        case "function":
          return E.function;
        case "bigint":
          return E.bigint;
        case "symbol":
          return E.symbol;
        case "object":
          if (Array.isArray(X)) return E.array;
          if (X === null) return E.null;
          if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return E.promise;
          if (typeof Map < "u" && X instanceof Map) return E.map;
          if (typeof Set < "u" && X instanceof Set) return E.set;
          if (typeof Date < "u" && X instanceof Date) return E.date;
          return E.object;
        default:
          return E.unknown;
      }
    };
    w = n.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
    h0 = class _h0 extends Error {
      get errors() {
        return this.issues;
      }
      constructor(X) {
        super();
        this.issues = [], this.addIssue = ($) => {
          this.issues = [...this.issues, $];
        }, this.addIssues = ($ = []) => {
          this.issues = [...this.issues, ...$];
        };
        let Q = new.target.prototype;
        if (Object.setPrototypeOf) Object.setPrototypeOf(this, Q);
        else this.__proto__ = Q;
        this.name = "ZodError", this.issues = X;
      }
      format(X) {
        let Q = X || function(W) {
          return W.message;
        }, $ = { _errors: [] }, Y = (W) => {
          for (let J of W.issues) if (J.code === "invalid_union") J.unionErrors.map(Y);
          else if (J.code === "invalid_return_type") Y(J.returnTypeError);
          else if (J.code === "invalid_arguments") Y(J.argumentsError);
          else if (J.path.length === 0) $._errors.push(Q(J));
          else {
            let G = $, H = 0;
            while (H < J.path.length) {
              let B = J.path[H];
              if (H !== J.path.length - 1) G[B] = G[B] || { _errors: [] };
              else G[B] = G[B] || { _errors: [] }, G[B]._errors.push(Q(J));
              G = G[B], H++;
            }
          }
        };
        return Y(this), $;
      }
      static assert(X) {
        if (!(X instanceof _h0)) throw Error(`Not a ZodError: ${X}`);
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, n.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(X = (Q) => Q.message) {
        let Q = {}, $ = [];
        for (let Y of this.issues) if (Y.path.length > 0) {
          let W = Y.path[0];
          Q[W] = Q[W] || [], Q[W].push(X(Y));
        } else $.push(X(Y));
        return { formErrors: $, fieldErrors: Q };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    h0.create = (X) => {
      return new h0(X);
    };
    $V = (X, Q) => {
      let $;
      switch (X.code) {
        case w.invalid_type:
          if (X.received === E.undefined) $ = "Required";
          else $ = `Expected ${X.expected}, received ${X.received}`;
          break;
        case w.invalid_literal:
          $ = `Invalid literal value, expected ${JSON.stringify(X.expected, n.jsonStringifyReplacer)}`;
          break;
        case w.unrecognized_keys:
          $ = `Unrecognized key(s) in object: ${n.joinValues(X.keys, ", ")}`;
          break;
        case w.invalid_union:
          $ = "Invalid input";
          break;
        case w.invalid_union_discriminator:
          $ = `Invalid discriminator value. Expected ${n.joinValues(X.options)}`;
          break;
        case w.invalid_enum_value:
          $ = `Invalid enum value. Expected ${n.joinValues(X.options)}, received '${X.received}'`;
          break;
        case w.invalid_arguments:
          $ = "Invalid function arguments";
          break;
        case w.invalid_return_type:
          $ = "Invalid function return type";
          break;
        case w.invalid_date:
          $ = "Invalid date";
          break;
        case w.invalid_string:
          if (typeof X.validation === "object") if ("includes" in X.validation) {
            if ($ = `Invalid input: must include "${X.validation.includes}"`, typeof X.validation.position === "number") $ = `${$} at one or more positions greater than or equal to ${X.validation.position}`;
          } else if ("startsWith" in X.validation) $ = `Invalid input: must start with "${X.validation.startsWith}"`;
          else if ("endsWith" in X.validation) $ = `Invalid input: must end with "${X.validation.endsWith}"`;
          else n.assertNever(X.validation);
          else if (X.validation !== "regex") $ = `Invalid ${X.validation}`;
          else $ = "Invalid";
          break;
        case w.too_small:
          if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
          else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
          else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
          else if (X.type === "bigint") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
          else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
          else $ = "Invalid input";
          break;
        case w.too_big:
          if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
          else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
          else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
          else if (X.type === "bigint") $ = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
          else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
          else $ = "Invalid input";
          break;
        case w.custom:
          $ = "Invalid input";
          break;
        case w.invalid_intersection_types:
          $ = "Intersection results could not be merged";
          break;
        case w.not_multiple_of:
          $ = `Number must be a multiple of ${X.multipleOf}`;
          break;
        case w.not_finite:
          $ = "Number must be finite";
          break;
        default:
          $ = Q.defaultError, n.assertNever(X);
      }
      return { message: $ };
    };
    T1 = $V;
    YV = T1;
    N4 = (X) => {
      let { data: Q, path: $, errorMaps: Y, issueData: W } = X, J = [...$, ...W.path || []], G = { ...W, path: J };
      if (W.message !== void 0) return { ...W, path: J, message: W.message };
      let H = "", B = Y.filter((z2) => !!z2).slice().reverse();
      for (let z2 of B) H = z2(G, { data: Q, defaultError: H }).message;
      return { ...W, path: J, message: H };
    };
    I0 = class _I0 {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid") this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted") this.value = "aborted";
      }
      static mergeArray(X, Q) {
        let $ = [];
        for (let Y of Q) {
          if (Y.status === "aborted") return g;
          if (Y.status === "dirty") X.dirty();
          $.push(Y.value);
        }
        return { status: X.value, value: $ };
      }
      static async mergeObjectAsync(X, Q) {
        let $ = [];
        for (let Y of Q) {
          let W = await Y.key, J = await Y.value;
          $.push({ key: W, value: J });
        }
        return _I0.mergeObjectSync(X, $);
      }
      static mergeObjectSync(X, Q) {
        let $ = {};
        for (let Y of Q) {
          let { key: W, value: J } = Y;
          if (W.status === "aborted") return g;
          if (J.status === "aborted") return g;
          if (W.status === "dirty") X.dirty();
          if (J.status === "dirty") X.dirty();
          if (W.value !== "__proto__" && (typeof J.value < "u" || Y.alwaysSet)) $[W.value] = J.value;
        }
        return { status: X.value, value: $ };
      }
    };
    g = Object.freeze({ status: "aborted" });
    R6 = (X) => ({ status: "dirty", value: X });
    C0 = (X) => ({ status: "valid", value: X });
    L9 = (X) => X.status === "aborted";
    q9 = (X) => X.status === "dirty";
    o1 = (X) => X.status === "valid";
    WX = (X) => typeof Promise < "u" && X instanceof Promise;
    (function(X) {
      X.errToObj = (Q) => typeof Q === "string" ? { message: Q } : Q || {}, X.toString = (Q) => typeof Q === "string" ? Q : Q?.message;
    })(Z || (Z = {}));
    r0 = class {
      constructor(X, Q, $, Y) {
        this._cachedPath = [], this.parent = X, this.data = Q, this._path = $, this._key = Y;
      }
      get path() {
        if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
        else this._cachedPath.push(...this._path, this._key);
        return this._cachedPath;
      }
    };
    VW = (X, Q) => {
      if (o1(Q)) return { success: true, data: Q.value };
      else {
        if (!X.common.issues.length) throw Error("Validation failed but no issues detected.");
        return { success: false, get error() {
          if (this._error) return this._error;
          let $ = new h0(X.common.issues);
          return this._error = $, this._error;
        } };
      }
    };
    p = class {
      get description() {
        return this._def.description;
      }
      _getType(X) {
        return O1(X.data);
      }
      _getOrReturnCtx(X, Q) {
        return Q || { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent };
      }
      _processInputParams(X) {
        return { status: new I0(), ctx: { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent } };
      }
      _parseSync(X) {
        let Q = this._parse(X);
        if (WX(Q)) throw Error("Synchronous parse encountered promise.");
        return Q;
      }
      _parseAsync(X) {
        let Q = this._parse(X);
        return Promise.resolve(Q);
      }
      parse(X, Q) {
        let $ = this.safeParse(X, Q);
        if ($.success) return $.data;
        throw $.error;
      }
      safeParse(X, Q) {
        let $ = { common: { issues: [], async: Q?.async ?? false, contextualErrorMap: Q?.errorMap }, path: Q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parseSync({ data: X, path: $.path, parent: $ });
        return VW($, Y);
      }
      "~validate"(X) {
        let Q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) };
        if (!this["~standard"].async) try {
          let $ = this._parseSync({ data: X, path: [], parent: Q });
          return o1($) ? { value: $.value } : { issues: Q.common.issues };
        } catch ($) {
          if ($?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
          Q.common = { issues: [], async: true };
        }
        return this._parseAsync({ data: X, path: [], parent: Q }).then(($) => o1($) ? { value: $.value } : { issues: Q.common.issues });
      }
      async parseAsync(X, Q) {
        let $ = await this.safeParseAsync(X, Q);
        if ($.success) return $.data;
        throw $.error;
      }
      async safeParseAsync(X, Q) {
        let $ = { common: { issues: [], contextualErrorMap: Q?.errorMap, async: true }, path: Q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parse({ data: X, path: $.path, parent: $ }), W = await (WX(Y) ? Y : Promise.resolve(Y));
        return VW($, W);
      }
      refine(X, Q) {
        let $ = (Y) => {
          if (typeof Q === "string" || typeof Q > "u") return { message: Q };
          else if (typeof Q === "function") return Q(Y);
          else return Q;
        };
        return this._refinement((Y, W) => {
          let J = X(Y), G = () => W.addIssue({ code: w.custom, ...$(Y) });
          if (typeof Promise < "u" && J instanceof Promise) return J.then((H) => {
            if (!H) return G(), false;
            else return true;
          });
          if (!J) return G(), false;
          else return true;
        });
      }
      refinement(X, Q) {
        return this._refinement(($, Y) => {
          if (!X($)) return Y.addIssue(typeof Q === "function" ? Q($, Y) : Q), false;
          else return true;
        });
      }
      _refinement(X) {
        return new H1({ schema: this, typeName: j.ZodEffects, effect: { type: "refinement", refinement: X } });
      }
      superRefine(X) {
        return this._refinement(X);
      }
      constructor(X) {
        this.spa = this.safeParseAsync, this._def = X, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (Q) => this["~validate"](Q) };
      }
      optional() {
        return G1.create(this, this._def);
      }
      nullable() {
        return _1.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return J1.create(this);
      }
      promise() {
        return S6.create(this, this._def);
      }
      or(X) {
        return zX.create([this, X], this._def);
      }
      and(X) {
        return KX.create(this, X, this._def);
      }
      transform(X) {
        return new H1({ ...l(this._def), schema: this, typeName: j.ZodEffects, effect: { type: "transform", transform: X } });
      }
      default(X) {
        let Q = typeof X === "function" ? X : () => X;
        return new qX({ ...l(this._def), innerType: this, defaultValue: Q, typeName: j.ZodDefault });
      }
      brand() {
        return new D9({ typeName: j.ZodBranded, type: this, ...l(this._def) });
      }
      catch(X) {
        let Q = typeof X === "function" ? X : () => X;
        return new FX({ ...l(this._def), innerType: this, catchValue: Q, typeName: j.ZodCatch });
      }
      describe(X) {
        return new this.constructor({ ...this._def, description: X });
      }
      pipe(X) {
        return E4.create(this, X);
      }
      readonly() {
        return NX.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    WV = /^c[^\s-]{8,}$/i;
    JV = /^[0-9a-z]+$/;
    GV = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    HV = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    BV = /^[a-z0-9_-]{21}$/i;
    zV = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    KV = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    UV = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    VV = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    LV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    qV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    FV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    NV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    OV = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    DV = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    LW = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
    AV = new RegExp(`^${LW}$`);
    A1 = class _A1 extends p {
      _parse(X) {
        if (this._def.coerce) X.data = String(X.data);
        if (this._getType(X) !== E.string) {
          let W = this._getOrReturnCtx(X);
          return b(W, { code: w.invalid_type, expected: E.string, received: W.parsedType }), g;
        }
        let $ = new I0(), Y = void 0;
        for (let W of this._def.checks) if (W.kind === "min") {
          if (X.data.length < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
        } else if (W.kind === "max") {
          if (X.data.length > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
        } else if (W.kind === "length") {
          let J = X.data.length > W.value, G = X.data.length < W.value;
          if (J || G) {
            if (Y = this._getOrReturnCtx(X, Y), J) b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
            else if (G) b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
            $.dirty();
          }
        } else if (W.kind === "email") {
          if (!UV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "email", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "emoji") {
          if (!F9) F9 = new RegExp(VV, "u");
          if (!F9.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "emoji", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "uuid") {
          if (!HV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "uuid", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "nanoid") {
          if (!BV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "nanoid", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "cuid") {
          if (!WV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "cuid2") {
          if (!JV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid2", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "ulid") {
          if (!GV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ulid", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "url") try {
          new URL(X.data);
        } catch {
          Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "url", code: w.invalid_string, message: W.message }), $.dirty();
        }
        else if (W.kind === "regex") {
          if (W.regex.lastIndex = 0, !W.regex.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "regex", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "trim") X.data = X.data.trim();
        else if (W.kind === "includes") {
          if (!X.data.includes(W.value, W.position)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { includes: W.value, position: W.position }, message: W.message }), $.dirty();
        } else if (W.kind === "toLowerCase") X.data = X.data.toLowerCase();
        else if (W.kind === "toUpperCase") X.data = X.data.toUpperCase();
        else if (W.kind === "startsWith") {
          if (!X.data.startsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { startsWith: W.value }, message: W.message }), $.dirty();
        } else if (W.kind === "endsWith") {
          if (!X.data.endsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { endsWith: W.value }, message: W.message }), $.dirty();
        } else if (W.kind === "datetime") {
          if (!MV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "datetime", message: W.message }), $.dirty();
        } else if (W.kind === "date") {
          if (!AV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "date", message: W.message }), $.dirty();
        } else if (W.kind === "time") {
          if (!wV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "time", message: W.message }), $.dirty();
        } else if (W.kind === "duration") {
          if (!KV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "duration", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "ip") {
          if (!jV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ip", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "jwt") {
          if (!RV(X.data, W.alg)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "jwt", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "cidr") {
          if (!EV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cidr", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "base64") {
          if (!OV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64", code: w.invalid_string, message: W.message }), $.dirty();
        } else if (W.kind === "base64url") {
          if (!DV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64url", code: w.invalid_string, message: W.message }), $.dirty();
        } else n.assertNever(W);
        return { status: $.value, value: X.data };
      }
      _regex(X, Q, $) {
        return this.refinement((Y) => X.test(Y), { validation: Q, code: w.invalid_string, ...Z.errToObj($) });
      }
      _addCheck(X) {
        return new _A1({ ...this._def, checks: [...this._def.checks, X] });
      }
      email(X) {
        return this._addCheck({ kind: "email", ...Z.errToObj(X) });
      }
      url(X) {
        return this._addCheck({ kind: "url", ...Z.errToObj(X) });
      }
      emoji(X) {
        return this._addCheck({ kind: "emoji", ...Z.errToObj(X) });
      }
      uuid(X) {
        return this._addCheck({ kind: "uuid", ...Z.errToObj(X) });
      }
      nanoid(X) {
        return this._addCheck({ kind: "nanoid", ...Z.errToObj(X) });
      }
      cuid(X) {
        return this._addCheck({ kind: "cuid", ...Z.errToObj(X) });
      }
      cuid2(X) {
        return this._addCheck({ kind: "cuid2", ...Z.errToObj(X) });
      }
      ulid(X) {
        return this._addCheck({ kind: "ulid", ...Z.errToObj(X) });
      }
      base64(X) {
        return this._addCheck({ kind: "base64", ...Z.errToObj(X) });
      }
      base64url(X) {
        return this._addCheck({ kind: "base64url", ...Z.errToObj(X) });
      }
      jwt(X) {
        return this._addCheck({ kind: "jwt", ...Z.errToObj(X) });
      }
      ip(X) {
        return this._addCheck({ kind: "ip", ...Z.errToObj(X) });
      }
      cidr(X) {
        return this._addCheck({ kind: "cidr", ...Z.errToObj(X) });
      }
      datetime(X) {
        if (typeof X === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: X });
        return this._addCheck({ kind: "datetime", precision: typeof X?.precision > "u" ? null : X?.precision, offset: X?.offset ?? false, local: X?.local ?? false, ...Z.errToObj(X?.message) });
      }
      date(X) {
        return this._addCheck({ kind: "date", message: X });
      }
      time(X) {
        if (typeof X === "string") return this._addCheck({ kind: "time", precision: null, message: X });
        return this._addCheck({ kind: "time", precision: typeof X?.precision > "u" ? null : X?.precision, ...Z.errToObj(X?.message) });
      }
      duration(X) {
        return this._addCheck({ kind: "duration", ...Z.errToObj(X) });
      }
      regex(X, Q) {
        return this._addCheck({ kind: "regex", regex: X, ...Z.errToObj(Q) });
      }
      includes(X, Q) {
        return this._addCheck({ kind: "includes", value: X, position: Q?.position, ...Z.errToObj(Q?.message) });
      }
      startsWith(X, Q) {
        return this._addCheck({ kind: "startsWith", value: X, ...Z.errToObj(Q) });
      }
      endsWith(X, Q) {
        return this._addCheck({ kind: "endsWith", value: X, ...Z.errToObj(Q) });
      }
      min(X, Q) {
        return this._addCheck({ kind: "min", value: X, ...Z.errToObj(Q) });
      }
      max(X, Q) {
        return this._addCheck({ kind: "max", value: X, ...Z.errToObj(Q) });
      }
      length(X, Q) {
        return this._addCheck({ kind: "length", value: X, ...Z.errToObj(Q) });
      }
      nonempty(X) {
        return this.min(1, Z.errToObj(X));
      }
      trim() {
        return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
      }
      toLowerCase() {
        return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
      }
      toUpperCase() {
        return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
      }
      get isDatetime() {
        return !!this._def.checks.find((X) => X.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((X) => X.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((X) => X.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((X) => X.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((X) => X.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((X) => X.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((X) => X.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((X) => X.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((X) => X.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((X) => X.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((X) => X.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((X) => X.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((X) => X.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((X) => X.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((X) => X.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((X) => X.kind === "base64url");
      }
      get minLength() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "min") {
          if (X === null || Q.value > X) X = Q.value;
        }
        return X;
      }
      get maxLength() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "max") {
          if (X === null || Q.value < X) X = Q.value;
        }
        return X;
      }
    };
    A1.create = (X) => {
      return new A1({ checks: [], typeName: j.ZodString, coerce: X?.coerce ?? false, ...l(X) });
    };
    I6 = class _I6 extends p {
      constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
      }
      _parse(X) {
        if (this._def.coerce) X.data = Number(X.data);
        if (this._getType(X) !== E.number) {
          let W = this._getOrReturnCtx(X);
          return b(W, { code: w.invalid_type, expected: E.number, received: W.parsedType }), g;
        }
        let $ = void 0, Y = new I0();
        for (let W of this._def.checks) if (W.kind === "int") {
          if (!n.isInteger(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.invalid_type, expected: "integer", received: "float", message: W.message }), Y.dirty();
        } else if (W.kind === "min") {
          if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, minimum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
        } else if (W.kind === "max") {
          if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, maximum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
        } else if (W.kind === "multipleOf") {
          if (IV(X.data, W.value) !== 0) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
        } else if (W.kind === "finite") {
          if (!Number.isFinite(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_finite, message: W.message }), Y.dirty();
        } else n.assertNever(W);
        return { status: Y.value, value: X.data };
      }
      gte(X, Q) {
        return this.setLimit("min", X, true, Z.toString(Q));
      }
      gt(X, Q) {
        return this.setLimit("min", X, false, Z.toString(Q));
      }
      lte(X, Q) {
        return this.setLimit("max", X, true, Z.toString(Q));
      }
      lt(X, Q) {
        return this.setLimit("max", X, false, Z.toString(Q));
      }
      setLimit(X, Q, $, Y) {
        return new _I6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
      }
      _addCheck(X) {
        return new _I6({ ...this._def, checks: [...this._def.checks, X] });
      }
      int(X) {
        return this._addCheck({ kind: "int", message: Z.toString(X) });
      }
      positive(X) {
        return this._addCheck({ kind: "min", value: 0, inclusive: false, message: Z.toString(X) });
      }
      negative(X) {
        return this._addCheck({ kind: "max", value: 0, inclusive: false, message: Z.toString(X) });
      }
      nonpositive(X) {
        return this._addCheck({ kind: "max", value: 0, inclusive: true, message: Z.toString(X) });
      }
      nonnegative(X) {
        return this._addCheck({ kind: "min", value: 0, inclusive: true, message: Z.toString(X) });
      }
      multipleOf(X, Q) {
        return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
      }
      finite(X) {
        return this._addCheck({ kind: "finite", message: Z.toString(X) });
      }
      safe(X) {
        return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: Z.toString(X) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: Z.toString(X) });
      }
      get minValue() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "min") {
          if (X === null || Q.value > X) X = Q.value;
        }
        return X;
      }
      get maxValue() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "max") {
          if (X === null || Q.value < X) X = Q.value;
        }
        return X;
      }
      get isInt() {
        return !!this._def.checks.find((X) => X.kind === "int" || X.kind === "multipleOf" && n.isInteger(X.value));
      }
      get isFinite() {
        let X = null, Q = null;
        for (let $ of this._def.checks) if ($.kind === "finite" || $.kind === "int" || $.kind === "multipleOf") return true;
        else if ($.kind === "min") {
          if (Q === null || $.value > Q) Q = $.value;
        } else if ($.kind === "max") {
          if (X === null || $.value < X) X = $.value;
        }
        return Number.isFinite(Q) && Number.isFinite(X);
      }
    };
    I6.create = (X) => {
      return new I6({ checks: [], typeName: j.ZodNumber, coerce: X?.coerce || false, ...l(X) });
    };
    b6 = class _b6 extends p {
      constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte;
      }
      _parse(X) {
        if (this._def.coerce) try {
          X.data = BigInt(X.data);
        } catch {
          return this._getInvalidInput(X);
        }
        if (this._getType(X) !== E.bigint) return this._getInvalidInput(X);
        let $ = void 0, Y = new I0();
        for (let W of this._def.checks) if (W.kind === "min") {
          if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, type: "bigint", minimum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
        } else if (W.kind === "max") {
          if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, type: "bigint", maximum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
        } else if (W.kind === "multipleOf") {
          if (X.data % W.value !== BigInt(0)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
        } else n.assertNever(W);
        return { status: Y.value, value: X.data };
      }
      _getInvalidInput(X) {
        let Q = this._getOrReturnCtx(X);
        return b(Q, { code: w.invalid_type, expected: E.bigint, received: Q.parsedType }), g;
      }
      gte(X, Q) {
        return this.setLimit("min", X, true, Z.toString(Q));
      }
      gt(X, Q) {
        return this.setLimit("min", X, false, Z.toString(Q));
      }
      lte(X, Q) {
        return this.setLimit("max", X, true, Z.toString(Q));
      }
      lt(X, Q) {
        return this.setLimit("max", X, false, Z.toString(Q));
      }
      setLimit(X, Q, $, Y) {
        return new _b6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
      }
      _addCheck(X) {
        return new _b6({ ...this._def, checks: [...this._def.checks, X] });
      }
      positive(X) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: Z.toString(X) });
      }
      negative(X) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: Z.toString(X) });
      }
      nonpositive(X) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: Z.toString(X) });
      }
      nonnegative(X) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: Z.toString(X) });
      }
      multipleOf(X, Q) {
        return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
      }
      get minValue() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "min") {
          if (X === null || Q.value > X) X = Q.value;
        }
        return X;
      }
      get maxValue() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "max") {
          if (X === null || Q.value < X) X = Q.value;
        }
        return X;
      }
    };
    b6.create = (X) => {
      return new b6({ checks: [], typeName: j.ZodBigInt, coerce: X?.coerce ?? false, ...l(X) });
    };
    O4 = class extends p {
      _parse(X) {
        if (this._def.coerce) X.data = Boolean(X.data);
        if (this._getType(X) !== E.boolean) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.boolean, received: $.parsedType }), g;
        }
        return C0(X.data);
      }
    };
    O4.create = (X) => {
      return new O4({ typeName: j.ZodBoolean, coerce: X?.coerce || false, ...l(X) });
    };
    GX = class _GX extends p {
      _parse(X) {
        if (this._def.coerce) X.data = new Date(X.data);
        if (this._getType(X) !== E.date) {
          let W = this._getOrReturnCtx(X);
          return b(W, { code: w.invalid_type, expected: E.date, received: W.parsedType }), g;
        }
        if (Number.isNaN(X.data.getTime())) {
          let W = this._getOrReturnCtx(X);
          return b(W, { code: w.invalid_date }), g;
        }
        let $ = new I0(), Y = void 0;
        for (let W of this._def.checks) if (W.kind === "min") {
          if (X.data.getTime() < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, message: W.message, inclusive: true, exact: false, minimum: W.value, type: "date" }), $.dirty();
        } else if (W.kind === "max") {
          if (X.data.getTime() > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, message: W.message, inclusive: true, exact: false, maximum: W.value, type: "date" }), $.dirty();
        } else n.assertNever(W);
        return { status: $.value, value: new Date(X.data.getTime()) };
      }
      _addCheck(X) {
        return new _GX({ ...this._def, checks: [...this._def.checks, X] });
      }
      min(X, Q) {
        return this._addCheck({ kind: "min", value: X.getTime(), message: Z.toString(Q) });
      }
      max(X, Q) {
        return this._addCheck({ kind: "max", value: X.getTime(), message: Z.toString(Q) });
      }
      get minDate() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "min") {
          if (X === null || Q.value > X) X = Q.value;
        }
        return X != null ? new Date(X) : null;
      }
      get maxDate() {
        let X = null;
        for (let Q of this._def.checks) if (Q.kind === "max") {
          if (X === null || Q.value < X) X = Q.value;
        }
        return X != null ? new Date(X) : null;
      }
    };
    GX.create = (X) => {
      return new GX({ checks: [], coerce: X?.coerce || false, typeName: j.ZodDate, ...l(X) });
    };
    D4 = class extends p {
      _parse(X) {
        if (this._getType(X) !== E.symbol) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.symbol, received: $.parsedType }), g;
        }
        return C0(X.data);
      }
    };
    D4.create = (X) => {
      return new D4({ typeName: j.ZodSymbol, ...l(X) });
    };
    HX = class extends p {
      _parse(X) {
        if (this._getType(X) !== E.undefined) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.undefined, received: $.parsedType }), g;
        }
        return C0(X.data);
      }
    };
    HX.create = (X) => {
      return new HX({ typeName: j.ZodUndefined, ...l(X) });
    };
    BX = class extends p {
      _parse(X) {
        if (this._getType(X) !== E.null) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.null, received: $.parsedType }), g;
        }
        return C0(X.data);
      }
    };
    BX.create = (X) => {
      return new BX({ typeName: j.ZodNull, ...l(X) });
    };
    A4 = class extends p {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(X) {
        return C0(X.data);
      }
    };
    A4.create = (X) => {
      return new A4({ typeName: j.ZodAny, ...l(X) });
    };
    t1 = class extends p {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(X) {
        return C0(X.data);
      }
    };
    t1.create = (X) => {
      return new t1({ typeName: j.ZodUnknown, ...l(X) });
    };
    w1 = class extends p {
      _parse(X) {
        let Q = this._getOrReturnCtx(X);
        return b(Q, { code: w.invalid_type, expected: E.never, received: Q.parsedType }), g;
      }
    };
    w1.create = (X) => {
      return new w1({ typeName: j.ZodNever, ...l(X) });
    };
    w4 = class extends p {
      _parse(X) {
        if (this._getType(X) !== E.undefined) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.void, received: $.parsedType }), g;
        }
        return C0(X.data);
      }
    };
    w4.create = (X) => {
      return new w4({ typeName: j.ZodVoid, ...l(X) });
    };
    J1 = class _J1 extends p {
      _parse(X) {
        let { ctx: Q, status: $ } = this._processInputParams(X), Y = this._def;
        if (Q.parsedType !== E.array) return b(Q, { code: w.invalid_type, expected: E.array, received: Q.parsedType }), g;
        if (Y.exactLength !== null) {
          let J = Q.data.length > Y.exactLength.value, G = Q.data.length < Y.exactLength.value;
          if (J || G) b(Q, { code: J ? w.too_big : w.too_small, minimum: G ? Y.exactLength.value : void 0, maximum: J ? Y.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: Y.exactLength.message }), $.dirty();
        }
        if (Y.minLength !== null) {
          if (Q.data.length < Y.minLength.value) b(Q, { code: w.too_small, minimum: Y.minLength.value, type: "array", inclusive: true, exact: false, message: Y.minLength.message }), $.dirty();
        }
        if (Y.maxLength !== null) {
          if (Q.data.length > Y.maxLength.value) b(Q, { code: w.too_big, maximum: Y.maxLength.value, type: "array", inclusive: true, exact: false, message: Y.maxLength.message }), $.dirty();
        }
        if (Q.common.async) return Promise.all([...Q.data].map((J, G) => {
          return Y.type._parseAsync(new r0(Q, J, Q.path, G));
        })).then((J) => {
          return I0.mergeArray($, J);
        });
        let W = [...Q.data].map((J, G) => {
          return Y.type._parseSync(new r0(Q, J, Q.path, G));
        });
        return I0.mergeArray($, W);
      }
      get element() {
        return this._def.type;
      }
      min(X, Q) {
        return new _J1({ ...this._def, minLength: { value: X, message: Z.toString(Q) } });
      }
      max(X, Q) {
        return new _J1({ ...this._def, maxLength: { value: X, message: Z.toString(Q) } });
      }
      length(X, Q) {
        return new _J1({ ...this._def, exactLength: { value: X, message: Z.toString(Q) } });
      }
      nonempty(X) {
        return this.min(1, X);
      }
    };
    J1.create = (X, Q) => {
      return new J1({ type: X, minLength: null, maxLength: null, exactLength: null, typeName: j.ZodArray, ...l(Q) });
    };
    V0 = class _V0 extends p {
      constructor() {
        super(...arguments);
        this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null) return this._cached;
        let X = this._def.shape(), Q = n.objectKeys(X);
        return this._cached = { shape: X, keys: Q }, this._cached;
      }
      _parse(X) {
        if (this._getType(X) !== E.object) {
          let B = this._getOrReturnCtx(X);
          return b(B, { code: w.invalid_type, expected: E.object, received: B.parsedType }), g;
        }
        let { status: $, ctx: Y } = this._processInputParams(X), { shape: W, keys: J } = this._getCached(), G = [];
        if (!(this._def.catchall instanceof w1 && this._def.unknownKeys === "strip")) {
          for (let B in Y.data) if (!J.includes(B)) G.push(B);
        }
        let H = [];
        for (let B of J) {
          let z2 = W[B], K = Y.data[B];
          H.push({ key: { status: "valid", value: B }, value: z2._parse(new r0(Y, K, Y.path, B)), alwaysSet: B in Y.data });
        }
        if (this._def.catchall instanceof w1) {
          let B = this._def.unknownKeys;
          if (B === "passthrough") for (let z2 of G) H.push({ key: { status: "valid", value: z2 }, value: { status: "valid", value: Y.data[z2] } });
          else if (B === "strict") {
            if (G.length > 0) b(Y, { code: w.unrecognized_keys, keys: G }), $.dirty();
          } else if (B === "strip") ;
          else throw Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
          let B = this._def.catchall;
          for (let z2 of G) {
            let K = Y.data[z2];
            H.push({ key: { status: "valid", value: z2 }, value: B._parse(new r0(Y, K, Y.path, z2)), alwaysSet: z2 in Y.data });
          }
        }
        if (Y.common.async) return Promise.resolve().then(async () => {
          let B = [];
          for (let z2 of H) {
            let K = await z2.key, V = await z2.value;
            B.push({ key: K, value: V, alwaysSet: z2.alwaysSet });
          }
          return B;
        }).then((B) => {
          return I0.mergeObjectSync($, B);
        });
        else return I0.mergeObjectSync($, H);
      }
      get shape() {
        return this._def.shape();
      }
      strict(X) {
        return Z.errToObj, new _V0({ ...this._def, unknownKeys: "strict", ...X !== void 0 ? { errorMap: (Q, $) => {
          let Y = this._def.errorMap?.(Q, $).message ?? $.defaultError;
          if (Q.code === "unrecognized_keys") return { message: Z.errToObj(X).message ?? Y };
          return { message: Y };
        } } : {} });
      }
      strip() {
        return new _V0({ ...this._def, unknownKeys: "strip" });
      }
      passthrough() {
        return new _V0({ ...this._def, unknownKeys: "passthrough" });
      }
      extend(X) {
        return new _V0({ ...this._def, shape: () => ({ ...this._def.shape(), ...X }) });
      }
      merge(X) {
        return new _V0({ unknownKeys: X._def.unknownKeys, catchall: X._def.catchall, shape: () => ({ ...this._def.shape(), ...X._def.shape() }), typeName: j.ZodObject });
      }
      setKey(X, Q) {
        return this.augment({ [X]: Q });
      }
      catchall(X) {
        return new _V0({ ...this._def, catchall: X });
      }
      pick(X) {
        let Q = {};
        for (let $ of n.objectKeys(X)) if (X[$] && this.shape[$]) Q[$] = this.shape[$];
        return new _V0({ ...this._def, shape: () => Q });
      }
      omit(X) {
        let Q = {};
        for (let $ of n.objectKeys(this.shape)) if (!X[$]) Q[$] = this.shape[$];
        return new _V0({ ...this._def, shape: () => Q });
      }
      deepPartial() {
        return E6(this);
      }
      partial(X) {
        let Q = {};
        for (let $ of n.objectKeys(this.shape)) {
          let Y = this.shape[$];
          if (X && !X[$]) Q[$] = Y;
          else Q[$] = Y.optional();
        }
        return new _V0({ ...this._def, shape: () => Q });
      }
      required(X) {
        let Q = {};
        for (let $ of n.objectKeys(this.shape)) if (X && !X[$]) Q[$] = this.shape[$];
        else {
          let W = this.shape[$];
          while (W instanceof G1) W = W._def.innerType;
          Q[$] = W;
        }
        return new _V0({ ...this._def, shape: () => Q });
      }
      keyof() {
        return FW(n.objectKeys(this.shape));
      }
    };
    V0.create = (X, Q) => {
      return new V0({ shape: () => X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
    };
    V0.strictCreate = (X, Q) => {
      return new V0({ shape: () => X, unknownKeys: "strict", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
    };
    V0.lazycreate = (X, Q) => {
      return new V0({ shape: X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
    };
    zX = class extends p {
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X), $ = this._def.options;
        function Y(W) {
          for (let G of W) if (G.result.status === "valid") return G.result;
          for (let G of W) if (G.result.status === "dirty") return Q.common.issues.push(...G.ctx.common.issues), G.result;
          let J = W.map((G) => new h0(G.ctx.common.issues));
          return b(Q, { code: w.invalid_union, unionErrors: J }), g;
        }
        if (Q.common.async) return Promise.all($.map(async (W) => {
          let J = { ...Q, common: { ...Q.common, issues: [] }, parent: null };
          return { result: await W._parseAsync({ data: Q.data, path: Q.path, parent: J }), ctx: J };
        })).then(Y);
        else {
          let W = void 0, J = [];
          for (let H of $) {
            let B = { ...Q, common: { ...Q.common, issues: [] }, parent: null }, z2 = H._parseSync({ data: Q.data, path: Q.path, parent: B });
            if (z2.status === "valid") return z2;
            else if (z2.status === "dirty" && !W) W = { result: z2, ctx: B };
            if (B.common.issues.length) J.push(B.common.issues);
          }
          if (W) return Q.common.issues.push(...W.ctx.common.issues), W.result;
          let G = J.map((H) => new h0(H));
          return b(Q, { code: w.invalid_union, unionErrors: G }), g;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    zX.create = (X, Q) => {
      return new zX({ options: X, typeName: j.ZodUnion, ...l(Q) });
    };
    D1 = (X) => {
      if (X instanceof UX) return D1(X.schema);
      else if (X instanceof H1) return D1(X.innerType());
      else if (X instanceof VX) return [X.value];
      else if (X instanceof a1) return X.options;
      else if (X instanceof LX) return n.objectValues(X.enum);
      else if (X instanceof qX) return D1(X._def.innerType);
      else if (X instanceof HX) return [void 0];
      else if (X instanceof BX) return [null];
      else if (X instanceof G1) return [void 0, ...D1(X.unwrap())];
      else if (X instanceof _1) return [null, ...D1(X.unwrap())];
      else if (X instanceof D9) return D1(X.unwrap());
      else if (X instanceof NX) return D1(X.unwrap());
      else if (X instanceof FX) return D1(X._def.innerType);
      else return [];
    };
    O9 = class _O9 extends p {
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X);
        if (Q.parsedType !== E.object) return b(Q, { code: w.invalid_type, expected: E.object, received: Q.parsedType }), g;
        let $ = this.discriminator, Y = Q.data[$], W = this.optionsMap.get(Y);
        if (!W) return b(Q, { code: w.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [$] }), g;
        if (Q.common.async) return W._parseAsync({ data: Q.data, path: Q.path, parent: Q });
        else return W._parseSync({ data: Q.data, path: Q.path, parent: Q });
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(X, Q, $) {
        let Y = /* @__PURE__ */ new Map();
        for (let W of Q) {
          let J = D1(W.shape[X]);
          if (!J.length) throw Error(`A discriminator value for key \`${X}\` could not be extracted from all schema options`);
          for (let G of J) {
            if (Y.has(G)) throw Error(`Discriminator property ${String(X)} has duplicate value ${String(G)}`);
            Y.set(G, W);
          }
        }
        return new _O9({ typeName: j.ZodDiscriminatedUnion, discriminator: X, options: Q, optionsMap: Y, ...l($) });
      }
    };
    KX = class extends p {
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X), Y = (W, J) => {
          if (L9(W) || L9(J)) return g;
          let G = N9(W.value, J.value);
          if (!G.valid) return b($, { code: w.invalid_intersection_types }), g;
          if (q9(W) || q9(J)) Q.dirty();
          return { status: Q.value, value: G.data };
        };
        if ($.common.async) return Promise.all([this._def.left._parseAsync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseAsync({ data: $.data, path: $.path, parent: $ })]).then(([W, J]) => Y(W, J));
        else return Y(this._def.left._parseSync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseSync({ data: $.data, path: $.path, parent: $ }));
      }
    };
    KX.create = (X, Q, $) => {
      return new KX({ left: X, right: Q, typeName: j.ZodIntersection, ...l($) });
    };
    M1 = class _M1 extends p {
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X);
        if ($.parsedType !== E.array) return b($, { code: w.invalid_type, expected: E.array, received: $.parsedType }), g;
        if ($.data.length < this._def.items.length) return b($, { code: w.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), g;
        if (!this._def.rest && $.data.length > this._def.items.length) b($, { code: w.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), Q.dirty();
        let W = [...$.data].map((J, G) => {
          let H = this._def.items[G] || this._def.rest;
          if (!H) return null;
          return H._parse(new r0($, J, $.path, G));
        }).filter((J) => !!J);
        if ($.common.async) return Promise.all(W).then((J) => {
          return I0.mergeArray(Q, J);
        });
        else return I0.mergeArray(Q, W);
      }
      get items() {
        return this._def.items;
      }
      rest(X) {
        return new _M1({ ...this._def, rest: X });
      }
    };
    M1.create = (X, Q) => {
      if (!Array.isArray(X)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new M1({ items: X, typeName: j.ZodTuple, rest: null, ...l(Q) });
    };
    M4 = class _M4 extends p {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X);
        if ($.parsedType !== E.object) return b($, { code: w.invalid_type, expected: E.object, received: $.parsedType }), g;
        let Y = [], W = this._def.keyType, J = this._def.valueType;
        for (let G in $.data) Y.push({ key: W._parse(new r0($, G, $.path, G)), value: J._parse(new r0($, $.data[G], $.path, G)), alwaysSet: G in $.data });
        if ($.common.async) return I0.mergeObjectAsync(Q, Y);
        else return I0.mergeObjectSync(Q, Y);
      }
      get element() {
        return this._def.valueType;
      }
      static create(X, Q, $) {
        if (Q instanceof p) return new _M4({ keyType: X, valueType: Q, typeName: j.ZodRecord, ...l($) });
        return new _M4({ keyType: A1.create(), valueType: X, typeName: j.ZodRecord, ...l(Q) });
      }
    };
    j4 = class extends p {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X);
        if ($.parsedType !== E.map) return b($, { code: w.invalid_type, expected: E.map, received: $.parsedType }), g;
        let Y = this._def.keyType, W = this._def.valueType, J = [...$.data.entries()].map(([G, H], B) => {
          return { key: Y._parse(new r0($, G, $.path, [B, "key"])), value: W._parse(new r0($, H, $.path, [B, "value"])) };
        });
        if ($.common.async) {
          let G = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (let H of J) {
              let B = await H.key, z2 = await H.value;
              if (B.status === "aborted" || z2.status === "aborted") return g;
              if (B.status === "dirty" || z2.status === "dirty") Q.dirty();
              G.set(B.value, z2.value);
            }
            return { status: Q.value, value: G };
          });
        } else {
          let G = /* @__PURE__ */ new Map();
          for (let H of J) {
            let { key: B, value: z2 } = H;
            if (B.status === "aborted" || z2.status === "aborted") return g;
            if (B.status === "dirty" || z2.status === "dirty") Q.dirty();
            G.set(B.value, z2.value);
          }
          return { status: Q.value, value: G };
        }
      }
    };
    j4.create = (X, Q, $) => {
      return new j4({ valueType: Q, keyType: X, typeName: j.ZodMap, ...l($) });
    };
    P6 = class _P6 extends p {
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X);
        if ($.parsedType !== E.set) return b($, { code: w.invalid_type, expected: E.set, received: $.parsedType }), g;
        let Y = this._def;
        if (Y.minSize !== null) {
          if ($.data.size < Y.minSize.value) b($, { code: w.too_small, minimum: Y.minSize.value, type: "set", inclusive: true, exact: false, message: Y.minSize.message }), Q.dirty();
        }
        if (Y.maxSize !== null) {
          if ($.data.size > Y.maxSize.value) b($, { code: w.too_big, maximum: Y.maxSize.value, type: "set", inclusive: true, exact: false, message: Y.maxSize.message }), Q.dirty();
        }
        let W = this._def.valueType;
        function J(H) {
          let B = /* @__PURE__ */ new Set();
          for (let z2 of H) {
            if (z2.status === "aborted") return g;
            if (z2.status === "dirty") Q.dirty();
            B.add(z2.value);
          }
          return { status: Q.value, value: B };
        }
        let G = [...$.data.values()].map((H, B) => W._parse(new r0($, H, $.path, B)));
        if ($.common.async) return Promise.all(G).then((H) => J(H));
        else return J(G);
      }
      min(X, Q) {
        return new _P6({ ...this._def, minSize: { value: X, message: Z.toString(Q) } });
      }
      max(X, Q) {
        return new _P6({ ...this._def, maxSize: { value: X, message: Z.toString(Q) } });
      }
      size(X, Q) {
        return this.min(X, Q).max(X, Q);
      }
      nonempty(X) {
        return this.min(1, X);
      }
    };
    P6.create = (X, Q) => {
      return new P6({ valueType: X, minSize: null, maxSize: null, typeName: j.ZodSet, ...l(Q) });
    };
    JX = class _JX extends p {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X);
        if (Q.parsedType !== E.function) return b(Q, { code: w.invalid_type, expected: E.function, received: Q.parsedType }), g;
        function $(G, H) {
          return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: w.invalid_arguments, argumentsError: H } });
        }
        function Y(G, H) {
          return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: w.invalid_return_type, returnTypeError: H } });
        }
        let W = { errorMap: Q.common.contextualErrorMap }, J = Q.data;
        if (this._def.returns instanceof S6) {
          let G = this;
          return C0(async function(...H) {
            let B = new h0([]), z2 = await G._def.args.parseAsync(H, W).catch((L) => {
              throw B.addIssue($(H, L)), B;
            }), K = await Reflect.apply(J, this, z2);
            return await G._def.returns._def.type.parseAsync(K, W).catch((L) => {
              throw B.addIssue(Y(K, L)), B;
            });
          });
        } else {
          let G = this;
          return C0(function(...H) {
            let B = G._def.args.safeParse(H, W);
            if (!B.success) throw new h0([$(H, B.error)]);
            let z2 = Reflect.apply(J, this, B.data), K = G._def.returns.safeParse(z2, W);
            if (!K.success) throw new h0([Y(z2, K.error)]);
            return K.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...X) {
        return new _JX({ ...this._def, args: M1.create(X).rest(t1.create()) });
      }
      returns(X) {
        return new _JX({ ...this._def, returns: X });
      }
      implement(X) {
        return this.parse(X);
      }
      strictImplement(X) {
        return this.parse(X);
      }
      static create(X, Q, $) {
        return new _JX({ args: X ? X : M1.create([]).rest(t1.create()), returns: Q || t1.create(), typeName: j.ZodFunction, ...l($) });
      }
    };
    UX = class extends p {
      get schema() {
        return this._def.getter();
      }
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X);
        return this._def.getter()._parse({ data: Q.data, path: Q.path, parent: Q });
      }
    };
    UX.create = (X, Q) => {
      return new UX({ getter: X, typeName: j.ZodLazy, ...l(Q) });
    };
    VX = class extends p {
      _parse(X) {
        if (X.data !== this._def.value) {
          let Q = this._getOrReturnCtx(X);
          return b(Q, { received: Q.data, code: w.invalid_literal, expected: this._def.value }), g;
        }
        return { status: "valid", value: X.data };
      }
      get value() {
        return this._def.value;
      }
    };
    VX.create = (X, Q) => {
      return new VX({ value: X, typeName: j.ZodLiteral, ...l(Q) });
    };
    a1 = class _a1 extends p {
      _parse(X) {
        if (typeof X.data !== "string") {
          let Q = this._getOrReturnCtx(X), $ = this._def.values;
          return b(Q, { expected: n.joinValues($), received: Q.parsedType, code: w.invalid_type }), g;
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(X.data)) {
          let Q = this._getOrReturnCtx(X), $ = this._def.values;
          return b(Q, { received: Q.data, code: w.invalid_enum_value, options: $ }), g;
        }
        return C0(X.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        let X = {};
        for (let Q of this._def.values) X[Q] = Q;
        return X;
      }
      get Values() {
        let X = {};
        for (let Q of this._def.values) X[Q] = Q;
        return X;
      }
      get Enum() {
        let X = {};
        for (let Q of this._def.values) X[Q] = Q;
        return X;
      }
      extract(X, Q = this._def) {
        return _a1.create(X, { ...this._def, ...Q });
      }
      exclude(X, Q = this._def) {
        return _a1.create(this.options.filter(($) => !X.includes($)), { ...this._def, ...Q });
      }
    };
    a1.create = FW;
    LX = class extends p {
      _parse(X) {
        let Q = n.getValidEnumValues(this._def.values), $ = this._getOrReturnCtx(X);
        if ($.parsedType !== E.string && $.parsedType !== E.number) {
          let Y = n.objectValues(Q);
          return b($, { expected: n.joinValues(Y), received: $.parsedType, code: w.invalid_type }), g;
        }
        if (!this._cache) this._cache = new Set(n.getValidEnumValues(this._def.values));
        if (!this._cache.has(X.data)) {
          let Y = n.objectValues(Q);
          return b($, { received: $.data, code: w.invalid_enum_value, options: Y }), g;
        }
        return C0(X.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    LX.create = (X, Q) => {
      return new LX({ values: X, typeName: j.ZodNativeEnum, ...l(Q) });
    };
    S6 = class extends p {
      unwrap() {
        return this._def.type;
      }
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X);
        if (Q.parsedType !== E.promise && Q.common.async === false) return b(Q, { code: w.invalid_type, expected: E.promise, received: Q.parsedType }), g;
        let $ = Q.parsedType === E.promise ? Q.data : Promise.resolve(Q.data);
        return C0($.then((Y) => {
          return this._def.type.parseAsync(Y, { path: Q.path, errorMap: Q.common.contextualErrorMap });
        }));
      }
    };
    S6.create = (X, Q) => {
      return new S6({ type: X, typeName: j.ZodPromise, ...l(Q) });
    };
    H1 = class extends p {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === j.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X), Y = this._def.effect || null, W = { addIssue: (J) => {
          if (b($, J), J.fatal) Q.abort();
          else Q.dirty();
        }, get path() {
          return $.path;
        } };
        if (W.addIssue = W.addIssue.bind(W), Y.type === "preprocess") {
          let J = Y.transform($.data, W);
          if ($.common.async) return Promise.resolve(J).then(async (G) => {
            if (Q.value === "aborted") return g;
            let H = await this._def.schema._parseAsync({ data: G, path: $.path, parent: $ });
            if (H.status === "aborted") return g;
            if (H.status === "dirty") return R6(H.value);
            if (Q.value === "dirty") return R6(H.value);
            return H;
          });
          else {
            if (Q.value === "aborted") return g;
            let G = this._def.schema._parseSync({ data: J, path: $.path, parent: $ });
            if (G.status === "aborted") return g;
            if (G.status === "dirty") return R6(G.value);
            if (Q.value === "dirty") return R6(G.value);
            return G;
          }
        }
        if (Y.type === "refinement") {
          let J = (G) => {
            let H = Y.refinement(G, W);
            if ($.common.async) return Promise.resolve(H);
            if (H instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return G;
          };
          if ($.common.async === false) {
            let G = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
            if (G.status === "aborted") return g;
            if (G.status === "dirty") Q.dirty();
            return J(G.value), { status: Q.value, value: G.value };
          } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((G) => {
            if (G.status === "aborted") return g;
            if (G.status === "dirty") Q.dirty();
            return J(G.value).then(() => {
              return { status: Q.value, value: G.value };
            });
          });
        }
        if (Y.type === "transform") if ($.common.async === false) {
          let J = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
          if (!o1(J)) return g;
          let G = Y.transform(J.value, W);
          if (G instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: Q.value, value: G };
        } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((J) => {
          if (!o1(J)) return g;
          return Promise.resolve(Y.transform(J.value, W)).then((G) => ({ status: Q.value, value: G }));
        });
        n.assertNever(Y);
      }
    };
    H1.create = (X, Q, $) => {
      return new H1({ schema: X, typeName: j.ZodEffects, effect: Q, ...l($) });
    };
    H1.createWithPreprocess = (X, Q, $) => {
      return new H1({ schema: Q, effect: { type: "preprocess", transform: X }, typeName: j.ZodEffects, ...l($) });
    };
    G1 = class extends p {
      _parse(X) {
        if (this._getType(X) === E.undefined) return C0(void 0);
        return this._def.innerType._parse(X);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    G1.create = (X, Q) => {
      return new G1({ innerType: X, typeName: j.ZodOptional, ...l(Q) });
    };
    _1 = class extends p {
      _parse(X) {
        if (this._getType(X) === E.null) return C0(null);
        return this._def.innerType._parse(X);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    _1.create = (X, Q) => {
      return new _1({ innerType: X, typeName: j.ZodNullable, ...l(Q) });
    };
    qX = class extends p {
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X), $ = Q.data;
        if (Q.parsedType === E.undefined) $ = this._def.defaultValue();
        return this._def.innerType._parse({ data: $, path: Q.path, parent: Q });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    qX.create = (X, Q) => {
      return new qX({ innerType: X, typeName: j.ZodDefault, defaultValue: typeof Q.default === "function" ? Q.default : () => Q.default, ...l(Q) });
    };
    FX = class extends p {
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X), $ = { ...Q, common: { ...Q.common, issues: [] } }, Y = this._def.innerType._parse({ data: $.data, path: $.path, parent: { ...$ } });
        if (WX(Y)) return Y.then((W) => {
          return { status: "valid", value: W.status === "valid" ? W.value : this._def.catchValue({ get error() {
            return new h0($.common.issues);
          }, input: $.data }) };
        });
        else return { status: "valid", value: Y.status === "valid" ? Y.value : this._def.catchValue({ get error() {
          return new h0($.common.issues);
        }, input: $.data }) };
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    FX.create = (X, Q) => {
      return new FX({ innerType: X, typeName: j.ZodCatch, catchValue: typeof Q.catch === "function" ? Q.catch : () => Q.catch, ...l(Q) });
    };
    R4 = class extends p {
      _parse(X) {
        if (this._getType(X) !== E.nan) {
          let $ = this._getOrReturnCtx(X);
          return b($, { code: w.invalid_type, expected: E.nan, received: $.parsedType }), g;
        }
        return { status: "valid", value: X.data };
      }
    };
    R4.create = (X) => {
      return new R4({ typeName: j.ZodNaN, ...l(X) });
    };
    D9 = class extends p {
      _parse(X) {
        let { ctx: Q } = this._processInputParams(X), $ = Q.data;
        return this._def.type._parse({ data: $, path: Q.path, parent: Q });
      }
      unwrap() {
        return this._def.type;
      }
    };
    E4 = class _E4 extends p {
      _parse(X) {
        let { status: Q, ctx: $ } = this._processInputParams(X);
        if ($.common.async) return (async () => {
          let W = await this._def.in._parseAsync({ data: $.data, path: $.path, parent: $ });
          if (W.status === "aborted") return g;
          if (W.status === "dirty") return Q.dirty(), R6(W.value);
          else return this._def.out._parseAsync({ data: W.value, path: $.path, parent: $ });
        })();
        else {
          let Y = this._def.in._parseSync({ data: $.data, path: $.path, parent: $ });
          if (Y.status === "aborted") return g;
          if (Y.status === "dirty") return Q.dirty(), { status: "dirty", value: Y.value };
          else return this._def.out._parseSync({ data: Y.value, path: $.path, parent: $ });
        }
      }
      static create(X, Q) {
        return new _E4({ in: X, out: Q, typeName: j.ZodPipeline });
      }
    };
    NX = class extends p {
      _parse(X) {
        let Q = this._def.innerType._parse(X), $ = (Y) => {
          if (o1(Y)) Y.value = Object.freeze(Y.value);
          return Y;
        };
        return WX(Q) ? Q.then((Y) => $(Y)) : $(Q);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    NX.create = (X, Q) => {
      return new NX({ innerType: X, typeName: j.ZodReadonly, ...l(Q) });
    };
    A2 = { object: V0.lazycreate };
    (function(X) {
      X.ZodString = "ZodString", X.ZodNumber = "ZodNumber", X.ZodNaN = "ZodNaN", X.ZodBigInt = "ZodBigInt", X.ZodBoolean = "ZodBoolean", X.ZodDate = "ZodDate", X.ZodSymbol = "ZodSymbol", X.ZodUndefined = "ZodUndefined", X.ZodNull = "ZodNull", X.ZodAny = "ZodAny", X.ZodUnknown = "ZodUnknown", X.ZodNever = "ZodNever", X.ZodVoid = "ZodVoid", X.ZodArray = "ZodArray", X.ZodObject = "ZodObject", X.ZodUnion = "ZodUnion", X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", X.ZodIntersection = "ZodIntersection", X.ZodTuple = "ZodTuple", X.ZodRecord = "ZodRecord", X.ZodMap = "ZodMap", X.ZodSet = "ZodSet", X.ZodFunction = "ZodFunction", X.ZodLazy = "ZodLazy", X.ZodLiteral = "ZodLiteral", X.ZodEnum = "ZodEnum", X.ZodEffects = "ZodEffects", X.ZodNativeEnum = "ZodNativeEnum", X.ZodOptional = "ZodOptional", X.ZodNullable = "ZodNullable", X.ZodDefault = "ZodDefault", X.ZodCatch = "ZodCatch", X.ZodPromise = "ZodPromise", X.ZodBranded = "ZodBranded", X.ZodPipeline = "ZodPipeline", X.ZodReadonly = "ZodReadonly";
    })(j || (j = {}));
    w2 = A1.create;
    M2 = I6.create;
    j2 = R4.create;
    R2 = b6.create;
    E2 = O4.create;
    I2 = GX.create;
    b2 = D4.create;
    P2 = HX.create;
    S2 = BX.create;
    Z2 = A4.create;
    C2 = t1.create;
    k2 = w1.create;
    v2 = w4.create;
    T2 = J1.create;
    NW = V0.create;
    _2 = V0.strictCreate;
    x2 = zX.create;
    y2 = O9.create;
    g2 = KX.create;
    f2 = M1.create;
    h2 = M4.create;
    u2 = j4.create;
    l2 = P6.create;
    m2 = JX.create;
    c2 = UX.create;
    p2 = VX.create;
    d2 = a1.create;
    i2 = LX.create;
    n2 = S6.create;
    r2 = H1.create;
    o2 = G1.create;
    t2 = _1.create;
    a2 = H1.createWithPreprocess;
    s2 = E4.create;
    bV = Object.freeze({ status: "aborted" });
    x1 = class extends Error {
      constructor() {
        super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
      }
    };
    I4 = {};
    i = {};
    U7(i, { unwrapMessage: () => OX, stringifyPrimitive: () => S4, required: () => pV, randomString: () => xV, propertyKeyTypes: () => E9, promiseAllObject: () => _V, primitiveTypes: () => OW, prefixIssues: () => B1, pick: () => hV, partial: () => cV, optionalKeys: () => I9, omit: () => uV, numKeys: () => yV, nullish: () => wX, normalizeParams: () => y, merge: () => mV, jsonStringifyReplacer: () => w9, joinValues: () => b4, issue: () => P9, isPlainObject: () => C6, isObject: () => Z6, getSizableOrigin: () => AW, getParsedType: () => gV, getLengthableOrigin: () => jX, getEnumValues: () => DX, getElementAtPath: () => TV, floatSafeRemainder: () => M9, finalizeIssue: () => o0, extend: () => lV, escapeRegex: () => y1, esc: () => s1, defineLazy: () => Y0, createTransparentProxy: () => fV, clone: () => l0, cleanRegex: () => MX, cleanEnum: () => dV, captureStackTrace: () => P4, cached: () => AX, assignProp: () => j9, assertNotEqual: () => ZV, assertNever: () => kV, assertIs: () => CV, assertEqual: () => SV, assert: () => vV, allowsEval: () => R9, aborted: () => e1, NUMBER_FORMAT_RANGES: () => b9, Class: () => wW, BIGINT_FORMAT_RANGES: () => DW });
    P4 = Error.captureStackTrace ? Error.captureStackTrace : (...X) => {
    };
    R9 = AX(() => {
      if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return false;
      try {
        return new Function(""), true;
      } catch (X) {
        return false;
      }
    });
    gV = (X) => {
      let Q = typeof X;
      switch (Q) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(X) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(X)) return "array";
          if (X === null) return "null";
          if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return "promise";
          if (typeof Map < "u" && X instanceof Map) return "map";
          if (typeof Set < "u" && X instanceof Set) return "set";
          if (typeof Date < "u" && X instanceof Date) return "date";
          if (typeof File < "u" && X instanceof File) return "file";
          return "object";
        default:
          throw Error(`Unknown data type: ${Q}`);
      }
    };
    E9 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    OW = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    b9 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
    DW = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
    wW = class {
      constructor(...X) {
      }
    };
    MW = (X, Q) => {
      X.name = "$ZodError", Object.defineProperty(X, "_zod", { value: X._zod, enumerable: false }), Object.defineProperty(X, "issues", { value: Q, enumerable: false }), Object.defineProperty(X, "message", { get() {
        return JSON.stringify(Q, w9, 2);
      }, enumerable: true });
    };
    Z4 = O("$ZodError", MW);
    RX = O("$ZodError", MW, { Parent: Error });
    C9 = (X) => (Q, $, Y, W) => {
      let J = Y ? Object.assign(Y, { async: false }) : { async: false }, G = Q._zod.run({ value: $, issues: [] }, J);
      if (G instanceof Promise) throw new x1();
      if (G.issues.length) {
        let H = new (W?.Err ?? X)(G.issues.map((B) => o0(B, J, u0())));
        throw P4(H, W?.callee), H;
      }
      return G.value;
    };
    k9 = C9(RX);
    v9 = (X) => async (Q, $, Y, W) => {
      let J = Y ? Object.assign(Y, { async: true }) : { async: true }, G = Q._zod.run({ value: $, issues: [] }, J);
      if (G instanceof Promise) G = await G;
      if (G.issues.length) {
        let H = new (W?.Err ?? X)(G.issues.map((B) => o0(B, J, u0())));
        throw P4(H, W?.callee), H;
      }
      return G.value;
    };
    T9 = v9(RX);
    _9 = (X) => (Q, $, Y) => {
      let W = Y ? { ...Y, async: false } : { async: false }, J = Q._zod.run({ value: $, issues: [] }, W);
      if (J instanceof Promise) throw new x1();
      return J.issues.length ? { success: false, error: new (X ?? Z4)(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
    };
    X6 = _9(RX);
    x9 = (X) => async (Q, $, Y) => {
      let W = Y ? Object.assign(Y, { async: true }) : { async: true }, J = Q._zod.run({ value: $, issues: [] }, W);
      if (J instanceof Promise) J = await J;
      return J.issues.length ? { success: false, error: new X(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
    };
    Q6 = x9(RX);
    jW = /^[cC][^\s-]{8,}$/;
    RW = /^[0-9a-z]+$/;
    EW = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    IW = /^[0-9a-vA-V]{20}$/;
    bW = /^[A-Za-z0-9]{27}$/;
    PW = /^[a-zA-Z0-9_-]{21}$/;
    SW = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    ZW = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    y9 = (X) => {
      if (!X) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${X}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    CW = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    vW = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    TW = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
    _W = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    xW = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    yW = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    g9 = /^[A-Za-z0-9_-]*$/;
    gW = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
    fW = /^\+(?:[0-9]){6,14}[0-9]$/;
    hW = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
    uW = new RegExp(`^${hW}$`);
    pW = (X) => {
      let Q = X ? `[\\s\\S]{${X?.minimum ?? 0},${X?.maximum ?? ""}}` : "[\\s\\S]*";
      return new RegExp(`^${Q}$`);
    };
    dW = /^\d+$/;
    iW = /^-?\d+(?:\.\d+)?/i;
    nW = /true|false/i;
    rW = /null/i;
    oW = /^[^A-Z]*$/;
    tW = /^[^a-z]*$/;
    w0 = O("$ZodCheck", (X, Q) => {
      var $;
      X._zod ?? (X._zod = {}), X._zod.def = Q, ($ = X._zod).onattach ?? ($.onattach = []);
    });
    aW = { number: "number", bigint: "bigint", object: "date" };
    f9 = O("$ZodCheckLessThan", (X, Q) => {
      w0.init(X, Q);
      let $ = aW[typeof Q.value];
      X._zod.onattach.push((Y) => {
        let W = Y._zod.bag, J = (Q.inclusive ? W.maximum : W.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (Q.value < J) if (Q.inclusive) W.maximum = Q.value;
        else W.exclusiveMaximum = Q.value;
      }), X._zod.check = (Y) => {
        if (Q.inclusive ? Y.value <= Q.value : Y.value < Q.value) return;
        Y.issues.push({ origin: $, code: "too_big", maximum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
      };
    });
    h9 = O("$ZodCheckGreaterThan", (X, Q) => {
      w0.init(X, Q);
      let $ = aW[typeof Q.value];
      X._zod.onattach.push((Y) => {
        let W = Y._zod.bag, J = (Q.inclusive ? W.minimum : W.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (Q.value > J) if (Q.inclusive) W.minimum = Q.value;
        else W.exclusiveMinimum = Q.value;
      }), X._zod.check = (Y) => {
        if (Q.inclusive ? Y.value >= Q.value : Y.value > Q.value) return;
        Y.issues.push({ origin: $, code: "too_small", minimum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
      };
    });
    sW = O("$ZodCheckMultipleOf", (X, Q) => {
      w0.init(X, Q), X._zod.onattach.push(($) => {
        var Y;
        (Y = $._zod.bag).multipleOf ?? (Y.multipleOf = Q.value);
      }), X._zod.check = ($) => {
        if (typeof $.value !== typeof Q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
        if (typeof $.value === "bigint" ? $.value % Q.value === BigInt(0) : M9($.value, Q.value) === 0) return;
        $.issues.push({ origin: typeof $.value, code: "not_multiple_of", divisor: Q.value, input: $.value, inst: X, continue: !Q.abort });
      };
    });
    eW = O("$ZodCheckNumberFormat", (X, Q) => {
      w0.init(X, Q), Q.format = Q.format || "float64";
      let $ = Q.format?.includes("int"), Y = $ ? "int" : "number", [W, J] = b9[Q.format];
      X._zod.onattach.push((G) => {
        let H = G._zod.bag;
        if (H.format = Q.format, H.minimum = W, H.maximum = J, $) H.pattern = dW;
      }), X._zod.check = (G) => {
        let H = G.value;
        if ($) {
          if (!Number.isInteger(H)) {
            G.issues.push({ expected: Y, format: Q.format, code: "invalid_type", input: H, inst: X });
            return;
          }
          if (!Number.isSafeInteger(H)) {
            if (H > 0) G.issues.push({ input: H, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
            else G.issues.push({ input: H, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
            return;
          }
        }
        if (H < W) G.issues.push({ origin: "number", input: H, code: "too_small", minimum: W, inclusive: true, inst: X, continue: !Q.abort });
        if (H > J) G.issues.push({ origin: "number", input: H, code: "too_big", maximum: J, inst: X });
      };
    });
    XJ = O("$ZodCheckMaxLength", (X, Q) => {
      w0.init(X, Q), X._zod.when = ($) => {
        let Y = $.value;
        return !wX(Y) && Y.length !== void 0;
      }, X._zod.onattach.push(($) => {
        let Y = $._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (Q.maximum < Y) $._zod.bag.maximum = Q.maximum;
      }), X._zod.check = ($) => {
        let Y = $.value;
        if (Y.length <= Q.maximum) return;
        let J = jX(Y);
        $.issues.push({ origin: J, code: "too_big", maximum: Q.maximum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
      };
    });
    QJ = O("$ZodCheckMinLength", (X, Q) => {
      w0.init(X, Q), X._zod.when = ($) => {
        let Y = $.value;
        return !wX(Y) && Y.length !== void 0;
      }, X._zod.onattach.push(($) => {
        let Y = $._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (Q.minimum > Y) $._zod.bag.minimum = Q.minimum;
      }), X._zod.check = ($) => {
        let Y = $.value;
        if (Y.length >= Q.minimum) return;
        let J = jX(Y);
        $.issues.push({ origin: J, code: "too_small", minimum: Q.minimum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
      };
    });
    $J = O("$ZodCheckLengthEquals", (X, Q) => {
      w0.init(X, Q), X._zod.when = ($) => {
        let Y = $.value;
        return !wX(Y) && Y.length !== void 0;
      }, X._zod.onattach.push(($) => {
        let Y = $._zod.bag;
        Y.minimum = Q.length, Y.maximum = Q.length, Y.length = Q.length;
      }), X._zod.check = ($) => {
        let Y = $.value, W = Y.length;
        if (W === Q.length) return;
        let J = jX(Y), G = W > Q.length;
        $.issues.push({ origin: J, ...G ? { code: "too_big", maximum: Q.length } : { code: "too_small", minimum: Q.length }, inclusive: true, exact: true, input: $.value, inst: X, continue: !Q.abort });
      };
    });
    EX = O("$ZodCheckStringFormat", (X, Q) => {
      var $, Y;
      if (w0.init(X, Q), X._zod.onattach.push((W) => {
        let J = W._zod.bag;
        if (J.format = Q.format, Q.pattern) J.patterns ?? (J.patterns = /* @__PURE__ */ new Set()), J.patterns.add(Q.pattern);
      }), Q.pattern) ($ = X._zod).check ?? ($.check = (W) => {
        if (Q.pattern.lastIndex = 0, Q.pattern.test(W.value)) return;
        W.issues.push({ origin: "string", code: "invalid_format", format: Q.format, input: W.value, ...Q.pattern ? { pattern: Q.pattern.toString() } : {}, inst: X, continue: !Q.abort });
      });
      else (Y = X._zod).check ?? (Y.check = () => {
      });
    });
    YJ = O("$ZodCheckRegex", (X, Q) => {
      EX.init(X, Q), X._zod.check = ($) => {
        if (Q.pattern.lastIndex = 0, Q.pattern.test($.value)) return;
        $.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: $.value, pattern: Q.pattern.toString(), inst: X, continue: !Q.abort });
      };
    });
    WJ = O("$ZodCheckLowerCase", (X, Q) => {
      Q.pattern ?? (Q.pattern = oW), EX.init(X, Q);
    });
    JJ = O("$ZodCheckUpperCase", (X, Q) => {
      Q.pattern ?? (Q.pattern = tW), EX.init(X, Q);
    });
    GJ = O("$ZodCheckIncludes", (X, Q) => {
      w0.init(X, Q);
      let $ = y1(Q.includes), Y = new RegExp(typeof Q.position === "number" ? `^.{${Q.position}}${$}` : $);
      Q.pattern = Y, X._zod.onattach.push((W) => {
        let J = W._zod.bag;
        J.patterns ?? (J.patterns = /* @__PURE__ */ new Set()), J.patterns.add(Y);
      }), X._zod.check = (W) => {
        if (W.value.includes(Q.includes, Q.position)) return;
        W.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: Q.includes, input: W.value, inst: X, continue: !Q.abort });
      };
    });
    HJ = O("$ZodCheckStartsWith", (X, Q) => {
      w0.init(X, Q);
      let $ = new RegExp(`^${y1(Q.prefix)}.*`);
      Q.pattern ?? (Q.pattern = $), X._zod.onattach.push((Y) => {
        let W = Y._zod.bag;
        W.patterns ?? (W.patterns = /* @__PURE__ */ new Set()), W.patterns.add($);
      }), X._zod.check = (Y) => {
        if (Y.value.startsWith(Q.prefix)) return;
        Y.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: Q.prefix, input: Y.value, inst: X, continue: !Q.abort });
      };
    });
    BJ = O("$ZodCheckEndsWith", (X, Q) => {
      w0.init(X, Q);
      let $ = new RegExp(`.*${y1(Q.suffix)}$`);
      Q.pattern ?? (Q.pattern = $), X._zod.onattach.push((Y) => {
        let W = Y._zod.bag;
        W.patterns ?? (W.patterns = /* @__PURE__ */ new Set()), W.patterns.add($);
      }), X._zod.check = (Y) => {
        if (Y.value.endsWith(Q.suffix)) return;
        Y.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: Q.suffix, input: Y.value, inst: X, continue: !Q.abort });
      };
    });
    zJ = O("$ZodCheckOverwrite", (X, Q) => {
      w0.init(X, Q), X._zod.check = ($) => {
        $.value = Q.tx($.value);
      };
    });
    u9 = class {
      constructor(X = []) {
        if (this.content = [], this.indent = 0, this) this.args = X;
      }
      indented(X) {
        this.indent += 1, X(this), this.indent -= 1;
      }
      write(X) {
        if (typeof X === "function") {
          X(this, { execution: "sync" }), X(this, { execution: "async" });
          return;
        }
        let $ = X.split(`
`).filter((J) => J), Y = Math.min(...$.map((J) => J.length - J.trimStart().length)), W = $.map((J) => J.slice(Y)).map((J) => " ".repeat(this.indent * 2) + J);
        for (let J of W) this.content.push(J);
      }
      compile() {
        let X = Function, Q = this?.args, Y = [...(this?.content ?? [""]).map((W) => `  ${W}`)];
        return new X(...Q, Y.join(`
`));
      }
    };
    UJ = { major: 4, minor: 0, patch: 0 };
    X0 = O("$ZodType", (X, Q) => {
      var $;
      X ?? (X = {}), X._zod.def = Q, X._zod.bag = X._zod.bag || {}, X._zod.version = UJ;
      let Y = [...X._zod.def.checks ?? []];
      if (X._zod.traits.has("$ZodCheck")) Y.unshift(X);
      for (let W of Y) for (let J of W._zod.onattach) J(X);
      if (Y.length === 0) ($ = X._zod).deferred ?? ($.deferred = []), X._zod.deferred?.push(() => {
        X._zod.run = X._zod.parse;
      });
      else {
        let W = (J, G, H) => {
          let B = e1(J), z2;
          for (let K of G) {
            if (K._zod.when) {
              if (!K._zod.when(J)) continue;
            } else if (B) continue;
            let V = J.issues.length, L = K._zod.check(J);
            if (L instanceof Promise && H?.async === false) throw new x1();
            if (z2 || L instanceof Promise) z2 = (z2 ?? Promise.resolve()).then(async () => {
              if (await L, J.issues.length === V) return;
              if (!B) B = e1(J, V);
            });
            else {
              if (J.issues.length === V) continue;
              if (!B) B = e1(J, V);
            }
          }
          if (z2) return z2.then(() => {
            return J;
          });
          return J;
        };
        X._zod.run = (J, G) => {
          let H = X._zod.parse(J, G);
          if (H instanceof Promise) {
            if (G.async === false) throw new x1();
            return H.then((B) => W(B, Y, G));
          }
          return W(H, Y, G);
        };
      }
      X["~standard"] = { validate: (W) => {
        try {
          let J = X6(X, W);
          return J.success ? { value: J.data } : { issues: J.error?.issues };
        } catch (J) {
          return Q6(X, W).then((G) => G.success ? { value: G.data } : { issues: G.error?.issues });
        }
      }, vendor: "zod", version: 1 };
    });
    IX = O("$ZodString", (X, Q) => {
      X0.init(X, Q), X._zod.pattern = [...X?._zod.bag?.patterns ?? []].pop() ?? pW(X._zod.bag), X._zod.parse = ($, Y) => {
        if (Q.coerce) try {
          $.value = String($.value);
        } catch (W) {
        }
        if (typeof $.value === "string") return $;
        return $.issues.push({ expected: "string", code: "invalid_type", input: $.value, inst: X }), $;
      };
    });
    W0 = O("$ZodStringFormat", (X, Q) => {
      EX.init(X, Q), IX.init(X, Q);
    });
    m9 = O("$ZodGUID", (X, Q) => {
      Q.pattern ?? (Q.pattern = ZW), W0.init(X, Q);
    });
    c9 = O("$ZodUUID", (X, Q) => {
      if (Q.version) {
        let Y = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[Q.version];
        if (Y === void 0) throw Error(`Invalid UUID version: "${Q.version}"`);
        Q.pattern ?? (Q.pattern = y9(Y));
      } else Q.pattern ?? (Q.pattern = y9());
      W0.init(X, Q);
    });
    p9 = O("$ZodEmail", (X, Q) => {
      Q.pattern ?? (Q.pattern = CW), W0.init(X, Q);
    });
    d9 = O("$ZodURL", (X, Q) => {
      W0.init(X, Q), X._zod.check = ($) => {
        try {
          let Y = $.value, W = new URL(Y), J = W.href;
          if (Q.hostname) {
            if (Q.hostname.lastIndex = 0, !Q.hostname.test(W.hostname)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: gW.source, input: $.value, inst: X, continue: !Q.abort });
          }
          if (Q.protocol) {
            if (Q.protocol.lastIndex = 0, !Q.protocol.test(W.protocol.endsWith(":") ? W.protocol.slice(0, -1) : W.protocol)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: Q.protocol.source, input: $.value, inst: X, continue: !Q.abort });
          }
          if (!Y.endsWith("/") && J.endsWith("/")) $.value = J.slice(0, -1);
          else $.value = J;
          return;
        } catch (Y) {
          $.issues.push({ code: "invalid_format", format: "url", input: $.value, inst: X, continue: !Q.abort });
        }
      };
    });
    i9 = O("$ZodEmoji", (X, Q) => {
      Q.pattern ?? (Q.pattern = kW()), W0.init(X, Q);
    });
    n9 = O("$ZodNanoID", (X, Q) => {
      Q.pattern ?? (Q.pattern = PW), W0.init(X, Q);
    });
    r9 = O("$ZodCUID", (X, Q) => {
      Q.pattern ?? (Q.pattern = jW), W0.init(X, Q);
    });
    o9 = O("$ZodCUID2", (X, Q) => {
      Q.pattern ?? (Q.pattern = RW), W0.init(X, Q);
    });
    t9 = O("$ZodULID", (X, Q) => {
      Q.pattern ?? (Q.pattern = EW), W0.init(X, Q);
    });
    a9 = O("$ZodXID", (X, Q) => {
      Q.pattern ?? (Q.pattern = IW), W0.init(X, Q);
    });
    s9 = O("$ZodKSUID", (X, Q) => {
      Q.pattern ?? (Q.pattern = bW), W0.init(X, Q);
    });
    MJ = O("$ZodISODateTime", (X, Q) => {
      Q.pattern ?? (Q.pattern = cW(Q)), W0.init(X, Q);
    });
    jJ = O("$ZodISODate", (X, Q) => {
      Q.pattern ?? (Q.pattern = uW), W0.init(X, Q);
    });
    RJ = O("$ZodISOTime", (X, Q) => {
      Q.pattern ?? (Q.pattern = mW(Q)), W0.init(X, Q);
    });
    EJ = O("$ZodISODuration", (X, Q) => {
      Q.pattern ?? (Q.pattern = SW), W0.init(X, Q);
    });
    e9 = O("$ZodIPv4", (X, Q) => {
      Q.pattern ?? (Q.pattern = vW), W0.init(X, Q), X._zod.onattach.push(($) => {
        let Y = $._zod.bag;
        Y.format = "ipv4";
      });
    });
    XQ = O("$ZodIPv6", (X, Q) => {
      Q.pattern ?? (Q.pattern = TW), W0.init(X, Q), X._zod.onattach.push(($) => {
        let Y = $._zod.bag;
        Y.format = "ipv6";
      }), X._zod.check = ($) => {
        try {
          new URL(`http://[${$.value}]`);
        } catch {
          $.issues.push({ code: "invalid_format", format: "ipv6", input: $.value, inst: X, continue: !Q.abort });
        }
      };
    });
    QQ = O("$ZodCIDRv4", (X, Q) => {
      Q.pattern ?? (Q.pattern = _W), W0.init(X, Q);
    });
    $Q = O("$ZodCIDRv6", (X, Q) => {
      Q.pattern ?? (Q.pattern = xW), W0.init(X, Q), X._zod.check = ($) => {
        let [Y, W] = $.value.split("/");
        try {
          if (!W) throw Error();
          let J = Number(W);
          if (`${J}` !== W) throw Error();
          if (J < 0 || J > 128) throw Error();
          new URL(`http://[${Y}]`);
        } catch {
          $.issues.push({ code: "invalid_format", format: "cidrv6", input: $.value, inst: X, continue: !Q.abort });
        }
      };
    });
    YQ = O("$ZodBase64", (X, Q) => {
      Q.pattern ?? (Q.pattern = yW), W0.init(X, Q), X._zod.onattach.push(($) => {
        $._zod.bag.contentEncoding = "base64";
      }), X._zod.check = ($) => {
        if (IJ($.value)) return;
        $.issues.push({ code: "invalid_format", format: "base64", input: $.value, inst: X, continue: !Q.abort });
      };
    });
    WQ = O("$ZodBase64URL", (X, Q) => {
      Q.pattern ?? (Q.pattern = g9), W0.init(X, Q), X._zod.onattach.push(($) => {
        $._zod.bag.contentEncoding = "base64url";
      }), X._zod.check = ($) => {
        if (nV($.value)) return;
        $.issues.push({ code: "invalid_format", format: "base64url", input: $.value, inst: X, continue: !Q.abort });
      };
    });
    JQ = O("$ZodE164", (X, Q) => {
      Q.pattern ?? (Q.pattern = fW), W0.init(X, Q);
    });
    GQ = O("$ZodJWT", (X, Q) => {
      W0.init(X, Q), X._zod.check = ($) => {
        if (rV($.value, Q.alg)) return;
        $.issues.push({ code: "invalid_format", format: "jwt", input: $.value, inst: X, continue: !Q.abort });
      };
    });
    v4 = O("$ZodNumber", (X, Q) => {
      X0.init(X, Q), X._zod.pattern = X._zod.bag.pattern ?? iW, X._zod.parse = ($, Y) => {
        if (Q.coerce) try {
          $.value = Number($.value);
        } catch (G) {
        }
        let W = $.value;
        if (typeof W === "number" && !Number.isNaN(W) && Number.isFinite(W)) return $;
        let J = typeof W === "number" ? Number.isNaN(W) ? "NaN" : !Number.isFinite(W) ? "Infinity" : void 0 : void 0;
        return $.issues.push({ expected: "number", code: "invalid_type", input: W, inst: X, ...J ? { received: J } : {} }), $;
      };
    });
    HQ = O("$ZodNumber", (X, Q) => {
      eW.init(X, Q), v4.init(X, Q);
    });
    BQ = O("$ZodBoolean", (X, Q) => {
      X0.init(X, Q), X._zod.pattern = nW, X._zod.parse = ($, Y) => {
        if (Q.coerce) try {
          $.value = Boolean($.value);
        } catch (J) {
        }
        let W = $.value;
        if (typeof W === "boolean") return $;
        return $.issues.push({ expected: "boolean", code: "invalid_type", input: W, inst: X }), $;
      };
    });
    zQ = O("$ZodNull", (X, Q) => {
      X0.init(X, Q), X._zod.pattern = rW, X._zod.values = /* @__PURE__ */ new Set([null]), X._zod.parse = ($, Y) => {
        let W = $.value;
        if (W === null) return $;
        return $.issues.push({ expected: "null", code: "invalid_type", input: W, inst: X }), $;
      };
    });
    KQ = O("$ZodUnknown", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($) => $;
    });
    UQ = O("$ZodNever", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($, Y) => {
        return $.issues.push({ expected: "never", code: "invalid_type", input: $.value, inst: X }), $;
      };
    });
    VQ = O("$ZodArray", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($, Y) => {
        let W = $.value;
        if (!Array.isArray(W)) return $.issues.push({ expected: "array", code: "invalid_type", input: W, inst: X }), $;
        $.value = Array(W.length);
        let J = [];
        for (let G = 0; G < W.length; G++) {
          let H = W[G], B = Q.element._zod.run({ value: H, issues: [] }, Y);
          if (B instanceof Promise) J.push(B.then((z2) => VJ(z2, $, G)));
          else VJ(B, $, G);
        }
        if (J.length) return Promise.all(J).then(() => $);
        return $;
      };
    });
    T4 = O("$ZodObject", (X, Q) => {
      X0.init(X, Q);
      let $ = AX(() => {
        let V = Object.keys(Q.shape);
        for (let U of V) if (!(Q.shape[U] instanceof X0)) throw Error(`Invalid element at key "${U}": expected a Zod schema`);
        let L = I9(Q.shape);
        return { shape: Q.shape, keys: V, keySet: new Set(V), numKeys: V.length, optionalKeys: new Set(L) };
      });
      Y0(X._zod, "propValues", () => {
        let V = Q.shape, L = {};
        for (let U in V) {
          let F = V[U]._zod;
          if (F.values) {
            L[U] ?? (L[U] = /* @__PURE__ */ new Set());
            for (let q of F.values) L[U].add(q);
          }
        }
        return L;
      });
      let Y = (V) => {
        let L = new u9(["shape", "payload", "ctx"]), U = $.value, F = (M) => {
          let R = s1(M);
          return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
        };
        L.write("const input = payload.value;");
        let q = /* @__PURE__ */ Object.create(null), N = 0;
        for (let M of U.keys) q[M] = `key_${N++}`;
        L.write("const newResult = {}");
        for (let M of U.keys) if (U.optionalKeys.has(M)) {
          let R = q[M];
          L.write(`const ${R} = ${F(M)};`);
          let S = s1(M);
          L.write(`
        if (${R}.issues.length) {
          if (input[${S}] === undefined) {
            if (${S} in input) {
              newResult[${S}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${R}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${S}, ...iss.path] : [${S}],
              }))
            );
          }
        } else if (${R}.value === undefined) {
          if (${S} in input) newResult[${S}] = undefined;
        } else {
          newResult[${S}] = ${R}.value;
        }
        `);
        } else {
          let R = q[M];
          L.write(`const ${R} = ${F(M)};`), L.write(`
          if (${R}.issues.length) payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${s1(M)}, ...iss.path] : [${s1(M)}]
          })));`), L.write(`newResult[${s1(M)}] = ${R}.value`);
        }
        L.write("payload.value = newResult;"), L.write("return payload;");
        let A = L.compile();
        return (M, R) => A(V, M, R);
      }, W, J = Z6, G = !I4.jitless, B = G && R9.value, z2 = Q.catchall, K;
      X._zod.parse = (V, L) => {
        K ?? (K = $.value);
        let U = V.value;
        if (!J(U)) return V.issues.push({ expected: "object", code: "invalid_type", input: U, inst: X }), V;
        let F = [];
        if (G && B && L?.async === false && L.jitless !== true) {
          if (!W) W = Y(Q.shape);
          V = W(V, L);
        } else {
          V.value = {};
          let R = K.shape;
          for (let S of K.keys) {
            let C = R[S], K0 = C._zod.run({ value: U[S], issues: [] }, L), U0 = C._zod.optin === "optional" && C._zod.optout === "optional";
            if (K0 instanceof Promise) F.push(K0.then((s) => U0 ? LJ(s, V, S, U) : k4(s, V, S)));
            else if (U0) LJ(K0, V, S, U);
            else k4(K0, V, S);
          }
        }
        if (!z2) return F.length ? Promise.all(F).then(() => V) : V;
        let q = [], N = K.keySet, A = z2._zod, M = A.def.type;
        for (let R of Object.keys(U)) {
          if (N.has(R)) continue;
          if (M === "never") {
            q.push(R);
            continue;
          }
          let S = A.run({ value: U[R], issues: [] }, L);
          if (S instanceof Promise) F.push(S.then((C) => k4(C, V, R)));
          else k4(S, V, R);
        }
        if (q.length) V.issues.push({ code: "unrecognized_keys", keys: q, input: U, inst: X });
        if (!F.length) return V;
        return Promise.all(F).then(() => {
          return V;
        });
      };
    });
    _4 = O("$ZodUnion", (X, Q) => {
      X0.init(X, Q), Y0(X._zod, "optin", () => Q.options.some(($) => $._zod.optin === "optional") ? "optional" : void 0), Y0(X._zod, "optout", () => Q.options.some(($) => $._zod.optout === "optional") ? "optional" : void 0), Y0(X._zod, "values", () => {
        if (Q.options.every(($) => $._zod.values)) return new Set(Q.options.flatMap(($) => Array.from($._zod.values)));
        return;
      }), Y0(X._zod, "pattern", () => {
        if (Q.options.every(($) => $._zod.pattern)) {
          let $ = Q.options.map((Y) => Y._zod.pattern);
          return new RegExp(`^(${$.map((Y) => MX(Y.source)).join("|")})$`);
        }
        return;
      }), X._zod.parse = ($, Y) => {
        let W = false, J = [];
        for (let G of Q.options) {
          let H = G._zod.run({ value: $.value, issues: [] }, Y);
          if (H instanceof Promise) J.push(H), W = true;
          else {
            if (H.issues.length === 0) return H;
            J.push(H);
          }
        }
        if (!W) return qJ(J, $, X, Y);
        return Promise.all(J).then((G) => {
          return qJ(G, $, X, Y);
        });
      };
    });
    LQ = O("$ZodDiscriminatedUnion", (X, Q) => {
      _4.init(X, Q);
      let $ = X._zod.parse;
      Y0(X._zod, "propValues", () => {
        let W = {};
        for (let J of Q.options) {
          let G = J._zod.propValues;
          if (!G || Object.keys(G).length === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(J)}"`);
          for (let [H, B] of Object.entries(G)) {
            if (!W[H]) W[H] = /* @__PURE__ */ new Set();
            for (let z2 of B) W[H].add(z2);
          }
        }
        return W;
      });
      let Y = AX(() => {
        let W = Q.options, J = /* @__PURE__ */ new Map();
        for (let G of W) {
          let H = G._zod.propValues[Q.discriminator];
          if (!H || H.size === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(G)}"`);
          for (let B of H) {
            if (J.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
            J.set(B, G);
          }
        }
        return J;
      });
      X._zod.parse = (W, J) => {
        let G = W.value;
        if (!Z6(G)) return W.issues.push({ code: "invalid_type", expected: "object", input: G, inst: X }), W;
        let H = Y.value.get(G?.[Q.discriminator]);
        if (H) return H._zod.run(W, J);
        if (Q.unionFallback) return $(W, J);
        return W.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", input: G, path: [Q.discriminator], inst: X }), W;
      };
    });
    qQ = O("$ZodIntersection", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($, Y) => {
        let W = $.value, J = Q.left._zod.run({ value: W, issues: [] }, Y), G = Q.right._zod.run({ value: W, issues: [] }, Y);
        if (J instanceof Promise || G instanceof Promise) return Promise.all([J, G]).then(([B, z2]) => {
          return FJ($, B, z2);
        });
        return FJ($, J, G);
      };
    });
    FQ = O("$ZodRecord", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($, Y) => {
        let W = $.value;
        if (!C6(W)) return $.issues.push({ expected: "record", code: "invalid_type", input: W, inst: X }), $;
        let J = [];
        if (Q.keyType._zod.values) {
          let G = Q.keyType._zod.values;
          $.value = {};
          for (let B of G) if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
            let z2 = Q.valueType._zod.run({ value: W[B], issues: [] }, Y);
            if (z2 instanceof Promise) J.push(z2.then((K) => {
              if (K.issues.length) $.issues.push(...B1(B, K.issues));
              $.value[B] = K.value;
            }));
            else {
              if (z2.issues.length) $.issues.push(...B1(B, z2.issues));
              $.value[B] = z2.value;
            }
          }
          let H;
          for (let B in W) if (!G.has(B)) H = H ?? [], H.push(B);
          if (H && H.length > 0) $.issues.push({ code: "unrecognized_keys", input: W, inst: X, keys: H });
        } else {
          $.value = {};
          for (let G of Reflect.ownKeys(W)) {
            if (G === "__proto__") continue;
            let H = Q.keyType._zod.run({ value: G, issues: [] }, Y);
            if (H instanceof Promise) throw Error("Async schemas not supported in object keys currently");
            if (H.issues.length) {
              $.issues.push({ origin: "record", code: "invalid_key", issues: H.issues.map((z2) => o0(z2, Y, u0())), input: G, path: [G], inst: X }), $.value[H.value] = H.value;
              continue;
            }
            let B = Q.valueType._zod.run({ value: W[G], issues: [] }, Y);
            if (B instanceof Promise) J.push(B.then((z2) => {
              if (z2.issues.length) $.issues.push(...B1(G, z2.issues));
              $.value[H.value] = z2.value;
            }));
            else {
              if (B.issues.length) $.issues.push(...B1(G, B.issues));
              $.value[H.value] = B.value;
            }
          }
        }
        if (J.length) return Promise.all(J).then(() => $);
        return $;
      };
    });
    NQ = O("$ZodEnum", (X, Q) => {
      X0.init(X, Q);
      let $ = DX(Q.entries);
      X._zod.values = new Set($), X._zod.pattern = new RegExp(`^(${$.filter((Y) => E9.has(typeof Y)).map((Y) => typeof Y === "string" ? y1(Y) : Y.toString()).join("|")})$`), X._zod.parse = (Y, W) => {
        let J = Y.value;
        if (X._zod.values.has(J)) return Y;
        return Y.issues.push({ code: "invalid_value", values: $, input: J, inst: X }), Y;
      };
    });
    OQ = O("$ZodLiteral", (X, Q) => {
      X0.init(X, Q), X._zod.values = new Set(Q.values), X._zod.pattern = new RegExp(`^(${Q.values.map(($) => typeof $ === "string" ? y1($) : $ ? $.toString() : String($)).join("|")})$`), X._zod.parse = ($, Y) => {
        let W = $.value;
        if (X._zod.values.has(W)) return $;
        return $.issues.push({ code: "invalid_value", values: Q.values, input: W, inst: X }), $;
      };
    });
    DQ = O("$ZodTransform", (X, Q) => {
      X0.init(X, Q), X._zod.parse = ($, Y) => {
        let W = Q.transform($.value, $);
        if (Y.async) return (W instanceof Promise ? W : Promise.resolve(W)).then((G) => {
          return $.value = G, $;
        });
        if (W instanceof Promise) throw new x1();
        return $.value = W, $;
      };
    });
    AQ = O("$ZodOptional", (X, Q) => {
      X0.init(X, Q), X._zod.optin = "optional", X._zod.optout = "optional", Y0(X._zod, "values", () => {
        return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, void 0]) : void 0;
      }), Y0(X._zod, "pattern", () => {
        let $ = Q.innerType._zod.pattern;
        return $ ? new RegExp(`^(${MX($.source)})?$`) : void 0;
      }), X._zod.parse = ($, Y) => {
        if (Q.innerType._zod.optin === "optional") return Q.innerType._zod.run($, Y);
        if ($.value === void 0) return $;
        return Q.innerType._zod.run($, Y);
      };
    });
    wQ = O("$ZodNullable", (X, Q) => {
      X0.init(X, Q), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "pattern", () => {
        let $ = Q.innerType._zod.pattern;
        return $ ? new RegExp(`^(${MX($.source)}|null)$`) : void 0;
      }), Y0(X._zod, "values", () => {
        return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, null]) : void 0;
      }), X._zod.parse = ($, Y) => {
        if ($.value === null) return $;
        return Q.innerType._zod.run($, Y);
      };
    });
    MQ = O("$ZodDefault", (X, Q) => {
      X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
        if ($.value === void 0) return $.value = Q.defaultValue, $;
        let W = Q.innerType._zod.run($, Y);
        if (W instanceof Promise) return W.then((J) => NJ(J, Q));
        return NJ(W, Q);
      };
    });
    jQ = O("$ZodPrefault", (X, Q) => {
      X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
        if ($.value === void 0) $.value = Q.defaultValue;
        return Q.innerType._zod.run($, Y);
      };
    });
    RQ = O("$ZodNonOptional", (X, Q) => {
      X0.init(X, Q), Y0(X._zod, "values", () => {
        let $ = Q.innerType._zod.values;
        return $ ? new Set([...$].filter((Y) => Y !== void 0)) : void 0;
      }), X._zod.parse = ($, Y) => {
        let W = Q.innerType._zod.run($, Y);
        if (W instanceof Promise) return W.then((J) => OJ(J, X));
        return OJ(W, X);
      };
    });
    EQ = O("$ZodCatch", (X, Q) => {
      X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
        let W = Q.innerType._zod.run($, Y);
        if (W instanceof Promise) return W.then((J) => {
          if ($.value = J.value, J.issues.length) $.value = Q.catchValue({ ...$, error: { issues: J.issues.map((G) => o0(G, Y, u0())) }, input: $.value }), $.issues = [];
          return $;
        });
        if ($.value = W.value, W.issues.length) $.value = Q.catchValue({ ...$, error: { issues: W.issues.map((J) => o0(J, Y, u0())) }, input: $.value }), $.issues = [];
        return $;
      };
    });
    IQ = O("$ZodPipe", (X, Q) => {
      X0.init(X, Q), Y0(X._zod, "values", () => Q.in._zod.values), Y0(X._zod, "optin", () => Q.in._zod.optin), Y0(X._zod, "optout", () => Q.out._zod.optout), X._zod.parse = ($, Y) => {
        let W = Q.in._zod.run($, Y);
        if (W instanceof Promise) return W.then((J) => DJ(J, Q, Y));
        return DJ(W, Q, Y);
      };
    });
    bQ = O("$ZodReadonly", (X, Q) => {
      X0.init(X, Q), Y0(X._zod, "propValues", () => Q.innerType._zod.propValues), Y0(X._zod, "values", () => Q.innerType._zod.values), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), X._zod.parse = ($, Y) => {
        let W = Q.innerType._zod.run($, Y);
        if (W instanceof Promise) return W.then(AJ);
        return AJ(W);
      };
    });
    PQ = O("$ZodCustom", (X, Q) => {
      w0.init(X, Q), X0.init(X, Q), X._zod.parse = ($, Y) => {
        return $;
      }, X._zod.check = ($) => {
        let Y = $.value, W = Q.fn(Y);
        if (W instanceof Promise) return W.then((J) => wJ(J, $, Y, X));
        wJ(W, $, Y, X);
        return;
      };
    });
    oV = (X) => {
      let Q = typeof X;
      switch (Q) {
        case "number":
          return Number.isNaN(X) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(X)) return "array";
          if (X === null) return "null";
          if (Object.getPrototypeOf(X) !== Object.prototype && X.constructor) return X.constructor.name;
        }
      }
      return Q;
    };
    tV = () => {
      let X = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
      function Q(Y) {
        return X[Y] ?? null;
      }
      let $ = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
      return (Y) => {
        switch (Y.code) {
          case "invalid_type":
            return `Invalid input: expected ${Y.expected}, received ${oV(Y.input)}`;
          case "invalid_value":
            if (Y.values.length === 1) return `Invalid input: expected ${S4(Y.values[0])}`;
            return `Invalid option: expected one of ${b4(Y.values, "|")}`;
          case "too_big": {
            let W = Y.inclusive ? "<=" : "<", J = Q(Y.origin);
            if (J) return `Too big: expected ${Y.origin ?? "value"} to have ${W}${Y.maximum.toString()} ${J.unit ?? "elements"}`;
            return `Too big: expected ${Y.origin ?? "value"} to be ${W}${Y.maximum.toString()}`;
          }
          case "too_small": {
            let W = Y.inclusive ? ">=" : ">", J = Q(Y.origin);
            if (J) return `Too small: expected ${Y.origin} to have ${W}${Y.minimum.toString()} ${J.unit}`;
            return `Too small: expected ${Y.origin} to be ${W}${Y.minimum.toString()}`;
          }
          case "invalid_format": {
            let W = Y;
            if (W.format === "starts_with") return `Invalid string: must start with "${W.prefix}"`;
            if (W.format === "ends_with") return `Invalid string: must end with "${W.suffix}"`;
            if (W.format === "includes") return `Invalid string: must include "${W.includes}"`;
            if (W.format === "regex") return `Invalid string: must match pattern ${W.pattern}`;
            return `Invalid ${$[W.format] ?? Y.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${Y.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${Y.keys.length > 1 ? "s" : ""}: ${b4(Y.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${Y.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${Y.origin}`;
          default:
            return "Invalid input";
        }
      };
    };
    x4 = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
      }
      add(X, ...Q) {
        let $ = Q[0];
        if (this._map.set(X, $), $ && typeof $ === "object" && "id" in $) {
          if (this._idmap.has($.id)) throw Error(`ID ${$.id} already exists in the registry`);
          this._idmap.set($.id, X);
        }
        return this;
      }
      remove(X) {
        return this._map.delete(X), this;
      }
      get(X) {
        let Q = X._zod.parent;
        if (Q) {
          let $ = { ...this.get(Q) ?? {} };
          return delete $.id, { ...$, ...this._map.get(X) };
        }
        return this._map.get(X);
      }
      has(X) {
        return this._map.has(X);
      }
    };
    g1 = bJ();
    F$ = class {
      constructor(X) {
        this.counter = 0, this.metadataRegistry = X?.metadata ?? g1, this.target = X?.target ?? "draft-2020-12", this.unrepresentable = X?.unrepresentable ?? "throw", this.override = X?.override ?? (() => {
        }), this.io = X?.io ?? "output", this.seen = /* @__PURE__ */ new Map();
      }
      process(X, Q = { path: [], schemaPath: [] }) {
        var $;
        let Y = X._zod.def, W = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, J = this.seen.get(X);
        if (J) {
          if (J.count++, Q.schemaPath.includes(X)) J.cycle = Q.path;
          return J.schema;
        }
        let G = { schema: {}, count: 1, cycle: void 0, path: Q.path };
        this.seen.set(X, G);
        let H = X._zod.toJSONSchema?.();
        if (H) G.schema = H;
        else {
          let K = { ...Q, schemaPath: [...Q.schemaPath, X], path: Q.path }, V = X._zod.parent;
          if (V) G.ref = V, this.process(V, K), this.seen.get(V).isParent = true;
          else {
            let L = G.schema;
            switch (Y.type) {
              case "string": {
                let U = L;
                U.type = "string";
                let { minimum: F, maximum: q, format: N, patterns: A, contentEncoding: M } = X._zod.bag;
                if (typeof F === "number") U.minLength = F;
                if (typeof q === "number") U.maxLength = q;
                if (N) {
                  if (U.format = W[N] ?? N, U.format === "") delete U.format;
                }
                if (M) U.contentEncoding = M;
                if (A && A.size > 0) {
                  let R = [...A];
                  if (R.length === 1) U.pattern = R[0].source;
                  else if (R.length > 1) G.schema.allOf = [...R.map((S) => ({ ...this.target === "draft-7" ? { type: "string" } : {}, pattern: S.source }))];
                }
                break;
              }
              case "number": {
                let U = L, { minimum: F, maximum: q, format: N, multipleOf: A, exclusiveMaximum: M, exclusiveMinimum: R } = X._zod.bag;
                if (typeof N === "string" && N.includes("int")) U.type = "integer";
                else U.type = "number";
                if (typeof R === "number") U.exclusiveMinimum = R;
                if (typeof F === "number") {
                  if (U.minimum = F, typeof R === "number") if (R >= F) delete U.minimum;
                  else delete U.exclusiveMinimum;
                }
                if (typeof M === "number") U.exclusiveMaximum = M;
                if (typeof q === "number") {
                  if (U.maximum = q, typeof M === "number") if (M <= q) delete U.maximum;
                  else delete U.exclusiveMaximum;
                }
                if (typeof A === "number") U.multipleOf = A;
                break;
              }
              case "boolean": {
                let U = L;
                U.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
                break;
              }
              case "null": {
                L.type = "null";
                break;
              }
              case "any":
                break;
              case "unknown":
                break;
              case "undefined":
              case "never": {
                L.not = {};
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
                break;
              }
              case "array": {
                let U = L, { minimum: F, maximum: q } = X._zod.bag;
                if (typeof F === "number") U.minItems = F;
                if (typeof q === "number") U.maxItems = q;
                U.type = "array", U.items = this.process(Y.element, { ...K, path: [...K.path, "items"] });
                break;
              }
              case "object": {
                let U = L;
                U.type = "object", U.properties = {};
                let F = Y.shape;
                for (let A in F) U.properties[A] = this.process(F[A], { ...K, path: [...K.path, "properties", A] });
                let q = new Set(Object.keys(F)), N = new Set([...q].filter((A) => {
                  let M = Y.shape[A]._zod;
                  if (this.io === "input") return M.optin === void 0;
                  else return M.optout === void 0;
                }));
                if (N.size > 0) U.required = Array.from(N);
                if (Y.catchall?._zod.def.type === "never") U.additionalProperties = false;
                else if (!Y.catchall) {
                  if (this.io === "output") U.additionalProperties = false;
                } else if (Y.catchall) U.additionalProperties = this.process(Y.catchall, { ...K, path: [...K.path, "additionalProperties"] });
                break;
              }
              case "union": {
                let U = L;
                U.anyOf = Y.options.map((F, q) => this.process(F, { ...K, path: [...K.path, "anyOf", q] }));
                break;
              }
              case "intersection": {
                let U = L, F = this.process(Y.left, { ...K, path: [...K.path, "allOf", 0] }), q = this.process(Y.right, { ...K, path: [...K.path, "allOf", 1] }), N = (M) => "allOf" in M && Object.keys(M).length === 1, A = [...N(F) ? F.allOf : [F], ...N(q) ? q.allOf : [q]];
                U.allOf = A;
                break;
              }
              case "tuple": {
                let U = L;
                U.type = "array";
                let F = Y.items.map((A, M) => this.process(A, { ...K, path: [...K.path, "prefixItems", M] }));
                if (this.target === "draft-2020-12") U.prefixItems = F;
                else U.items = F;
                if (Y.rest) {
                  let A = this.process(Y.rest, { ...K, path: [...K.path, "items"] });
                  if (this.target === "draft-2020-12") U.items = A;
                  else U.additionalItems = A;
                }
                if (Y.rest) U.items = this.process(Y.rest, { ...K, path: [...K.path, "items"] });
                let { minimum: q, maximum: N } = X._zod.bag;
                if (typeof q === "number") U.minItems = q;
                if (typeof N === "number") U.maxItems = N;
                break;
              }
              case "record": {
                let U = L;
                U.type = "object", U.propertyNames = this.process(Y.keyType, { ...K, path: [...K.path, "propertyNames"] }), U.additionalProperties = this.process(Y.valueType, { ...K, path: [...K.path, "additionalProperties"] });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
                break;
              }
              case "enum": {
                let U = L, F = DX(Y.entries);
                if (F.every((q) => typeof q === "number")) U.type = "number";
                if (F.every((q) => typeof q === "string")) U.type = "string";
                U.enum = F;
                break;
              }
              case "literal": {
                let U = L, F = [];
                for (let q of Y.values) if (q === void 0) {
                  if (this.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
                } else if (typeof q === "bigint") if (this.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
                else F.push(Number(q));
                else F.push(q);
                if (F.length === 0) ;
                else if (F.length === 1) {
                  let q = F[0];
                  U.type = q === null ? "null" : typeof q, U.const = q;
                } else {
                  if (F.every((q) => typeof q === "number")) U.type = "number";
                  if (F.every((q) => typeof q === "string")) U.type = "string";
                  if (F.every((q) => typeof q === "boolean")) U.type = "string";
                  if (F.every((q) => q === null)) U.type = "null";
                  U.enum = F;
                }
                break;
              }
              case "file": {
                let U = L, F = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: q, maximum: N, mime: A } = X._zod.bag;
                if (q !== void 0) F.minLength = q;
                if (N !== void 0) F.maxLength = N;
                if (A) if (A.length === 1) F.contentMediaType = A[0], Object.assign(U, F);
                else U.anyOf = A.map((M) => {
                  return { ...F, contentMediaType: M };
                });
                else Object.assign(U, F);
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
                break;
              }
              case "nullable": {
                let U = this.process(Y.innerType, K);
                L.anyOf = [U, { type: "null" }];
                break;
              }
              case "nonoptional": {
                this.process(Y.innerType, K), G.ref = Y.innerType;
                break;
              }
              case "success": {
                let U = L;
                U.type = "boolean";
                break;
              }
              case "default": {
                this.process(Y.innerType, K), G.ref = Y.innerType, L.default = JSON.parse(JSON.stringify(Y.defaultValue));
                break;
              }
              case "prefault": {
                if (this.process(Y.innerType, K), G.ref = Y.innerType, this.io === "input") L._prefault = JSON.parse(JSON.stringify(Y.defaultValue));
                break;
              }
              case "catch": {
                this.process(Y.innerType, K), G.ref = Y.innerType;
                let U;
                try {
                  U = Y.catchValue(void 0);
                } catch {
                  throw Error("Dynamic catch values are not supported in JSON Schema");
                }
                L.default = U;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
                break;
              }
              case "template_literal": {
                let U = L, F = X._zod.pattern;
                if (!F) throw Error("Pattern not found in template literal");
                U.type = "string", U.pattern = F.source;
                break;
              }
              case "pipe": {
                let U = this.io === "input" ? Y.in._zod.def.type === "transform" ? Y.out : Y.in : Y.out;
                this.process(U, K), G.ref = U;
                break;
              }
              case "readonly": {
                this.process(Y.innerType, K), G.ref = Y.innerType, L.readOnly = true;
                break;
              }
              case "promise": {
                this.process(Y.innerType, K), G.ref = Y.innerType;
                break;
              }
              case "optional": {
                this.process(Y.innerType, K), G.ref = Y.innerType;
                break;
              }
              case "lazy": {
                let U = X._zod.innerType;
                this.process(U, K), G.ref = U;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
                break;
              }
              default:
            }
          }
        }
        let B = this.metadataRegistry.get(X);
        if (B) Object.assign(G.schema, B);
        if (this.io === "input" && A0(X)) delete G.schema.examples, delete G.schema.default;
        if (this.io === "input" && G.schema._prefault) ($ = G.schema).default ?? ($.default = G.schema._prefault);
        return delete G.schema._prefault, this.seen.get(X).schema;
      }
      emit(X, Q) {
        let $ = { cycles: Q?.cycles ?? "ref", reused: Q?.reused ?? "inline", external: Q?.external ?? void 0 }, Y = this.seen.get(X);
        if (!Y) throw Error("Unprocessed schema. This is a bug in Zod.");
        let W = (z2) => {
          let K = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if ($.external) {
            let F = $.external.registry.get(z2[0])?.id;
            if (F) return { ref: $.external.uri(F) };
            let q = z2[1].defId ?? z2[1].schema.id ?? `schema${this.counter++}`;
            return z2[1].defId = q, { defId: q, ref: `${$.external.uri("__shared")}#/${K}/${q}` };
          }
          if (z2[1] === Y) return { ref: "#" };
          let L = `${"#"}/${K}/`, U = z2[1].schema.id ?? `__schema${this.counter++}`;
          return { defId: U, ref: L + U };
        }, J = (z2) => {
          if (z2[1].schema.$ref) return;
          let K = z2[1], { ref: V, defId: L } = W(z2);
          if (K.def = { ...K.schema }, L) K.defId = L;
          let U = K.schema;
          for (let F in U) delete U[F];
          U.$ref = V;
        };
        for (let z2 of this.seen.entries()) {
          let K = z2[1];
          if (X === z2[0]) {
            J(z2);
            continue;
          }
          if ($.external) {
            let L = $.external.registry.get(z2[0])?.id;
            if (X !== z2[0] && L) {
              J(z2);
              continue;
            }
          }
          if (this.metadataRegistry.get(z2[0])?.id) {
            J(z2);
            continue;
          }
          if (K.cycle) {
            if ($.cycles === "throw") throw Error(`Cycle detected: #/${K.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            else if ($.cycles === "ref") J(z2);
            continue;
          }
          if (K.count > 1) {
            if ($.reused === "ref") {
              J(z2);
              continue;
            }
          }
        }
        let G = (z2, K) => {
          let V = this.seen.get(z2), L = V.def ?? V.schema, U = { ...L };
          if (V.ref === null) return;
          let F = V.ref;
          if (V.ref = null, F) {
            G(F, K);
            let q = this.seen.get(F).schema;
            if (q.$ref && K.target === "draft-7") L.allOf = L.allOf ?? [], L.allOf.push(q);
            else Object.assign(L, q), Object.assign(L, U);
          }
          if (!V.isParent) this.override({ zodSchema: z2, jsonSchema: L, path: V.path ?? [] });
        };
        for (let z2 of [...this.seen.entries()].reverse()) G(z2[0], { target: this.target });
        let H = {};
        if (this.target === "draft-2020-12") H.$schema = "https://json-schema.org/draft/2020-12/schema";
        else if (this.target === "draft-7") H.$schema = "http://json-schema.org/draft-07/schema#";
        else console.warn(`Invalid target: ${this.target}`);
        Object.assign(H, Y.def);
        let B = $.external?.defs ?? {};
        for (let z2 of this.seen.entries()) {
          let K = z2[1];
          if (K.def && K.defId) B[K.defId] = K.def;
        }
        if (!$.external && Object.keys(B).length > 0) if (this.target === "draft-2020-12") H.$defs = B;
        else H.definitions = B;
        try {
          return JSON.parse(JSON.stringify(H));
        } catch (z2) {
          throw Error("Error converting schema to JSON.");
        }
      }
    };
    TL = O("ZodMiniType", (X, Q) => {
      if (!X._zod) throw Error("Uninitialized schema in ZodMiniType.");
      X0.init(X, Q), X.def = Q, X.parse = ($, Y) => k9(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => X6(X, $, Y), X.parseAsync = async ($, Y) => T9(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => Q6(X, $, Y), X.check = (...$) => {
        return X.clone({ ...Q, checks: [...Q.checks ?? [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
      }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
        return $.add(X, Y), X;
      };
    });
    _L = O("ZodMiniObject", (X, Q) => {
      T4.init(X, Q), TL.init(X, Q), i.defineLazy(X, "shape", () => Q.shape);
    });
    SX = {};
    U7(SX, { time: () => w$, duration: () => M$, datetime: () => D$, date: () => A$, ZodISOTime: () => gJ, ZodISODuration: () => fJ, ZodISODateTime: () => xJ, ZodISODate: () => yJ });
    xJ = O("ZodISODateTime", (X, Q) => {
      MJ.init(X, Q), H0.init(X, Q);
    });
    yJ = O("ZodISODate", (X, Q) => {
      jJ.init(X, Q), H0.init(X, Q);
    });
    gJ = O("ZodISOTime", (X, Q) => {
      RJ.init(X, Q), H0.init(X, Q);
    });
    fJ = O("ZodISODuration", (X, Q) => {
      EJ.init(X, Q), H0.init(X, Q);
    });
    hJ = (X, Q) => {
      Z4.init(X, Q), X.name = "ZodError", Object.defineProperties(X, { format: { value: ($) => Z9(X, $) }, flatten: { value: ($) => S9(X, $) }, addIssue: { value: ($) => X.issues.push($) }, addIssues: { value: ($) => X.issues.push(...$) }, isEmpty: { get() {
        return X.issues.length === 0;
      } } });
    };
    WZ = O("ZodError", hJ);
    ZX = O("ZodError", hJ, { Parent: Error });
    uJ = C9(ZX);
    lJ = v9(ZX);
    mJ = _9(ZX);
    cJ = x9(ZX);
    z0 = O("ZodType", (X, Q) => {
      return X0.init(X, Q), X.def = Q, Object.defineProperty(X, "_def", { value: Q }), X.check = (...$) => {
        return X.clone({ ...Q, checks: [...Q.checks ?? [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
      }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
        return $.add(X, Y), X;
      }, X.parse = ($, Y) => uJ(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => mJ(X, $, Y), X.parseAsync = async ($, Y) => lJ(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => cJ(X, $, Y), X.spa = X.safeParseAsync, X.refine = ($, Y) => X.check(kq($, Y)), X.superRefine = ($) => X.check(vq($)), X.overwrite = ($) => X.check($6($)), X.optional = () => v(X), X.nullable = () => iJ(X), X.nullish = () => v(iJ(X)), X.nonoptional = ($) => Eq(X, $), X.array = () => r(X), X.or = ($) => J0([X, $]), X.and = ($) => i4(X, $), X.transform = ($) => R$(X, aJ($)), X.default = ($) => Mq(X, $), X.prefault = ($) => Rq(X, $), X.catch = ($) => bq(X, $), X.pipe = ($) => R$(X, $), X.readonly = () => Zq(X), X.describe = ($) => {
        let Y = X.clone();
        return g1.add(Y, { description: $ }), Y;
      }, Object.defineProperty(X, "description", { get() {
        return g1.get(X)?.description;
      }, configurable: true }), X.meta = (...$) => {
        if ($.length === 0) return g1.get(X);
        let Y = X.clone();
        return g1.add(Y, $[0]), Y;
      }, X.isOptional = () => X.safeParse(void 0).success, X.isNullable = () => X.safeParse(null).success, X;
    });
    nJ = O("_ZodString", (X, Q) => {
      IX.init(X, Q), z0.init(X, Q);
      let $ = X._zod.bag;
      X.format = $.format ?? null, X.minLength = $.minimum ?? null, X.maxLength = $.maximum ?? null, X.regex = (...Y) => X.check(Y$(...Y)), X.includes = (...Y) => X.check(G$(...Y)), X.startsWith = (...Y) => X.check(H$(...Y)), X.endsWith = (...Y) => X.check(B$(...Y)), X.min = (...Y) => X.check(k6(...Y)), X.max = (...Y) => X.check(u4(...Y)), X.length = (...Y) => X.check(l4(...Y)), X.nonempty = (...Y) => X.check(k6(1, ...Y)), X.lowercase = (Y) => X.check(W$(Y)), X.uppercase = (Y) => X.check(J$(Y)), X.trim = () => X.check(K$()), X.normalize = (...Y) => X.check(z$(...Y)), X.toLowerCase = () => X.check(U$()), X.toUpperCase = () => X.check(V$());
    });
    cL = O("ZodString", (X, Q) => {
      IX.init(X, Q), nJ.init(X, Q), X.email = ($) => X.check(CQ(pL, $)), X.url = ($) => X.check(xQ(dL, $)), X.jwt = ($) => X.check(tQ(Gq, $)), X.emoji = ($) => X.check(yQ(iL, $)), X.guid = ($) => X.check(y4(pJ, $)), X.uuid = ($) => X.check(kQ(d4, $)), X.uuidv4 = ($) => X.check(vQ(d4, $)), X.uuidv6 = ($) => X.check(TQ(d4, $)), X.uuidv7 = ($) => X.check(_Q(d4, $)), X.nanoid = ($) => X.check(gQ(nL, $)), X.guid = ($) => X.check(y4(pJ, $)), X.cuid = ($) => X.check(fQ(rL, $)), X.cuid2 = ($) => X.check(hQ(oL, $)), X.ulid = ($) => X.check(uQ(tL, $)), X.base64 = ($) => X.check(nQ(Yq, $)), X.base64url = ($) => X.check(rQ(Wq, $)), X.xid = ($) => X.check(lQ(aL, $)), X.ksuid = ($) => X.check(mQ(sL, $)), X.ipv4 = ($) => X.check(cQ(eL, $)), X.ipv6 = ($) => X.check(pQ(Xq, $)), X.cidrv4 = ($) => X.check(dQ(Qq, $)), X.cidrv6 = ($) => X.check(iQ($q, $)), X.e164 = ($) => X.check(oQ(Jq, $)), X.datetime = ($) => X.check(D$($)), X.date = ($) => X.check(A$($)), X.time = ($) => X.check(w$($)), X.duration = ($) => X.check(M$($));
    });
    H0 = O("ZodStringFormat", (X, Q) => {
      W0.init(X, Q), nJ.init(X, Q);
    });
    pL = O("ZodEmail", (X, Q) => {
      p9.init(X, Q), H0.init(X, Q);
    });
    pJ = O("ZodGUID", (X, Q) => {
      m9.init(X, Q), H0.init(X, Q);
    });
    d4 = O("ZodUUID", (X, Q) => {
      c9.init(X, Q), H0.init(X, Q);
    });
    dL = O("ZodURL", (X, Q) => {
      d9.init(X, Q), H0.init(X, Q);
    });
    iL = O("ZodEmoji", (X, Q) => {
      i9.init(X, Q), H0.init(X, Q);
    });
    nL = O("ZodNanoID", (X, Q) => {
      n9.init(X, Q), H0.init(X, Q);
    });
    rL = O("ZodCUID", (X, Q) => {
      r9.init(X, Q), H0.init(X, Q);
    });
    oL = O("ZodCUID2", (X, Q) => {
      o9.init(X, Q), H0.init(X, Q);
    });
    tL = O("ZodULID", (X, Q) => {
      t9.init(X, Q), H0.init(X, Q);
    });
    aL = O("ZodXID", (X, Q) => {
      a9.init(X, Q), H0.init(X, Q);
    });
    sL = O("ZodKSUID", (X, Q) => {
      s9.init(X, Q), H0.init(X, Q);
    });
    eL = O("ZodIPv4", (X, Q) => {
      e9.init(X, Q), H0.init(X, Q);
    });
    Xq = O("ZodIPv6", (X, Q) => {
      XQ.init(X, Q), H0.init(X, Q);
    });
    Qq = O("ZodCIDRv4", (X, Q) => {
      QQ.init(X, Q), H0.init(X, Q);
    });
    $q = O("ZodCIDRv6", (X, Q) => {
      $Q.init(X, Q), H0.init(X, Q);
    });
    Yq = O("ZodBase64", (X, Q) => {
      YQ.init(X, Q), H0.init(X, Q);
    });
    Wq = O("ZodBase64URL", (X, Q) => {
      WQ.init(X, Q), H0.init(X, Q);
    });
    Jq = O("ZodE164", (X, Q) => {
      JQ.init(X, Q), H0.init(X, Q);
    });
    Gq = O("ZodJWT", (X, Q) => {
      GQ.init(X, Q), H0.init(X, Q);
    });
    rJ = O("ZodNumber", (X, Q) => {
      v4.init(X, Q), z0.init(X, Q), X.gt = (Y, W) => X.check(f4(Y, W)), X.gte = (Y, W) => X.check(PX(Y, W)), X.min = (Y, W) => X.check(PX(Y, W)), X.lt = (Y, W) => X.check(g4(Y, W)), X.lte = (Y, W) => X.check(bX(Y, W)), X.max = (Y, W) => X.check(bX(Y, W)), X.int = (Y) => X.check(dJ(Y)), X.safe = (Y) => X.check(dJ(Y)), X.positive = (Y) => X.check(f4(0, Y)), X.nonnegative = (Y) => X.check(PX(0, Y)), X.negative = (Y) => X.check(g4(0, Y)), X.nonpositive = (Y) => X.check(bX(0, Y)), X.multipleOf = (Y, W) => X.check(h4(Y, W)), X.step = (Y, W) => X.check(h4(Y, W)), X.finite = () => X;
      let $ = X._zod.bag;
      X.minValue = Math.max($.minimum ?? Number.NEGATIVE_INFINITY, $.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, X.maxValue = Math.min($.maximum ?? Number.POSITIVE_INFINITY, $.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, X.isInt = ($.format ?? "").includes("int") || Number.isSafeInteger($.multipleOf ?? 0.5), X.isFinite = true, X.format = $.format ?? null;
    });
    Hq = O("ZodNumberFormat", (X, Q) => {
      HQ.init(X, Q), rJ.init(X, Q);
    });
    Bq = O("ZodBoolean", (X, Q) => {
      BQ.init(X, Q), z0.init(X, Q);
    });
    zq = O("ZodNull", (X, Q) => {
      zQ.init(X, Q), z0.init(X, Q);
    });
    Kq = O("ZodUnknown", (X, Q) => {
      KQ.init(X, Q), z0.init(X, Q);
    });
    Uq = O("ZodNever", (X, Q) => {
      UQ.init(X, Q), z0.init(X, Q);
    });
    Lq = O("ZodArray", (X, Q) => {
      VQ.init(X, Q), z0.init(X, Q), X.element = Q.element, X.min = ($, Y) => X.check(k6($, Y)), X.nonempty = ($) => X.check(k6(1, $)), X.max = ($, Y) => X.check(u4($, Y)), X.length = ($, Y) => X.check(l4($, Y)), X.unwrap = () => X.element;
    });
    oJ = O("ZodObject", (X, Q) => {
      T4.init(X, Q), z0.init(X, Q), i.defineLazy(X, "shape", () => Q.shape), X.keyof = () => j0(Object.keys(X._zod.def.shape)), X.catchall = ($) => X.clone({ ...X._zod.def, catchall: $ }), X.passthrough = () => X.clone({ ...X._zod.def, catchall: N0() }), X.loose = () => X.clone({ ...X._zod.def, catchall: N0() }), X.strict = () => X.clone({ ...X._zod.def, catchall: Vq() }), X.strip = () => X.clone({ ...X._zod.def, catchall: void 0 }), X.extend = ($) => {
        return i.extend(X, $);
      }, X.merge = ($) => i.merge(X, $), X.pick = ($) => i.pick(X, $), X.omit = ($) => i.omit(X, $), X.partial = (...$) => i.partial(sJ, X, $[0]), X.required = (...$) => i.required(eJ, X, $[0]);
    });
    tJ = O("ZodUnion", (X, Q) => {
      _4.init(X, Q), z0.init(X, Q), X.options = Q.options;
    });
    qq = O("ZodDiscriminatedUnion", (X, Q) => {
      tJ.init(X, Q), LQ.init(X, Q);
    });
    Fq = O("ZodIntersection", (X, Q) => {
      qQ.init(X, Q), z0.init(X, Q);
    });
    Nq = O("ZodRecord", (X, Q) => {
      FQ.init(X, Q), z0.init(X, Q), X.keyType = Q.keyType, X.valueType = Q.valueType;
    });
    j$ = O("ZodEnum", (X, Q) => {
      NQ.init(X, Q), z0.init(X, Q), X.enum = Q.entries, X.options = Object.values(Q.entries);
      let $ = new Set(Object.keys(Q.entries));
      X.extract = (Y, W) => {
        let J = {};
        for (let G of Y) if ($.has(G)) J[G] = Q.entries[G];
        else throw Error(`Key ${G} not found in enum`);
        return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
      }, X.exclude = (Y, W) => {
        let J = { ...Q.entries };
        for (let G of Y) if ($.has(G)) delete J[G];
        else throw Error(`Key ${G} not found in enum`);
        return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
      };
    });
    Oq = O("ZodLiteral", (X, Q) => {
      OQ.init(X, Q), z0.init(X, Q), X.values = new Set(Q.values), Object.defineProperty(X, "value", { get() {
        if (Q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
        return Q.values[0];
      } });
    });
    Dq = O("ZodTransform", (X, Q) => {
      DQ.init(X, Q), z0.init(X, Q), X._zod.parse = ($, Y) => {
        $.addIssue = (J) => {
          if (typeof J === "string") $.issues.push(i.issue(J, $.value, Q));
          else {
            let G = J;
            if (G.fatal) G.continue = false;
            G.code ?? (G.code = "custom"), G.input ?? (G.input = $.value), G.inst ?? (G.inst = X), G.continue ?? (G.continue = true), $.issues.push(i.issue(G));
          }
        };
        let W = Q.transform($.value, $);
        if (W instanceof Promise) return W.then((J) => {
          return $.value = J, $;
        });
        return $.value = W, $;
      };
    });
    sJ = O("ZodOptional", (X, Q) => {
      AQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
    });
    Aq = O("ZodNullable", (X, Q) => {
      wQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
    });
    wq = O("ZodDefault", (X, Q) => {
      MQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeDefault = X.unwrap;
    });
    jq = O("ZodPrefault", (X, Q) => {
      jQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
    });
    eJ = O("ZodNonOptional", (X, Q) => {
      RQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
    });
    Iq = O("ZodCatch", (X, Q) => {
      EQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeCatch = X.unwrap;
    });
    Pq = O("ZodPipe", (X, Q) => {
      IQ.init(X, Q), z0.init(X, Q), X.in = Q.in, X.out = Q.out;
    });
    Sq = O("ZodReadonly", (X, Q) => {
      bQ.init(X, Q), z0.init(X, Q);
    });
    X5 = O("ZodCustom", (X, Q) => {
      PQ.init(X, Q), z0.init(X, Q);
    });
    u0(SQ());
    P$ = "2025-11-25";
    $5 = [P$, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
    K1 = "io.modelcontextprotocol/related-task";
    r4 = "2.0";
    z1 = Q5((X) => X !== null && (typeof X === "object" || typeof X === "function"));
    Y5 = J0([D(), Q0().int()]);
    W5 = D();
    Tq = c0({ ttl: J0([Q0(), E$()]).optional(), pollInterval: Q0().optional() });
    S$ = c0({ taskId: D() });
    _q = c0({ progressToken: Y5.optional(), [K1]: S$.optional() });
    _0 = c0({ task: Tq.optional(), _meta: _q.optional() });
    R0 = I({ method: D(), params: _0.optional() });
    W6 = c0({ _meta: I({ [K1]: v(S$) }).passthrough().optional() });
    p0 = I({ method: D(), params: W6.optional() });
    b0 = c0({ _meta: c0({ [K1]: S$.optional() }).optional() });
    o4 = J0([D(), Q0().int()]);
    J5 = I({ jsonrpc: T(r4), id: o4, ...R0.shape }).strict();
    Z$ = (X) => J5.safeParse(X).success;
    G5 = I({ jsonrpc: T(r4), ...p0.shape }).strict();
    H5 = (X) => G5.safeParse(X).success;
    B5 = I({ jsonrpc: T(r4), id: o4, result: b0 }).strict();
    CX = (X) => B5.safeParse(X).success;
    (function(X) {
      X[X.ConnectionClosed = -32e3] = "ConnectionClosed", X[X.RequestTimeout = -32001] = "RequestTimeout", X[X.ParseError = -32700] = "ParseError", X[X.InvalidRequest = -32600] = "InvalidRequest", X[X.MethodNotFound = -32601] = "MethodNotFound", X[X.InvalidParams = -32602] = "InvalidParams", X[X.InternalError = -32603] = "InternalError", X[X.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
    })(x || (x = {}));
    z5 = I({ jsonrpc: T(r4), id: o4, error: I({ code: Q0().int(), message: D(), data: v(N0()) }) }).strict();
    K5 = (X) => z5.safeParse(X).success;
    DZ = J0([J5, G5, B5, z5]);
    t4 = b0.strict();
    xq = W6.extend({ requestId: o4, reason: D().optional() });
    a4 = p0.extend({ method: T("notifications/cancelled"), params: xq });
    yq = I({ src: D(), mimeType: D().optional(), sizes: r(D()).optional() });
    kX = I({ icons: r(yq).optional() });
    _6 = I({ name: D(), title: D().optional() });
    U5 = _6.extend({ ..._6.shape, ...kX.shape, version: D(), websiteUrl: D().optional() });
    gq = i4(I({ applyDefaults: M0().optional() }), O0(D(), N0()));
    fq = b$((X) => {
      if (X && typeof X === "object" && !Array.isArray(X)) {
        if (Object.keys(X).length === 0) return { form: {} };
      }
      return X;
    }, i4(I({ form: gq.optional(), url: z1.optional() }), O0(D(), N0()).optional()));
    hq = I({ list: v(I({}).passthrough()), cancel: v(I({}).passthrough()), requests: v(I({ sampling: v(I({ createMessage: v(I({}).passthrough()) }).passthrough()), elicitation: v(I({ create: v(I({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
    uq = I({ list: v(I({}).passthrough()), cancel: v(I({}).passthrough()), requests: v(I({ tools: v(I({ call: v(I({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
    lq = I({ experimental: O0(D(), z1).optional(), sampling: I({ context: z1.optional(), tools: z1.optional() }).optional(), elicitation: fq.optional(), roots: I({ listChanged: M0().optional() }).optional(), tasks: v(hq) });
    mq = _0.extend({ protocolVersion: D(), capabilities: lq, clientInfo: U5 });
    C$ = R0.extend({ method: T("initialize"), params: mq });
    cq = I({ experimental: O0(D(), z1).optional(), logging: z1.optional(), completions: z1.optional(), prompts: v(I({ listChanged: v(M0()) })), resources: I({ subscribe: M0().optional(), listChanged: M0().optional() }).optional(), tools: I({ listChanged: M0().optional() }).optional(), tasks: v(uq) }).passthrough();
    pq = b0.extend({ protocolVersion: D(), capabilities: cq, serverInfo: U5, instructions: D().optional() });
    k$ = p0.extend({ method: T("notifications/initialized") });
    s4 = R0.extend({ method: T("ping") });
    dq = I({ progress: Q0(), total: v(Q0()), message: v(D()) });
    iq = I({ ...W6.shape, ...dq.shape, progressToken: Y5 });
    e4 = p0.extend({ method: T("notifications/progress"), params: iq });
    nq = _0.extend({ cursor: W5.optional() });
    vX = R0.extend({ params: nq.optional() });
    TX = b0.extend({ nextCursor: v(W5) });
    _X = I({ taskId: D(), status: j0(["working", "input_required", "completed", "failed", "cancelled"]), ttl: J0([Q0(), E$()]), createdAt: D(), lastUpdatedAt: D(), pollInterval: v(Q0()), statusMessage: v(D()) });
    x6 = b0.extend({ task: _X });
    rq = W6.merge(_X);
    xX = p0.extend({ method: T("notifications/tasks/status"), params: rq });
    X8 = R0.extend({ method: T("tasks/get"), params: _0.extend({ taskId: D() }) });
    Q8 = b0.merge(_X);
    $8 = R0.extend({ method: T("tasks/result"), params: _0.extend({ taskId: D() }) });
    Y8 = vX.extend({ method: T("tasks/list") });
    W8 = TX.extend({ tasks: r(_X) });
    V5 = R0.extend({ method: T("tasks/cancel"), params: _0.extend({ taskId: D() }) });
    L5 = b0.merge(_X);
    q5 = I({ uri: D(), mimeType: v(D()), _meta: O0(D(), N0()).optional() });
    F5 = q5.extend({ text: D() });
    v$ = D().refine((X) => {
      try {
        return atob(X), true;
      } catch (Q) {
        return false;
      }
    }, { message: "Invalid Base64 string" });
    N5 = q5.extend({ blob: v$ });
    y6 = I({ audience: r(j0(["user", "assistant"])).optional(), priority: Q0().min(0).max(1).optional(), lastModified: SX.datetime({ offset: true }).optional() });
    O5 = I({ ..._6.shape, ...kX.shape, uri: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
    oq = I({ ..._6.shape, ...kX.shape, uriTemplate: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
    J8 = vX.extend({ method: T("resources/list") });
    tq = TX.extend({ resources: r(O5) });
    G8 = vX.extend({ method: T("resources/templates/list") });
    aq = TX.extend({ resourceTemplates: r(oq) });
    T$ = _0.extend({ uri: D() });
    sq = T$;
    H8 = R0.extend({ method: T("resources/read"), params: sq });
    eq = b0.extend({ contents: r(J0([F5, N5])) });
    XF = p0.extend({ method: T("notifications/resources/list_changed") });
    QF = T$;
    $F = R0.extend({ method: T("resources/subscribe"), params: QF });
    YF = T$;
    WF = R0.extend({ method: T("resources/unsubscribe"), params: YF });
    JF = W6.extend({ uri: D() });
    GF = p0.extend({ method: T("notifications/resources/updated"), params: JF });
    HF = I({ name: D(), description: v(D()), required: v(M0()) });
    BF = I({ ..._6.shape, ...kX.shape, description: v(D()), arguments: v(r(HF)), _meta: v(c0({})) });
    B8 = vX.extend({ method: T("prompts/list") });
    zF = TX.extend({ prompts: r(BF) });
    KF = _0.extend({ name: D(), arguments: O0(D(), D()).optional() });
    z8 = R0.extend({ method: T("prompts/get"), params: KF });
    _$ = I({ type: T("text"), text: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
    x$ = I({ type: T("image"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
    y$ = I({ type: T("audio"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
    UF = I({ type: T("tool_use"), name: D(), id: D(), input: I({}).passthrough(), _meta: v(I({}).passthrough()) }).passthrough();
    VF = I({ type: T("resource"), resource: J0([F5, N5]), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
    LF = O5.extend({ type: T("resource_link") });
    g$ = J0([_$, x$, y$, LF, VF]);
    qF = I({ role: j0(["user", "assistant"]), content: g$ });
    FF = b0.extend({ description: v(D()), messages: r(qF) });
    NF = p0.extend({ method: T("notifications/prompts/list_changed") });
    OF = I({ title: D().optional(), readOnlyHint: M0().optional(), destructiveHint: M0().optional(), idempotentHint: M0().optional(), openWorldHint: M0().optional() });
    DF = I({ taskSupport: j0(["required", "optional", "forbidden"]).optional() });
    D5 = I({ ..._6.shape, ...kX.shape, description: D().optional(), inputSchema: I({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()), outputSchema: I({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()).optional(), annotations: v(OF), execution: v(DF), _meta: O0(D(), N0()).optional() });
    K8 = vX.extend({ method: T("tools/list") });
    AF = TX.extend({ tools: r(D5) });
    U8 = b0.extend({ content: r(g$).default([]), structuredContent: O0(D(), N0()).optional(), isError: v(M0()) });
    AZ = U8.or(b0.extend({ toolResult: N0() }));
    wF = _0.extend({ name: D(), arguments: v(O0(D(), N0())) });
    g6 = R0.extend({ method: T("tools/call"), params: wF });
    MF = p0.extend({ method: T("notifications/tools/list_changed") });
    yX = j0(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
    jF = _0.extend({ level: yX });
    f$ = R0.extend({ method: T("logging/setLevel"), params: jF });
    RF = W6.extend({ level: yX, logger: D().optional(), data: N0() });
    EF = p0.extend({ method: T("notifications/message"), params: RF });
    IF = I({ name: D().optional() });
    bF = I({ hints: v(r(IF)), costPriority: v(Q0().min(0).max(1)), speedPriority: v(Q0().min(0).max(1)), intelligencePriority: v(Q0().min(0).max(1)) });
    PF = I({ mode: v(j0(["auto", "required", "none"])) });
    SF = I({ type: T("tool_result"), toolUseId: D().describe("The unique identifier for the corresponding tool call."), content: r(g$).default([]), structuredContent: I({}).passthrough().optional(), isError: v(M0()), _meta: v(I({}).passthrough()) }).passthrough();
    ZF = I$("type", [_$, x$, y$]);
    n4 = I$("type", [_$, x$, y$, UF, SF]);
    CF = I({ role: j0(["user", "assistant"]), content: J0([n4, r(n4)]), _meta: v(I({}).passthrough()) }).passthrough();
    kF = _0.extend({ messages: r(CF), modelPreferences: bF.optional(), systemPrompt: D().optional(), includeContext: j0(["none", "thisServer", "allServers"]).optional(), temperature: Q0().optional(), maxTokens: Q0().int(), stopSequences: r(D()).optional(), metadata: z1.optional(), tools: v(r(D5)), toolChoice: v(PF) });
    vF = R0.extend({ method: T("sampling/createMessage"), params: kF });
    h$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens"]).or(D())), role: j0(["user", "assistant"]), content: ZF });
    u$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(D())), role: j0(["user", "assistant"]), content: J0([n4, r(n4)]) });
    TF = I({ type: T("boolean"), title: D().optional(), description: D().optional(), default: M0().optional() });
    _F = I({ type: T("string"), title: D().optional(), description: D().optional(), minLength: Q0().optional(), maxLength: Q0().optional(), format: j0(["email", "uri", "date", "date-time"]).optional(), default: D().optional() });
    xF = I({ type: j0(["number", "integer"]), title: D().optional(), description: D().optional(), minimum: Q0().optional(), maximum: Q0().optional(), default: Q0().optional() });
    yF = I({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), default: D().optional() });
    gF = I({ type: T("string"), title: D().optional(), description: D().optional(), oneOf: r(I({ const: D(), title: D() })), default: D().optional() });
    fF = I({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), enumNames: r(D()).optional(), default: D().optional() });
    hF = J0([yF, gF]);
    uF = I({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: I({ type: T("string"), enum: r(D()) }), default: r(D()).optional() });
    lF = I({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: I({ anyOf: r(I({ const: D(), title: D() })) }), default: r(D()).optional() });
    mF = J0([uF, lF]);
    cF = J0([fF, hF, mF]);
    pF = J0([cF, TF, _F, xF]);
    dF = _0.extend({ mode: T("form").optional(), message: D(), requestedSchema: I({ type: T("object"), properties: O0(D(), pF), required: r(D()).optional() }) });
    iF = _0.extend({ mode: T("url"), message: D(), elicitationId: D(), url: D().url() });
    nF = J0([dF, iF]);
    rF = R0.extend({ method: T("elicitation/create"), params: nF });
    oF = W6.extend({ elicitationId: D() });
    tF = p0.extend({ method: T("notifications/elicitation/complete"), params: oF });
    V8 = b0.extend({ action: j0(["accept", "decline", "cancel"]), content: b$((X) => X === null ? void 0 : X, O0(D(), J0([D(), Q0(), M0(), r(D())])).optional()) });
    aF = I({ type: T("ref/resource"), uri: D() });
    sF = I({ type: T("ref/prompt"), name: D() });
    eF = _0.extend({ ref: J0([sF, aF]), argument: I({ name: D(), value: D() }), context: I({ arguments: O0(D(), D()).optional() }).optional() });
    L8 = R0.extend({ method: T("completion/complete"), params: eF });
    XN = b0.extend({ completion: c0({ values: r(D()).max(100), total: v(Q0().int()), hasMore: v(M0()) }) });
    QN = I({ uri: D().startsWith("file://"), name: D().optional(), _meta: O0(D(), N0()).optional() });
    $N = R0.extend({ method: T("roots/list") });
    l$ = b0.extend({ roots: r(QN) });
    YN = p0.extend({ method: T("notifications/roots/list_changed") });
    wZ = J0([s4, C$, L8, f$, z8, B8, J8, G8, H8, $F, WF, g6, K8, X8, $8, Y8]);
    MZ = J0([a4, e4, k$, YN, xX]);
    jZ = J0([t4, h$, u$, V8, l$, Q8, W8, x6]);
    RZ = J0([s4, vF, rF, $N, X8, $8, Y8]);
    EZ = J0([a4, e4, EF, GF, XF, MF, NF, xX, tF]);
    IZ = J0([t4, pq, XN, FF, zF, tq, aq, eq, U8, AF, Q8, W8, x6]);
    k = class _k extends Error {
      constructor(X, Q, $) {
        super(`MCP error ${X}: ${Q}`);
        this.code = X, this.data = $, this.name = "McpError";
      }
      static fromError(X, Q, $) {
        if (X === x.UrlElicitationRequired && $) {
          let Y = $;
          if (Y.elicitations) return new M5(Y.elicitations, Q);
        }
        return new _k(X, Q, $);
      }
    };
    M5 = class extends k {
      constructor(X, Q = `URL elicitation${X.length > 1 ? "s" : ""} required`) {
        super(x.UrlElicitationRequired, Q, { elicitations: X });
      }
      get elicitations() {
        var X, Q;
        return (Q = (X = this.data) === null || X === void 0 ? void 0 : X.elicitations) !== null && Q !== void 0 ? Q : [];
      }
    };
    R5 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
    j5 = { name: void 0, $refStrategy: "root", basePath: ["#"], effectStrategy: "input", pipeStrategy: "all", dateStrategy: "format:date-time", mapStrategy: "entries", removeAdditionalStrategy: "passthrough", allowedAdditionalProperties: true, rejectedAdditionalProperties: false, definitionPath: "definitions", target: "jsonSchema7", strictUnions: false, definitions: {}, errorMessages: false, markdownDescription: false, patternStrategy: "escape", applyRegexFlags: false, emailStrategy: "format:email", base64Strategy: "contentEncoding:base64", nameStrategy: "ref", openAiAnyTypeName: "OpenAiAnyType" };
    E5 = (X) => typeof X === "string" ? { ...j5, name: X } : { ...j5, ...X };
    I5 = (X) => {
      let Q = E5(X), $ = Q.name !== void 0 ? [...Q.basePath, Q.definitionPath, Q.name] : Q.basePath;
      return { ...Q, flags: { hasReferencedOpenAiAnyType: false }, currentPath: $, propertyPath: void 0, seen: new Map(Object.entries(Q.definitions).map(([Y, W]) => [W._def, { def: W._def, path: [...Q.basePath, Q.definitionPath, Y], jsonSchema: void 0 }])) };
    };
    q8 = (X, Q) => {
      let $ = 0;
      for (; $ < X.length && $ < Q.length; $++) if (X[$] !== Q[$]) break;
      return [(X.length - $).toString(), ...Q.slice($)].join("/");
    };
    Z5 = (X, Q) => {
      return f(X.innerType._def, Q);
    };
    WN = (X, Q) => {
      let $ = { type: "integer", format: "unix-time" };
      if (Q.target === "openApi3") return $;
      for (let Y of X.checks) switch (Y.kind) {
        case "min":
          o($, "minimum", Y.value, Y.message, Q);
          break;
        case "max":
          o($, "maximum", Y.value, Y.message, Q);
          break;
      }
      return $;
    };
    JN = (X) => {
      if ("type" in X && X.type === "string") return false;
      return "allOf" in X;
    };
    p$ = void 0;
    t0 = { cuid: /^[cC][^\s-]{8,}$/, cuid2: /^[0-9a-z]+$/, ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/, email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/, emoji: () => {
      if (p$ === void 0) p$ = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      return p$;
    }, uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/, ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, nanoid: /^[a-zA-Z0-9_-]{21}$/, jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/ };
    GN = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    gX = { ZodString: "string", ZodNumber: "number", ZodBigInt: "integer", ZodBoolean: "boolean", ZodNull: "null" };
    u5 = (X, Q) => {
      let $ = (X.options instanceof Map ? Array.from(X.options.values()) : X.options).map((Y, W) => f(Y._def, { ...Q, currentPath: [...Q.currentPath, "anyOf", `${W}`] })).filter((Y) => !!Y && (!Q.strictUnions || typeof Y === "object" && Object.keys(Y).length > 0));
      return $.length ? { anyOf: $ } : void 0;
    };
    d5 = (X, Q) => {
      if (Q.currentPath.toString() === Q.propertyPath?.toString()) return f(X.innerType._def, Q);
      let $ = f(X.innerType._def, { ...Q, currentPath: [...Q.currentPath, "anyOf", "1"] });
      return $ ? { anyOf: [{ not: B0(Q) }, $] } : B0(Q);
    };
    i5 = (X, Q) => {
      if (Q.pipeStrategy === "input") return f(X.in._def, Q);
      else if (Q.pipeStrategy === "output") return f(X.out._def, Q);
      let $ = f(X.in._def, { ...Q, currentPath: [...Q.currentPath, "allOf", "0"] }), Y = f(X.out._def, { ...Q, currentPath: [...Q.currentPath, "allOf", $ ? "1" : "0"] });
      return { allOf: [$, Y].filter((W) => W !== void 0) };
    };
    s5 = (X, Q) => {
      return f(X.innerType._def, Q);
    };
    e5 = (X, Q, $) => {
      switch (Q) {
        case j.ZodString:
          return N8(X, $);
        case j.ZodNumber:
          return c5(X, $);
        case j.ZodObject:
          return p5(X, $);
        case j.ZodBigInt:
          return P5(X, $);
        case j.ZodBoolean:
          return S5();
        case j.ZodDate:
          return c$(X, $);
        case j.ZodUndefined:
          return t5($);
        case j.ZodNull:
          return h5($);
        case j.ZodArray:
          return b5(X, $);
        case j.ZodUnion:
        case j.ZodDiscriminatedUnion:
          return l5(X, $);
        case j.ZodIntersection:
          return T5(X, $);
        case j.ZodTuple:
          return o5(X, $);
        case j.ZodRecord:
          return O8(X, $);
        case j.ZodLiteral:
          return _5(X, $);
        case j.ZodEnum:
          return v5(X);
        case j.ZodNativeEnum:
          return g5(X);
        case j.ZodNullable:
          return m5(X, $);
        case j.ZodOptional:
          return d5(X, $);
        case j.ZodMap:
          return y5(X, $);
        case j.ZodSet:
          return r5(X, $);
        case j.ZodLazy:
          return () => X.getter()._def;
        case j.ZodPromise:
          return n5(X, $);
        case j.ZodNaN:
        case j.ZodNever:
          return f5($);
        case j.ZodEffects:
          return k5(X, $);
        case j.ZodAny:
          return B0($);
        case j.ZodUnknown:
          return a5($);
        case j.ZodDefault:
          return C5(X, $);
        case j.ZodBranded:
          return F8(X, $);
        case j.ZodReadonly:
          return s5(X, $);
        case j.ZodCatch:
          return Z5(X, $);
        case j.ZodPipeline:
          return i5(X, $);
        case j.ZodFunction:
        case j.ZodVoid:
        case j.ZodSymbol:
          return;
        default:
          return /* @__PURE__ */ ((Y) => {
            return;
          })(Q);
      }
    };
    KN = (X, Q) => {
      switch (Q.$refStrategy) {
        case "root":
          return { $ref: X.path.join("/") };
        case "relative":
          return { $ref: q8(Q.currentPath, X.path) };
        case "none":
        case "seen": {
          if (X.path.length < Q.currentPath.length && X.path.every(($, Y) => Q.currentPath[Y] === $)) return console.warn(`Recursive reference detected at ${Q.currentPath.join("/")}! Defaulting to any`), B0(Q);
          return Q.$refStrategy === "seen" ? B0(Q) : void 0;
        }
      }
    };
    UN = (X, Q, $) => {
      if (X.description) {
        if ($.description = X.description, Q.markdownDescription) $.markdownDescription = X.description;
      }
      return $;
    };
    i$ = (X, Q) => {
      let $ = I5(Q), Y = typeof Q === "object" && Q.definitions ? Object.entries(Q.definitions).reduce((B, [z2, K]) => ({ ...B, [z2]: f(K._def, { ...$, currentPath: [...$.basePath, $.definitionPath, z2] }, true) ?? B0($) }), {}) : void 0, W = typeof Q === "string" ? Q : Q?.nameStrategy === "title" ? void 0 : Q?.name, J = f(X._def, W === void 0 ? $ : { ...$, currentPath: [...$.basePath, $.definitionPath, W] }, false) ?? B0($), G = typeof Q === "object" && Q.name !== void 0 && Q.nameStrategy === "title" ? Q.name : void 0;
      if (G !== void 0) J.title = G;
      if ($.flags.hasReferencedOpenAiAnyType) {
        if (!Y) Y = {};
        if (!Y[$.openAiAnyTypeName]) Y[$.openAiAnyTypeName] = { type: ["string", "number", "integer", "boolean", "array", "null"], items: { $ref: $.$refStrategy === "relative" ? "1" : [...$.basePath, $.definitionPath, $.openAiAnyTypeName].join("/") } };
      }
      let H = W === void 0 ? Y ? { ...J, [$.definitionPath]: Y } : J : { $ref: [...$.$refStrategy === "relative" ? [] : $.basePath, $.definitionPath, W].join("/"), [$.definitionPath]: { ...Y, [W]: J } };
      if ($.target === "jsonSchema7") H.$schema = "http://json-schema.org/draft-07/schema#";
      else if ($.target === "jsonSchema2019-09" || $.target === "openAi") H.$schema = "https://json-schema.org/draft/2019-09/schema#";
      if ($.target === "openAi" && ("anyOf" in H || "oneOf" in H || "allOf" in H || "type" in H && Array.isArray(H.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
      return H;
    };
    LN = 6e4;
    t$ = class {
      constructor(X) {
        if (this._options = X, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this._pendingDebouncedNotifications = /* @__PURE__ */ new Set(), this._taskProgressTokens = /* @__PURE__ */ new Map(), this._requestResolvers = /* @__PURE__ */ new Map(), this.setNotificationHandler(a4, (Q) => {
          this._oncancel(Q);
        }), this.setNotificationHandler(e4, (Q) => {
          this._onprogress(Q);
        }), this.setRequestHandler(s4, (Q) => ({})), this._taskStore = X === null || X === void 0 ? void 0 : X.taskStore, this._taskMessageQueue = X === null || X === void 0 ? void 0 : X.taskMessageQueue, this._taskStore) this.setRequestHandler(X8, async (Q, $) => {
          let Y = await this._taskStore.getTask(Q.params.taskId, $.sessionId);
          if (!Y) throw new k(x.InvalidParams, "Failed to retrieve task: Task not found");
          return { ...Y };
        }), this.setRequestHandler($8, async (Q, $) => {
          let Y = async () => {
            var W;
            let J = Q.params.taskId;
            if (this._taskMessageQueue) {
              let H;
              while (H = await this._taskMessageQueue.dequeue(J, $.sessionId)) {
                if (H.type === "response" || H.type === "error") {
                  let B = H.message, z2 = B.id, K = this._requestResolvers.get(z2);
                  if (K) if (this._requestResolvers.delete(z2), H.type === "response") K(B);
                  else {
                    let V = B, L = new k(V.error.code, V.error.message, V.error.data);
                    K(L);
                  }
                  else {
                    let V = H.type === "response" ? "Response" : "Error";
                    this._onerror(Error(`${V} handler missing for request ${z2}`));
                  }
                  continue;
                }
                await ((W = this._transport) === null || W === void 0 ? void 0 : W.send(H.message, { relatedRequestId: $.requestId }));
              }
            }
            let G = await this._taskStore.getTask(J, $.sessionId);
            if (!G) throw new k(x.InvalidParams, `Task not found: ${J}`);
            if (!u1(G.status)) return await this._waitForTaskUpdate(J, $.signal), await Y();
            if (u1(G.status)) {
              let H = await this._taskStore.getTaskResult(J, $.sessionId);
              return this._clearTaskQueue(J), { ...H, _meta: { ...H._meta, [K1]: { taskId: J } } };
            }
            return await Y();
          };
          return await Y();
        }), this.setRequestHandler(Y8, async (Q, $) => {
          var Y;
          try {
            let { tasks: W, nextCursor: J } = await this._taskStore.listTasks((Y = Q.params) === null || Y === void 0 ? void 0 : Y.cursor, $.sessionId);
            return { tasks: W, nextCursor: J, _meta: {} };
          } catch (W) {
            throw new k(x.InvalidParams, `Failed to list tasks: ${W instanceof Error ? W.message : String(W)}`);
          }
        }), this.setRequestHandler(V5, async (Q, $) => {
          try {
            let Y = await this._taskStore.getTask(Q.params.taskId, $.sessionId);
            if (!Y) throw new k(x.InvalidParams, `Task not found: ${Q.params.taskId}`);
            if (u1(Y.status)) throw new k(x.InvalidParams, `Cannot cancel task in terminal status: ${Y.status}`);
            await this._taskStore.updateTaskStatus(Q.params.taskId, "cancelled", "Client cancelled task execution.", $.sessionId), this._clearTaskQueue(Q.params.taskId);
            let W = await this._taskStore.getTask(Q.params.taskId, $.sessionId);
            if (!W) throw new k(x.InvalidParams, `Task not found after cancellation: ${Q.params.taskId}`);
            return { _meta: {}, ...W };
          } catch (Y) {
            if (Y instanceof k) throw Y;
            throw new k(x.InvalidRequest, `Failed to cancel task: ${Y instanceof Error ? Y.message : String(Y)}`);
          }
        });
      }
      async _oncancel(X) {
        let Q = this._requestHandlerAbortControllers.get(X.params.requestId);
        Q === null || Q === void 0 || Q.abort(X.params.reason);
      }
      _setupTimeout(X, Q, $, Y, W = false) {
        this._timeoutInfo.set(X, { timeoutId: setTimeout(Y, Q), startTime: Date.now(), timeout: Q, maxTotalTimeout: $, resetTimeoutOnProgress: W, onTimeout: Y });
      }
      _resetTimeout(X) {
        let Q = this._timeoutInfo.get(X);
        if (!Q) return false;
        let $ = Date.now() - Q.startTime;
        if (Q.maxTotalTimeout && $ >= Q.maxTotalTimeout) throw this._timeoutInfo.delete(X), k.fromError(x.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: Q.maxTotalTimeout, totalElapsed: $ });
        return clearTimeout(Q.timeoutId), Q.timeoutId = setTimeout(Q.onTimeout, Q.timeout), true;
      }
      _cleanupTimeout(X) {
        let Q = this._timeoutInfo.get(X);
        if (Q) clearTimeout(Q.timeoutId), this._timeoutInfo.delete(X);
      }
      async connect(X) {
        var Q, $, Y;
        this._transport = X;
        let W = (Q = this.transport) === null || Q === void 0 ? void 0 : Q.onclose;
        this._transport.onclose = () => {
          W === null || W === void 0 || W(), this._onclose();
        };
        let J = ($ = this.transport) === null || $ === void 0 ? void 0 : $.onerror;
        this._transport.onerror = (H) => {
          J === null || J === void 0 || J(H), this._onerror(H);
        };
        let G = (Y = this._transport) === null || Y === void 0 ? void 0 : Y.onmessage;
        this._transport.onmessage = (H, B) => {
          if (G === null || G === void 0 || G(H, B), CX(H) || K5(H)) this._onresponse(H);
          else if (Z$(H)) this._onrequest(H, B);
          else if (H5(H)) this._onnotification(H);
          else this._onerror(Error(`Unknown message type: ${JSON.stringify(H)}`));
        }, await this._transport.start();
      }
      _onclose() {
        var X;
        let Q = this._responseHandlers;
        this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
        let $ = k.fromError(x.ConnectionClosed, "Connection closed");
        this._transport = void 0, (X = this.onclose) === null || X === void 0 || X.call(this);
        for (let Y of Q.values()) Y($);
      }
      _onerror(X) {
        var Q;
        (Q = this.onerror) === null || Q === void 0 || Q.call(this, X);
      }
      _onnotification(X) {
        var Q;
        let $ = (Q = this._notificationHandlers.get(X.method)) !== null && Q !== void 0 ? Q : this.fallbackNotificationHandler;
        if ($ === void 0) return;
        Promise.resolve().then(() => $(X)).catch((Y) => this._onerror(Error(`Uncaught error in notification handler: ${Y}`)));
      }
      _onrequest(X, Q) {
        var $, Y, W, J, G, H;
        let B = ($ = this._requestHandlers.get(X.method)) !== null && $ !== void 0 ? $ : this.fallbackRequestHandler, z2 = this._transport, K = (J = (W = (Y = X.params) === null || Y === void 0 ? void 0 : Y._meta) === null || W === void 0 ? void 0 : W[K1]) === null || J === void 0 ? void 0 : J.taskId;
        if (B === void 0) {
          let q = { jsonrpc: "2.0", id: X.id, error: { code: x.MethodNotFound, message: "Method not found" } };
          if (K && this._taskMessageQueue) this._enqueueTaskMessage(K, { type: "error", message: q, timestamp: Date.now() }, z2 === null || z2 === void 0 ? void 0 : z2.sessionId).catch((N) => this._onerror(Error(`Failed to enqueue error response: ${N}`)));
          else z2 === null || z2 === void 0 || z2.send(q).catch((N) => this._onerror(Error(`Failed to send an error response: ${N}`)));
          return;
        }
        let V = new AbortController();
        this._requestHandlerAbortControllers.set(X.id, V);
        let L = (G = X.params) === null || G === void 0 ? void 0 : G.task, U = this._taskStore ? this.requestTaskStore(X, z2 === null || z2 === void 0 ? void 0 : z2.sessionId) : void 0, F = { signal: V.signal, sessionId: z2 === null || z2 === void 0 ? void 0 : z2.sessionId, _meta: (H = X.params) === null || H === void 0 ? void 0 : H._meta, sendNotification: async (q) => {
          let N = { relatedRequestId: X.id };
          if (K) N.relatedTask = { taskId: K };
          await this.notification(q, N);
        }, sendRequest: async (q, N, A) => {
          var M, R;
          let S = { ...A, relatedRequestId: X.id };
          if (K && !S.relatedTask) S.relatedTask = { taskId: K };
          let C = (R = (M = S.relatedTask) === null || M === void 0 ? void 0 : M.taskId) !== null && R !== void 0 ? R : K;
          if (C && U) await U.updateTaskStatus(C, "input_required");
          return await this.request(q, N, S);
        }, authInfo: Q === null || Q === void 0 ? void 0 : Q.authInfo, requestId: X.id, requestInfo: Q === null || Q === void 0 ? void 0 : Q.requestInfo, taskId: K, taskStore: U, taskRequestedTtl: L === null || L === void 0 ? void 0 : L.ttl, closeSSEStream: Q === null || Q === void 0 ? void 0 : Q.closeSSEStream, closeStandaloneSSEStream: Q === null || Q === void 0 ? void 0 : Q.closeStandaloneSSEStream };
        Promise.resolve().then(() => {
          if (L) this.assertTaskHandlerCapability(X.method);
        }).then(() => B(X, F)).then(async (q) => {
          if (V.signal.aborted) return;
          let N = { result: q, jsonrpc: "2.0", id: X.id };
          if (K && this._taskMessageQueue) await this._enqueueTaskMessage(K, { type: "response", message: N, timestamp: Date.now() }, z2 === null || z2 === void 0 ? void 0 : z2.sessionId);
          else await (z2 === null || z2 === void 0 ? void 0 : z2.send(N));
        }, async (q) => {
          var N;
          if (V.signal.aborted) return;
          let A = { jsonrpc: "2.0", id: X.id, error: { code: Number.isSafeInteger(q.code) ? q.code : x.InternalError, message: (N = q.message) !== null && N !== void 0 ? N : "Internal error", ...q.data !== void 0 && { data: q.data } } };
          if (K && this._taskMessageQueue) await this._enqueueTaskMessage(K, { type: "error", message: A, timestamp: Date.now() }, z2 === null || z2 === void 0 ? void 0 : z2.sessionId);
          else await (z2 === null || z2 === void 0 ? void 0 : z2.send(A));
        }).catch((q) => this._onerror(Error(`Failed to send response: ${q}`))).finally(() => {
          this._requestHandlerAbortControllers.delete(X.id);
        });
      }
      _onprogress(X) {
        let { progressToken: Q, ...$ } = X.params, Y = Number(Q), W = this._progressHandlers.get(Y);
        if (!W) {
          this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(X)}`));
          return;
        }
        let J = this._responseHandlers.get(Y), G = this._timeoutInfo.get(Y);
        if (G && J && G.resetTimeoutOnProgress) try {
          this._resetTimeout(Y);
        } catch (H) {
          this._responseHandlers.delete(Y), this._progressHandlers.delete(Y), this._cleanupTimeout(Y), J(H);
          return;
        }
        W($);
      }
      _onresponse(X) {
        let Q = Number(X.id), $ = this._requestResolvers.get(Q);
        if ($) {
          if (this._requestResolvers.delete(Q), CX(X)) $(X);
          else {
            let J = new k(X.error.code, X.error.message, X.error.data);
            $(J);
          }
          return;
        }
        let Y = this._responseHandlers.get(Q);
        if (Y === void 0) {
          this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(X)}`));
          return;
        }
        this._responseHandlers.delete(Q), this._cleanupTimeout(Q);
        let W = false;
        if (CX(X) && X.result && typeof X.result === "object") {
          let J = X.result;
          if (J.task && typeof J.task === "object") {
            let G = J.task;
            if (typeof G.taskId === "string") W = true, this._taskProgressTokens.set(G.taskId, Q);
          }
        }
        if (!W) this._progressHandlers.delete(Q);
        if (CX(X)) Y(X);
        else {
          let J = k.fromError(X.error.code, X.error.message, X.error.data);
          Y(J);
        }
      }
      get transport() {
        return this._transport;
      }
      async close() {
        var X;
        await ((X = this._transport) === null || X === void 0 ? void 0 : X.close());
      }
      async *requestStream(X, Q, $) {
        var Y, W, J, G;
        let { task: H } = $ !== null && $ !== void 0 ? $ : {};
        if (!H) {
          try {
            yield { type: "result", result: await this.request(X, Q, $) };
          } catch (z2) {
            yield { type: "error", error: z2 instanceof k ? z2 : new k(x.InternalError, String(z2)) };
          }
          return;
        }
        let B;
        try {
          let z2 = await this.request(X, x6, $);
          if (z2.task) B = z2.task.taskId, yield { type: "taskCreated", task: z2.task };
          else throw new k(x.InternalError, "Task creation did not return a task");
          while (true) {
            let K = await this.getTask({ taskId: B }, $);
            if (yield { type: "taskStatus", task: K }, u1(K.status)) {
              if (K.status === "completed") yield { type: "result", result: await this.getTaskResult({ taskId: B }, Q, $) };
              else if (K.status === "failed") yield { type: "error", error: new k(x.InternalError, `Task ${B} failed`) };
              else if (K.status === "cancelled") yield { type: "error", error: new k(x.InternalError, `Task ${B} was cancelled`) };
              return;
            }
            if (K.status === "input_required") {
              yield { type: "result", result: await this.getTaskResult({ taskId: B }, Q, $) };
              return;
            }
            let V = (J = (Y = K.pollInterval) !== null && Y !== void 0 ? Y : (W = this._options) === null || W === void 0 ? void 0 : W.defaultTaskPollInterval) !== null && J !== void 0 ? J : 1e3;
            await new Promise((L) => setTimeout(L, V)), (G = $ === null || $ === void 0 ? void 0 : $.signal) === null || G === void 0 || G.throwIfAborted();
          }
        } catch (z2) {
          yield { type: "error", error: z2 instanceof k ? z2 : new k(x.InternalError, String(z2)) };
        }
      }
      request(X, Q, $) {
        let { relatedRequestId: Y, resumptionToken: W, onresumptiontoken: J, task: G, relatedTask: H } = $ !== null && $ !== void 0 ? $ : {};
        return new Promise((B, z2) => {
          var K, V, L, U, F, q, N;
          let A = (s) => {
            z2(s);
          };
          if (!this._transport) {
            A(Error("Not connected"));
            return;
          }
          if (((K = this._options) === null || K === void 0 ? void 0 : K.enforceStrictCapabilities) === true) try {
            if (this.assertCapabilityForMethod(X.method), G) this.assertTaskCapability(X.method);
          } catch (s) {
            A(s);
            return;
          }
          (V = $ === null || $ === void 0 ? void 0 : $.signal) === null || V === void 0 || V.throwIfAborted();
          let M = this._requestMessageId++, R = { ...X, jsonrpc: "2.0", id: M };
          if ($ === null || $ === void 0 ? void 0 : $.onprogress) this._progressHandlers.set(M, $.onprogress), R.params = { ...X.params, _meta: { ...((L = X.params) === null || L === void 0 ? void 0 : L._meta) || {}, progressToken: M } };
          if (G) R.params = { ...R.params, task: G };
          if (H) R.params = { ...R.params, _meta: { ...((U = R.params) === null || U === void 0 ? void 0 : U._meta) || {}, [K1]: H } };
          let S = (s) => {
            var D0;
            this._responseHandlers.delete(M), this._progressHandlers.delete(M), this._cleanupTimeout(M), (D0 = this._transport) === null || D0 === void 0 || D0.send({ jsonrpc: "2.0", method: "notifications/cancelled", params: { requestId: M, reason: String(s) } }, { relatedRequestId: Y, resumptionToken: W, onresumptiontoken: J }).catch((W1) => this._onerror(Error(`Failed to send cancellation: ${W1}`)));
            let q0 = s instanceof k ? s : new k(x.RequestTimeout, String(s));
            z2(q0);
          };
          this._responseHandlers.set(M, (s) => {
            var D0;
            if ((D0 = $ === null || $ === void 0 ? void 0 : $.signal) === null || D0 === void 0 ? void 0 : D0.aborted) return;
            if (s instanceof Error) return z2(s);
            try {
              let q0 = f1(Q, s.result);
              if (!q0.success) z2(q0.error);
              else B(q0.data);
            } catch (q0) {
              z2(q0);
            }
          }), (F = $ === null || $ === void 0 ? void 0 : $.signal) === null || F === void 0 || F.addEventListener("abort", () => {
            var s;
            S((s = $ === null || $ === void 0 ? void 0 : $.signal) === null || s === void 0 ? void 0 : s.reason);
          });
          let C = (q = $ === null || $ === void 0 ? void 0 : $.timeout) !== null && q !== void 0 ? q : LN, K0 = () => S(k.fromError(x.RequestTimeout, "Request timed out", { timeout: C }));
          this._setupTimeout(M, C, $ === null || $ === void 0 ? void 0 : $.maxTotalTimeout, K0, (N = $ === null || $ === void 0 ? void 0 : $.resetTimeoutOnProgress) !== null && N !== void 0 ? N : false);
          let U0 = H === null || H === void 0 ? void 0 : H.taskId;
          if (U0) {
            let s = (D0) => {
              let q0 = this._responseHandlers.get(M);
              if (q0) q0(D0);
              else this._onerror(Error(`Response handler missing for side-channeled request ${M}`));
            };
            this._requestResolvers.set(M, s), this._enqueueTaskMessage(U0, { type: "request", message: R, timestamp: Date.now() }).catch((D0) => {
              this._cleanupTimeout(M), z2(D0);
            });
          } else this._transport.send(R, { relatedRequestId: Y, resumptionToken: W, onresumptiontoken: J }).catch((s) => {
            this._cleanupTimeout(M), z2(s);
          });
        });
      }
      async getTask(X, Q) {
        return this.request({ method: "tasks/get", params: X }, Q8, Q);
      }
      async getTaskResult(X, Q, $) {
        return this.request({ method: "tasks/result", params: X }, Q, $);
      }
      async listTasks(X, Q) {
        return this.request({ method: "tasks/list", params: X }, W8, Q);
      }
      async cancelTask(X, Q) {
        return this.request({ method: "tasks/cancel", params: X }, L5, Q);
      }
      async notification(X, Q) {
        var $, Y, W, J, G;
        if (!this._transport) throw Error("Not connected");
        this.assertNotificationCapability(X.method);
        let H = ($ = Q === null || Q === void 0 ? void 0 : Q.relatedTask) === null || $ === void 0 ? void 0 : $.taskId;
        if (H) {
          let V = { ...X, jsonrpc: "2.0", params: { ...X.params, _meta: { ...((Y = X.params) === null || Y === void 0 ? void 0 : Y._meta) || {}, [K1]: Q.relatedTask } } };
          await this._enqueueTaskMessage(H, { type: "notification", message: V, timestamp: Date.now() });
          return;
        }
        if (((J = (W = this._options) === null || W === void 0 ? void 0 : W.debouncedNotificationMethods) !== null && J !== void 0 ? J : []).includes(X.method) && !X.params && !(Q === null || Q === void 0 ? void 0 : Q.relatedRequestId) && !(Q === null || Q === void 0 ? void 0 : Q.relatedTask)) {
          if (this._pendingDebouncedNotifications.has(X.method)) return;
          this._pendingDebouncedNotifications.add(X.method), Promise.resolve().then(() => {
            var V, L;
            if (this._pendingDebouncedNotifications.delete(X.method), !this._transport) return;
            let U = { ...X, jsonrpc: "2.0" };
            if (Q === null || Q === void 0 ? void 0 : Q.relatedTask) U = { ...U, params: { ...U.params, _meta: { ...((V = U.params) === null || V === void 0 ? void 0 : V._meta) || {}, [K1]: Q.relatedTask } } };
            (L = this._transport) === null || L === void 0 || L.send(U, Q).catch((F) => this._onerror(F));
          });
          return;
        }
        let K = { ...X, jsonrpc: "2.0" };
        if (Q === null || Q === void 0 ? void 0 : Q.relatedTask) K = { ...K, params: { ...K.params, _meta: { ...((G = K.params) === null || G === void 0 ? void 0 : G._meta) || {}, [K1]: Q.relatedTask } } };
        await this._transport.send(K, Q);
      }
      setRequestHandler(X, Q) {
        let $ = r$(X);
        this.assertRequestHandlerCapability($), this._requestHandlers.set($, (Y, W) => {
          let J = o$(X, Y);
          return Promise.resolve(Q(J, W));
        });
      }
      removeRequestHandler(X) {
        this._requestHandlers.delete(X);
      }
      assertCanSetRequestHandler(X) {
        if (this._requestHandlers.has(X)) throw Error(`A request handler for ${X} already exists, which would be overridden`);
      }
      setNotificationHandler(X, Q) {
        let $ = r$(X);
        this._notificationHandlers.set($, (Y) => {
          let W = o$(X, Y);
          return Promise.resolve(Q(W));
        });
      }
      removeNotificationHandler(X) {
        this._notificationHandlers.delete(X);
      }
      _cleanupTaskProgressHandler(X) {
        let Q = this._taskProgressTokens.get(X);
        if (Q !== void 0) this._progressHandlers.delete(Q), this._taskProgressTokens.delete(X);
      }
      async _enqueueTaskMessage(X, Q, $) {
        var Y;
        if (!this._taskStore || !this._taskMessageQueue) throw Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
        let W = (Y = this._options) === null || Y === void 0 ? void 0 : Y.maxTaskQueueSize;
        await this._taskMessageQueue.enqueue(X, Q, $, W);
      }
      async _clearTaskQueue(X, Q) {
        if (this._taskMessageQueue) {
          let $ = await this._taskMessageQueue.dequeueAll(X, Q);
          for (let Y of $) if (Y.type === "request" && Z$(Y.message)) {
            let W = Y.message.id, J = this._requestResolvers.get(W);
            if (J) J(new k(x.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(W);
            else this._onerror(Error(`Resolver missing for request ${W} during task ${X} cleanup`));
          }
        }
      }
      async _waitForTaskUpdate(X, Q) {
        var $, Y, W;
        let J = (Y = ($ = this._options) === null || $ === void 0 ? void 0 : $.defaultTaskPollInterval) !== null && Y !== void 0 ? Y : 1e3;
        try {
          let G = await ((W = this._taskStore) === null || W === void 0 ? void 0 : W.getTask(X));
          if (G === null || G === void 0 ? void 0 : G.pollInterval) J = G.pollInterval;
        } catch (G) {
        }
        return new Promise((G, H) => {
          if (Q.aborted) {
            H(new k(x.InvalidRequest, "Request cancelled"));
            return;
          }
          let B = setTimeout(G, J);
          Q.addEventListener("abort", () => {
            clearTimeout(B), H(new k(x.InvalidRequest, "Request cancelled"));
          }, { once: true });
        });
      }
      requestTaskStore(X, Q) {
        let $ = this._taskStore;
        if (!$) throw Error("No task store configured");
        return { createTask: async (Y) => {
          if (!X) throw Error("No request provided");
          return await $.createTask(Y, X.id, { method: X.method, params: X.params }, Q);
        }, getTask: async (Y) => {
          let W = await $.getTask(Y, Q);
          if (!W) throw new k(x.InvalidParams, "Failed to retrieve task: Task not found");
          return W;
        }, storeTaskResult: async (Y, W, J) => {
          await $.storeTaskResult(Y, W, J, Q);
          let G = await $.getTask(Y, Q);
          if (G) {
            let H = xX.parse({ method: "notifications/tasks/status", params: G });
            if (await this.notification(H), u1(G.status)) this._cleanupTaskProgressHandler(Y);
          }
        }, getTaskResult: (Y) => {
          return $.getTaskResult(Y, Q);
        }, updateTaskStatus: async (Y, W, J) => {
          let G = await $.getTask(Y, Q);
          if (!G) throw new k(x.InvalidParams, `Task "${Y}" not found - it may have been cleaned up`);
          if (u1(G.status)) throw new k(x.InvalidParams, `Cannot update task "${Y}" from terminal status "${G.status}" to "${W}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
          await $.updateTaskStatus(Y, W, J, Q);
          let H = await $.getTask(Y, Q);
          if (H) {
            let B = xX.parse({ method: "notifications/tasks/status", params: H });
            if (await this.notification(B), u1(H.status)) this._cleanupTaskProgressHandler(Y);
          }
        }, listTasks: (Y) => {
          return $.listTasks(Y, Q);
        } };
      }
    };
    fz = K7(cY(), 1);
    hz = K7(gz(), 1);
    eY = class {
      constructor(X) {
        this._ajv = X !== null && X !== void 0 ? X : ME();
      }
      getValidator(X) {
        var Q;
        let $ = "$id" in X && typeof X.$id === "string" ? (Q = this._ajv.getSchema(X.$id)) !== null && Q !== void 0 ? Q : this._ajv.compile(X) : this._ajv.compile(X);
        return (Y) => {
          if ($(Y)) return { valid: true, data: Y, errorMessage: void 0 };
          else return { valid: false, data: void 0, errorMessage: this._ajv.errorsText($.errors) };
        };
      }
    };
    X7 = class {
      constructor(X) {
        this._server = X;
      }
      requestStream(X, Q, $) {
        return this._server.requestStream(X, Q, $);
      }
      async getTask(X, Q) {
        return this._server.getTask({ taskId: X }, Q);
      }
      async getTaskResult(X, Q, $) {
        return this._server.getTaskResult({ taskId: X }, Q, $);
      }
      async listTasks(X, Q) {
        return this._server.listTasks(X ? { cursor: X } : void 0, Q);
      }
      async cancelTask(X, Q) {
        return this._server.cancelTask({ taskId: X }, Q);
      }
    };
    Q7 = class extends t$ {
      constructor(X, Q) {
        var $, Y;
        super(Q);
        if (this._serverInfo = X, this._loggingLevels = /* @__PURE__ */ new Map(), this.LOG_LEVEL_SEVERITY = new Map(yX.options.map((W, J) => [W, J])), this.isMessageIgnored = (W, J) => {
          let G = this._loggingLevels.get(J);
          return G ? this.LOG_LEVEL_SEVERITY.get(W) < this.LOG_LEVEL_SEVERITY.get(G) : false;
        }, this._capabilities = ($ = Q === null || Q === void 0 ? void 0 : Q.capabilities) !== null && $ !== void 0 ? $ : {}, this._instructions = Q === null || Q === void 0 ? void 0 : Q.instructions, this._jsonSchemaValidator = (Y = Q === null || Q === void 0 ? void 0 : Q.jsonSchemaValidator) !== null && Y !== void 0 ? Y : new eY(), this.setRequestHandler(C$, (W) => this._oninitialize(W)), this.setNotificationHandler(k$, () => {
          var W;
          return (W = this.oninitialized) === null || W === void 0 ? void 0 : W.call(this);
        }), this._capabilities.logging) this.setRequestHandler(f$, async (W, J) => {
          var G;
          let H = J.sessionId || ((G = J.requestInfo) === null || G === void 0 ? void 0 : G.headers["mcp-session-id"]) || void 0, { level: B } = W.params, z2 = yX.safeParse(B);
          if (z2.success) this._loggingLevels.set(H, z2.data);
          return {};
        });
      }
      get experimental() {
        if (!this._experimental) this._experimental = { tasks: new X7(this) };
        return this._experimental;
      }
      registerCapabilities(X) {
        if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
        this._capabilities = QG(this._capabilities, X);
      }
      setRequestHandler(X, Q) {
        var $, Y, W;
        let J = h1(X), G = J === null || J === void 0 ? void 0 : J.method;
        if (!G) throw Error("Schema is missing a method literal");
        let H;
        if (m0(G)) {
          let z2 = G, K = ($ = z2._zod) === null || $ === void 0 ? void 0 : $.def;
          H = (Y = K === null || K === void 0 ? void 0 : K.value) !== null && Y !== void 0 ? Y : z2.value;
        } else {
          let z2 = G, K = z2._def;
          H = (W = K === null || K === void 0 ? void 0 : K.value) !== null && W !== void 0 ? W : z2.value;
        }
        if (typeof H !== "string") throw Error("Schema method literal must be a string");
        if (H === "tools/call") {
          let z2 = async (K, V) => {
            let L = f1(g6, K);
            if (!L.success) {
              let N = L.error instanceof Error ? L.error.message : String(L.error);
              throw new k(x.InvalidParams, `Invalid tools/call request: ${N}`);
            }
            let { params: U } = L.data, F = await Promise.resolve(Q(K, V));
            if (U.task) {
              let N = f1(x6, F);
              if (!N.success) {
                let A = N.error instanceof Error ? N.error.message : String(N.error);
                throw new k(x.InvalidParams, `Invalid task creation result: ${A}`);
              }
              return N.data;
            }
            let q = f1(U8, F);
            if (!q.success) {
              let N = q.error instanceof Error ? q.error.message : String(q.error);
              throw new k(x.InvalidParams, `Invalid tools/call result: ${N}`);
            }
            return q.data;
          };
          return super.setRequestHandler(X, z2);
        }
        return super.setRequestHandler(X, Q);
      }
      assertCapabilityForMethod(X) {
        var Q, $, Y;
        switch (X) {
          case "sampling/createMessage":
            if (!((Q = this._clientCapabilities) === null || Q === void 0 ? void 0 : Q.sampling)) throw Error(`Client does not support sampling (required for ${X})`);
            break;
          case "elicitation/create":
            if (!(($ = this._clientCapabilities) === null || $ === void 0 ? void 0 : $.elicitation)) throw Error(`Client does not support elicitation (required for ${X})`);
            break;
          case "roots/list":
            if (!((Y = this._clientCapabilities) === null || Y === void 0 ? void 0 : Y.roots)) throw Error(`Client does not support listing roots (required for ${X})`);
            break;
          case "ping":
            break;
        }
      }
      assertNotificationCapability(X) {
        var Q, $;
        switch (X) {
          case "notifications/message":
            if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${X})`);
            break;
          case "notifications/resources/updated":
          case "notifications/resources/list_changed":
            if (!this._capabilities.resources) throw Error(`Server does not support notifying about resources (required for ${X})`);
            break;
          case "notifications/tools/list_changed":
            if (!this._capabilities.tools) throw Error(`Server does not support notifying of tool list changes (required for ${X})`);
            break;
          case "notifications/prompts/list_changed":
            if (!this._capabilities.prompts) throw Error(`Server does not support notifying of prompt list changes (required for ${X})`);
            break;
          case "notifications/elicitation/complete":
            if (!(($ = (Q = this._clientCapabilities) === null || Q === void 0 ? void 0 : Q.elicitation) === null || $ === void 0 ? void 0 : $.url)) throw Error(`Client does not support URL elicitation (required for ${X})`);
            break;
          case "notifications/cancelled":
            break;
          case "notifications/progress":
            break;
        }
      }
      assertRequestHandlerCapability(X) {
        if (!this._capabilities) return;
        switch (X) {
          case "completion/complete":
            if (!this._capabilities.completions) throw Error(`Server does not support completions (required for ${X})`);
            break;
          case "logging/setLevel":
            if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${X})`);
            break;
          case "prompts/get":
          case "prompts/list":
            if (!this._capabilities.prompts) throw Error(`Server does not support prompts (required for ${X})`);
            break;
          case "resources/list":
          case "resources/templates/list":
          case "resources/read":
            if (!this._capabilities.resources) throw Error(`Server does not support resources (required for ${X})`);
            break;
          case "tools/call":
          case "tools/list":
            if (!this._capabilities.tools) throw Error(`Server does not support tools (required for ${X})`);
            break;
          case "tasks/get":
          case "tasks/list":
          case "tasks/result":
          case "tasks/cancel":
            if (!this._capabilities.tasks) throw Error(`Server does not support tasks capability (required for ${X})`);
            break;
          case "ping":
          case "initialize":
            break;
        }
      }
      assertTaskCapability(X) {
        var Q, $;
        lz(($ = (Q = this._clientCapabilities) === null || Q === void 0 ? void 0 : Q.tasks) === null || $ === void 0 ? void 0 : $.requests, X, "Client");
      }
      assertTaskHandlerCapability(X) {
        var Q;
        if (!this._capabilities) return;
        uz((Q = this._capabilities.tasks) === null || Q === void 0 ? void 0 : Q.requests, X, "Server");
      }
      async _oninitialize(X) {
        let Q = X.params.protocolVersion;
        return this._clientCapabilities = X.params.capabilities, this._clientVersion = X.params.clientInfo, { protocolVersion: $5.includes(Q) ? Q : P$, capabilities: this.getCapabilities(), serverInfo: this._serverInfo, ...this._instructions && { instructions: this._instructions } };
      }
      getClientCapabilities() {
        return this._clientCapabilities;
      }
      getClientVersion() {
        return this._clientVersion;
      }
      getCapabilities() {
        return this._capabilities;
      }
      async ping() {
        return this.request({ method: "ping" }, t4);
      }
      async createMessage(X, Q) {
        var $, Y;
        if (X.tools || X.toolChoice) {
          if (!((Y = ($ = this._clientCapabilities) === null || $ === void 0 ? void 0 : $.sampling) === null || Y === void 0 ? void 0 : Y.tools)) throw Error("Client does not support sampling tools capability.");
        }
        if (X.messages.length > 0) {
          let W = X.messages[X.messages.length - 1], J = Array.isArray(W.content) ? W.content : [W.content], G = J.some((K) => K.type === "tool_result"), H = X.messages.length > 1 ? X.messages[X.messages.length - 2] : void 0, B = H ? Array.isArray(H.content) ? H.content : [H.content] : [], z2 = B.some((K) => K.type === "tool_use");
          if (G) {
            if (J.some((K) => K.type !== "tool_result")) throw Error("The last message must contain only tool_result content if any is present");
            if (!z2) throw Error("tool_result blocks are not matching any tool_use from the previous message");
          }
          if (z2) {
            let K = new Set(B.filter((L) => L.type === "tool_use").map((L) => L.id)), V = new Set(J.filter((L) => L.type === "tool_result").map((L) => L.toolUseId));
            if (K.size !== V.size || ![...K].every((L) => V.has(L))) throw Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
          }
        }
        if (X.tools) return this.request({ method: "sampling/createMessage", params: X }, u$, Q);
        return this.request({ method: "sampling/createMessage", params: X }, h$, Q);
      }
      async elicitInput(X, Q) {
        var $, Y, W, J, G;
        switch (($ = X.mode) !== null && $ !== void 0 ? $ : "form") {
          case "url": {
            if (!((W = (Y = this._clientCapabilities) === null || Y === void 0 ? void 0 : Y.elicitation) === null || W === void 0 ? void 0 : W.url)) throw Error("Client does not support url elicitation.");
            let B = X;
            return this.request({ method: "elicitation/create", params: B }, V8, Q);
          }
          case "form": {
            if (!((G = (J = this._clientCapabilities) === null || J === void 0 ? void 0 : J.elicitation) === null || G === void 0 ? void 0 : G.form)) throw Error("Client does not support form elicitation.");
            let B = X.mode === "form" ? X : { ...X, mode: "form" }, z2 = await this.request({ method: "elicitation/create", params: B }, V8, Q);
            if (z2.action === "accept" && z2.content && B.requestedSchema) try {
              let V = this._jsonSchemaValidator.getValidator(B.requestedSchema)(z2.content);
              if (!V.valid) throw new k(x.InvalidParams, `Elicitation response content does not match requested schema: ${V.errorMessage}`);
            } catch (K) {
              if (K instanceof k) throw K;
              throw new k(x.InternalError, `Error validating elicitation response: ${K instanceof Error ? K.message : String(K)}`);
            }
            return z2;
          }
        }
      }
      createElicitationCompletionNotifier(X, Q) {
        var $, Y;
        if (!((Y = ($ = this._clientCapabilities) === null || $ === void 0 ? void 0 : $.elicitation) === null || Y === void 0 ? void 0 : Y.url)) throw Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
        return () => this.notification({ method: "notifications/elicitation/complete", params: { elicitationId: X } }, Q);
      }
      async listRoots(X, Q) {
        return this.request({ method: "roots/list", params: X }, l$, Q);
      }
      async sendLoggingMessage(X, Q) {
        if (this._capabilities.logging) {
          if (!this.isMessageIgnored(X.level, Q)) return this.notification({ method: "notifications/message", params: X });
        }
      }
      async sendResourceUpdated(X) {
        return this.notification({ method: "notifications/resources/updated", params: X });
      }
      async sendResourceListChanged() {
        return this.notification({ method: "notifications/resources/list_changed" });
      }
      async sendToolListChanged() {
        return this.notification({ method: "notifications/tools/list_changed" });
      }
      async sendPromptListChanged() {
        return this.notification({ method: "notifications/prompts/list_changed" });
      }
    };
    cz = /* @__PURE__ */ Symbol.for("mcp.completable");
    (function(X) {
      X.Completable = "McpCompletable";
    })(mz || (mz = {}));
    jE = /^[A-Za-z0-9._-]{1,128}$/;
    Y7 = class {
      constructor(X) {
        this._mcpServer = X;
      }
      registerToolTask(X, Q, $) {
        let Y = { taskSupport: "required", ...Q.execution };
        if (Y.taskSupport === "forbidden") throw Error(`Cannot register task-based tool '${X}' with taskSupport 'forbidden'. Use registerTool() instead.`);
        return this._mcpServer._createRegisteredTool(X, Q.title, Q.description, Q.inputSchema, Q.outputSchema, Q.annotations, Y, Q._meta, $);
      }
    };
    J7 = class {
      constructor(X, Q) {
        this._registeredResources = {}, this._registeredResourceTemplates = {}, this._registeredTools = {}, this._registeredPrompts = {}, this._toolHandlersInitialized = false, this._completionHandlerInitialized = false, this._resourceHandlersInitialized = false, this._promptHandlersInitialized = false, this.server = new Q7(X, Q);
      }
      get experimental() {
        if (!this._experimental) this._experimental = { tasks: new Y7(this) };
        return this._experimental;
      }
      async connect(X) {
        return await this.server.connect(X);
      }
      async close() {
        await this.server.close();
      }
      setToolRequestHandlers() {
        if (this._toolHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(r1(K8)), this.server.assertCanSetRequestHandler(r1(g6)), this.server.registerCapabilities({ tools: { listChanged: true } }), this.server.setRequestHandler(K8, () => ({ tools: Object.entries(this._registeredTools).filter(([, X]) => X.enabled).map(([X, Q]) => {
          let $ = { name: X, title: Q.title, description: Q.description, inputSchema: (() => {
            let Y = T6(Q.inputSchema);
            return Y ? n$(Y, { strictUnions: true, pipeStrategy: "input" }) : IE;
          })(), annotations: Q.annotations, execution: Q.execution, _meta: Q._meta };
          if (Q.outputSchema) {
            let Y = T6(Q.outputSchema);
            if (Y) $.outputSchema = n$(Y, { strictUnions: true, pipeStrategy: "output" });
          }
          return $;
        }) })), this.server.setRequestHandler(g6, async (X, Q) => {
          var $;
          try {
            let Y = this._registeredTools[X.params.name];
            if (!Y) throw new k(x.InvalidParams, `Tool ${X.params.name} not found`);
            if (!Y.enabled) throw new k(x.InvalidParams, `Tool ${X.params.name} disabled`);
            let W = !!X.params.task, J = ($ = Y.execution) === null || $ === void 0 ? void 0 : $.taskSupport, G = "createTask" in Y.handler;
            if ((J === "required" || J === "optional") && !G) throw new k(x.InternalError, `Tool ${X.params.name} has taskSupport '${J}' but was not registered with registerToolTask`);
            if (J === "required" && !W) throw new k(x.MethodNotFound, `Tool ${X.params.name} requires task augmentation (taskSupport: 'required')`);
            if (J === "optional" && !W && G) return await this.handleAutomaticTaskPolling(Y, X, Q);
            let H = await this.validateToolInput(Y, X.params.arguments, X.params.name), B = await this.executeToolHandler(Y, H, Q);
            if (W) return B;
            return await this.validateToolOutput(Y, B, X.params.name), B;
          } catch (Y) {
            if (Y instanceof k) {
              if (Y.code === x.UrlElicitationRequired) throw Y;
            }
            return this.createToolError(Y instanceof Error ? Y.message : String(Y));
          }
        }), this._toolHandlersInitialized = true;
      }
      createToolError(X) {
        return { content: [{ type: "text", text: X }], isError: true };
      }
      async validateToolInput(X, Q, $) {
        if (!X.inputSchema) return;
        let Y = T6(X.inputSchema), W = Y !== null && Y !== void 0 ? Y : X.inputSchema, J = await m4(W, Q);
        if (!J.success) {
          let G = "error" in J ? J.error : "Unknown error", H = c4(G);
          throw new k(x.InvalidParams, `Input validation error: Invalid arguments for tool ${$}: ${H}`);
        }
        return J.data;
      }
      async validateToolOutput(X, Q, $) {
        if (!X.outputSchema) return;
        if (!("content" in Q)) return;
        if (Q.isError) return;
        if (!Q.structuredContent) throw new k(x.InvalidParams, `Output validation error: Tool ${$} has an output schema but no structured content was provided`);
        let Y = T6(X.outputSchema), W = await m4(Y, Q.structuredContent);
        if (!W.success) {
          let J = "error" in W ? W.error : "Unknown error", G = c4(J);
          throw new k(x.InvalidParams, `Output validation error: Invalid structured content for tool ${$}: ${G}`);
        }
      }
      async executeToolHandler(X, Q, $) {
        let Y = X.handler;
        if ("createTask" in Y) {
          if (!$.taskStore) throw Error("No task store provided.");
          let J = { ...$, taskStore: $.taskStore };
          if (X.inputSchema) return await Promise.resolve(Y.createTask(Q, J));
          else return await Promise.resolve(Y.createTask(J));
        }
        if (X.inputSchema) return await Promise.resolve(Y(Q, $));
        else return await Promise.resolve(Y($));
      }
      async handleAutomaticTaskPolling(X, Q, $) {
        var Y;
        if (!$.taskStore) throw Error("No task store provided for task-capable tool.");
        let W = await this.validateToolInput(X, Q.params.arguments, Q.params.name), J = X.handler, G = { ...$, taskStore: $.taskStore }, H = W ? await Promise.resolve(J.createTask(W, G)) : await Promise.resolve(J.createTask(G)), B = H.task.taskId, z2 = H.task, K = (Y = z2.pollInterval) !== null && Y !== void 0 ? Y : 5e3;
        while (z2.status !== "completed" && z2.status !== "failed" && z2.status !== "cancelled") {
          await new Promise((L) => setTimeout(L, K));
          let V = await $.taskStore.getTask(B);
          if (!V) throw new k(x.InternalError, `Task ${B} not found during polling`);
          z2 = V;
        }
        return await $.taskStore.getTaskResult(B);
      }
      setCompletionRequestHandler() {
        if (this._completionHandlerInitialized) return;
        this.server.assertCanSetRequestHandler(r1(L8)), this.server.registerCapabilities({ completions: {} }), this.server.setRequestHandler(L8, async (X) => {
          switch (X.params.ref.type) {
            case "ref/prompt":
              return A5(X), this.handlePromptCompletion(X, X.params.ref);
            case "ref/resource":
              return w5(X), this.handleResourceCompletion(X, X.params.ref);
            default:
              throw new k(x.InvalidParams, `Invalid completion reference: ${X.params.ref}`);
          }
        }), this._completionHandlerInitialized = true;
      }
      async handlePromptCompletion(X, Q) {
        let $ = this._registeredPrompts[Q.name];
        if (!$) throw new k(x.InvalidParams, `Prompt ${Q.name} not found`);
        if (!$.enabled) throw new k(x.InvalidParams, `Prompt ${Q.name} disabled`);
        if (!$.argsSchema) return H4;
        let Y = h1($.argsSchema), W = Y === null || Y === void 0 ? void 0 : Y[X.params.argument.name];
        if (!pz(W)) return H4;
        let J = dz(W);
        if (!J) return H4;
        let G = await J(X.params.argument.value, X.params.context);
        return nz(G);
      }
      async handleResourceCompletion(X, Q) {
        let $ = Object.values(this._registeredResourceTemplates).find((J) => J.resourceTemplate.uriTemplate.toString() === Q.uri);
        if (!$) {
          if (this._registeredResources[Q.uri]) return H4;
          throw new k(x.InvalidParams, `Resource template ${X.params.ref.uri} not found`);
        }
        let Y = $.resourceTemplate.completeCallback(X.params.argument.name);
        if (!Y) return H4;
        let W = await Y(X.params.argument.value, X.params.context);
        return nz(W);
      }
      setResourceRequestHandlers() {
        if (this._resourceHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(r1(J8)), this.server.assertCanSetRequestHandler(r1(G8)), this.server.assertCanSetRequestHandler(r1(H8)), this.server.registerCapabilities({ resources: { listChanged: true } }), this.server.setRequestHandler(J8, async (X, Q) => {
          let $ = Object.entries(this._registeredResources).filter(([W, J]) => J.enabled).map(([W, J]) => ({ uri: W, name: J.name, ...J.metadata })), Y = [];
          for (let W of Object.values(this._registeredResourceTemplates)) {
            if (!W.resourceTemplate.listCallback) continue;
            let J = await W.resourceTemplate.listCallback(Q);
            for (let G of J.resources) Y.push({ ...W.metadata, ...G });
          }
          return { resources: [...$, ...Y] };
        }), this.server.setRequestHandler(G8, async () => {
          return { resourceTemplates: Object.entries(this._registeredResourceTemplates).map(([Q, $]) => ({ name: Q, uriTemplate: $.resourceTemplate.uriTemplate.toString(), ...$.metadata })) };
        }), this.server.setRequestHandler(H8, async (X, Q) => {
          let $ = new URL(X.params.uri), Y = this._registeredResources[$.toString()];
          if (Y) {
            if (!Y.enabled) throw new k(x.InvalidParams, `Resource ${$} disabled`);
            return Y.readCallback($, Q);
          }
          for (let W of Object.values(this._registeredResourceTemplates)) {
            let J = W.resourceTemplate.uriTemplate.match($.toString());
            if (J) return W.readCallback($, J, Q);
          }
          throw new k(x.InvalidParams, `Resource ${$} not found`);
        }), this.setCompletionRequestHandler(), this._resourceHandlersInitialized = true;
      }
      setPromptRequestHandlers() {
        if (this._promptHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(r1(B8)), this.server.assertCanSetRequestHandler(r1(z8)), this.server.registerCapabilities({ prompts: { listChanged: true } }), this.server.setRequestHandler(B8, () => ({ prompts: Object.entries(this._registeredPrompts).filter(([, X]) => X.enabled).map(([X, Q]) => {
          return { name: X, title: Q.title, description: Q.description, arguments: Q.argsSchema ? PE(Q.argsSchema) : void 0 };
        }) })), this.server.setRequestHandler(z8, async (X, Q) => {
          let $ = this._registeredPrompts[X.params.name];
          if (!$) throw new k(x.InvalidParams, `Prompt ${X.params.name} not found`);
          if (!$.enabled) throw new k(x.InvalidParams, `Prompt ${X.params.name} disabled`);
          if ($.argsSchema) {
            let Y = T6($.argsSchema), W = await m4(Y, X.params.arguments);
            if (!W.success) {
              let H = "error" in W ? W.error : "Unknown error", B = c4(H);
              throw new k(x.InvalidParams, `Invalid arguments for prompt ${X.params.name}: ${B}`);
            }
            let J = W.data, G = $.callback;
            return await Promise.resolve(G(J, Q));
          } else {
            let Y = $.callback;
            return await Promise.resolve(Y(Q));
          }
        }), this.setCompletionRequestHandler(), this._promptHandlersInitialized = true;
      }
      resource(X, Q, ...$) {
        let Y;
        if (typeof $[0] === "object") Y = $.shift();
        let W = $[0];
        if (typeof Q === "string") {
          if (this._registeredResources[Q]) throw Error(`Resource ${Q} is already registered`);
          let J = this._createRegisteredResource(X, void 0, Q, Y, W);
          return this.setResourceRequestHandlers(), this.sendResourceListChanged(), J;
        } else {
          if (this._registeredResourceTemplates[X]) throw Error(`Resource template ${X} is already registered`);
          let J = this._createRegisteredResourceTemplate(X, void 0, Q, Y, W);
          return this.setResourceRequestHandlers(), this.sendResourceListChanged(), J;
        }
      }
      registerResource(X, Q, $, Y) {
        if (typeof Q === "string") {
          if (this._registeredResources[Q]) throw Error(`Resource ${Q} is already registered`);
          let W = this._createRegisteredResource(X, $.title, Q, $, Y);
          return this.setResourceRequestHandlers(), this.sendResourceListChanged(), W;
        } else {
          if (this._registeredResourceTemplates[X]) throw Error(`Resource template ${X} is already registered`);
          let W = this._createRegisteredResourceTemplate(X, $.title, Q, $, Y);
          return this.setResourceRequestHandlers(), this.sendResourceListChanged(), W;
        }
      }
      _createRegisteredResource(X, Q, $, Y, W) {
        let J = { name: X, title: Q, metadata: Y, readCallback: W, enabled: true, disable: () => J.update({ enabled: false }), enable: () => J.update({ enabled: true }), remove: () => J.update({ uri: null }), update: (G) => {
          if (typeof G.uri < "u" && G.uri !== $) {
            if (delete this._registeredResources[$], G.uri) this._registeredResources[G.uri] = J;
          }
          if (typeof G.name < "u") J.name = G.name;
          if (typeof G.title < "u") J.title = G.title;
          if (typeof G.metadata < "u") J.metadata = G.metadata;
          if (typeof G.callback < "u") J.readCallback = G.callback;
          if (typeof G.enabled < "u") J.enabled = G.enabled;
          this.sendResourceListChanged();
        } };
        return this._registeredResources[$] = J, J;
      }
      _createRegisteredResourceTemplate(X, Q, $, Y, W) {
        let J = { resourceTemplate: $, title: Q, metadata: Y, readCallback: W, enabled: true, disable: () => J.update({ enabled: false }), enable: () => J.update({ enabled: true }), remove: () => J.update({ name: null }), update: (G) => {
          if (typeof G.name < "u" && G.name !== X) {
            if (delete this._registeredResourceTemplates[X], G.name) this._registeredResourceTemplates[G.name] = J;
          }
          if (typeof G.title < "u") J.title = G.title;
          if (typeof G.template < "u") J.resourceTemplate = G.template;
          if (typeof G.metadata < "u") J.metadata = G.metadata;
          if (typeof G.callback < "u") J.readCallback = G.callback;
          if (typeof G.enabled < "u") J.enabled = G.enabled;
          this.sendResourceListChanged();
        } };
        return this._registeredResourceTemplates[X] = J, J;
      }
      _createRegisteredPrompt(X, Q, $, Y, W) {
        let J = { title: Q, description: $, argsSchema: Y === void 0 ? void 0 : v6(Y), callback: W, enabled: true, disable: () => J.update({ enabled: false }), enable: () => J.update({ enabled: true }), remove: () => J.update({ name: null }), update: (G) => {
          if (typeof G.name < "u" && G.name !== X) {
            if (delete this._registeredPrompts[X], G.name) this._registeredPrompts[G.name] = J;
          }
          if (typeof G.title < "u") J.title = G.title;
          if (typeof G.description < "u") J.description = G.description;
          if (typeof G.argsSchema < "u") J.argsSchema = v6(G.argsSchema);
          if (typeof G.callback < "u") J.callback = G.callback;
          if (typeof G.enabled < "u") J.enabled = G.enabled;
          this.sendPromptListChanged();
        } };
        return this._registeredPrompts[X] = J, J;
      }
      _createRegisteredTool(X, Q, $, Y, W, J, G, H, B) {
        $7(X);
        let z2 = { title: Q, description: $, inputSchema: iz(Y), outputSchema: iz(W), annotations: J, execution: G, _meta: H, handler: B, enabled: true, disable: () => z2.update({ enabled: false }), enable: () => z2.update({ enabled: true }), remove: () => z2.update({ name: null }), update: (K) => {
          if (typeof K.name < "u" && K.name !== X) {
            if (typeof K.name === "string") $7(K.name);
            if (delete this._registeredTools[X], K.name) this._registeredTools[K.name] = z2;
          }
          if (typeof K.title < "u") z2.title = K.title;
          if (typeof K.description < "u") z2.description = K.description;
          if (typeof K.paramsSchema < "u") z2.inputSchema = v6(K.paramsSchema);
          if (typeof K.callback < "u") z2.handler = K.callback;
          if (typeof K.annotations < "u") z2.annotations = K.annotations;
          if (typeof K._meta < "u") z2._meta = K._meta;
          if (typeof K.enabled < "u") z2.enabled = K.enabled;
          this.sendToolListChanged();
        } };
        return this._registeredTools[X] = z2, this.setToolRequestHandlers(), this.sendToolListChanged(), z2;
      }
      tool(X, ...Q) {
        if (this._registeredTools[X]) throw Error(`Tool ${X} is already registered`);
        let $, Y, W, J;
        if (typeof Q[0] === "string") $ = Q.shift();
        if (Q.length > 1) {
          let H = Q[0];
          if (W7(H)) {
            if (Y = Q.shift(), Q.length > 1 && typeof Q[0] === "object" && Q[0] !== null && !W7(Q[0])) J = Q.shift();
          } else if (typeof H === "object" && H !== null) J = Q.shift();
        }
        let G = Q[0];
        return this._createRegisteredTool(X, void 0, $, Y, W, J, { taskSupport: "forbidden" }, void 0, G);
      }
      registerTool(X, Q, $) {
        if (this._registeredTools[X]) throw Error(`Tool ${X} is already registered`);
        let { title: Y, description: W, inputSchema: J, outputSchema: G, annotations: H, _meta: B } = Q;
        return this._createRegisteredTool(X, Y, W, J, G, H, { taskSupport: "forbidden" }, B, $);
      }
      prompt(X, ...Q) {
        if (this._registeredPrompts[X]) throw Error(`Prompt ${X} is already registered`);
        let $;
        if (typeof Q[0] === "string") $ = Q.shift();
        let Y;
        if (Q.length > 1) Y = Q.shift();
        let W = Q[0], J = this._createRegisteredPrompt(X, void 0, $, Y, W);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), J;
      }
      registerPrompt(X, Q, $) {
        if (this._registeredPrompts[X]) throw Error(`Prompt ${X} is already registered`);
        let { title: Y, description: W, argsSchema: J } = Q, G = this._createRegisteredPrompt(X, Y, W, J, $);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), G;
      }
      isConnected() {
        return this.server.transport !== void 0;
      }
      async sendLoggingMessage(X, Q) {
        return this.server.sendLoggingMessage(X, Q);
      }
      sendResourceListChanged() {
        if (this.isConnected()) this.server.sendResourceListChanged();
      }
      sendToolListChanged() {
        if (this.isConnected()) this.server.sendToolListChanged();
      }
      sendPromptListChanged() {
        if (this.isConnected()) this.server.sendPromptListChanged();
      }
    };
    IE = { type: "object", properties: {} };
    H4 = { completion: { values: [], hasMore: false } };
  }
});

// dist/servers/mim-server.js
var readline = __toESM(require("node:readline"), 1);
var fs2 = __toESM(require("node:fs"), 1);
var path2 = __toESM(require("node:path"), 1);
var import_node_child_process = require("node:child_process");
var import_node_os = require("node:os");

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const k3 = keys[i3];
      if (!(k3 in inst)) {
        inst[k3] = proto[k3].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = /* @__PURE__ */ Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v3) => typeof v3 === "number");
  const values = Object.entries(entries).filter(([k3, _]) => numericValues.indexOf(+k3) === -1).map(([_, v3]) => v3);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v3) {
      Object.defineProperty(object2, key, {
        value: v3
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i3 = 0; i3 < keys.length; i3++) {
      resolvedObj[keys[i3]] = results[i3];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i3 = 0; i3 < length; i3++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o6) {
  if (isObject(o6) === false)
    return false;
  const ctor = o6.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o6) {
  if (isPlainObject(o6))
    return { ...o6 };
  if (Array.isArray(o6))
    return [...o6];
  return o6;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k3) => {
    return shape[k3]._zod.optin === "optional" && shape[k3]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b3) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b3._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b3._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x3, startIndex = 0) {
  if (x3.aborted === true)
    return true;
  for (let i3 = startIndex; i3 < x3.issues.length; i3++) {
    if (x3.issues[i3]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path3, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k3, _]) => {
    return Number.isNaN(Number.parseInt(k3, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i3 = 0; i3 < binaryString.length; i3++) {
    bytes[i3] = binaryString.charCodeAt(i3);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i3 = 0; i3 < bytes.length; i3++) {
    binaryString += String.fromCharCode(bytes[i3]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i3 = 0; i3 < cleanHex.length; i3 += 2) {
    bytes[i3 / 2] = Number.parseInt(cleanHex.slice(i3, i3 + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b3) => b3.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i3 = 0;
        while (i3 < issue2.path.length) {
          const el = issue2.path[i3];
          const terminal = i3 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i3++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path3 = []) => {
    var _a2, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path3, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i3 = 0;
        while (i3 < fullpath.length) {
          const el = fullpath[i3];
          const terminal = i3 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i3++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path3 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b3) => (a.path ?? []).length - (b3.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x3) => x3);
    const minIndent = Math.min(...lines.map((x3) => x3.length - x3.trimStart().length));
    const dedented = lines.map((x3) => x3.slice(minIndent)).map((x3) => " ".repeat(this.indent * 2) + x3);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x3) => `  ${x3}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r3 = safeParse(inst, value);
        return r3.success ? { value: r3.data } : { issues: r3.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r3) => r3.success ? { value: r3.data } : { issues: r3.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v3 = versionMap[def.version];
    if (v3 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v3));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c3) => c3 === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i3 = 0; i3 < input.length; i3++) {
      const item = input[i3];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i3)));
      } else {
        handleArrayResult(result, payload, i3);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k3 of keys) {
    if (!def.shape?.[k3]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k3}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r3 = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r3 instanceof Promise) {
      proms.push(r3.then((r6) => handlePropertyResult(r6, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r3, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v3 of field.values)
          propValues[key].add(v3);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r3 = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r3 instanceof Promise) {
        proms.push(r3.then((r6) => handlePropertyResult(r6, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r3, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k3 = esc(key);
      return `shape[${k3}]._zod.run({ value: input[${k3}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k3 = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k3} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k3}, ...iss.path] : [${k3}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k3} in input) {
            newResult[${k3}] = undefined;
          }
        } else {
          newResult[${k3}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k3}, ...iss.path] : [${k3}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k3} in input) {
            newResult[${k3}] = undefined;
          }
        } else {
          newResult[${k3}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r3) => !aborted(r3));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o6) => o6._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o6) => o6._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o6) => o6._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o6) => o6._zod.pattern)) {
      const patterns = def.options.map((o6) => o6._zod.pattern);
      return new RegExp(`^(${patterns.map((p3) => cleanRegex(p3.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r3) => r3.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k3, v3] of Object.entries(pv)) {
        if (!propValues[k3])
          propValues[k3] = /* @__PURE__ */ new Set();
        for (const val of v3) {
          propValues[k3].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o6 of opts) {
      const values = o6._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o6)}"`);
      for (const v3 of values) {
        if (map2.has(v3)) {
          throw new Error(`Duplicate discriminator value "${String(v3)}"`);
        }
        map2.set(v3, o6);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b3) {
  if (a === b3) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b3 instanceof Date && +a === +b3) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b3)) {
    const bKeys = Object.keys(b3);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b3[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b3)) {
    if (a.length !== b3.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k3 of iss.keys) {
        if (!unrecKeys.has(k3))
          unrecKeys.set(k3, {});
        unrecKeys.get(k3).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k3 of iss.keys) {
        if (!unrecKeys.has(k3))
          unrecKeys.set(k3, {});
        unrecKeys.get(k3).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f3]) => f3.l && f3.r).map(([k3]) => k3);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i3 = -1;
    for (const item of items) {
      i3++;
      if (i3 >= input.length) {
        if (i3 >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i3],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i3)));
      } else {
        handleTupleResult(result, payload, i3);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i3++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i3)));
        } else {
          handleTupleResult(result, payload, i3);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k3) => propertyKeyTypes.has(typeof k3)).map((o6) => typeof o6 === "string" ? escapeRegex(o6) : o6.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o6) => typeof o6 === "string" ? escapeRegex(o6) : o6 ? escapeRegex(o6.toString()) : String(o6)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r3) => handleOptionalResult(r3, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v3 = def.innerType._zod.values;
    return v3 ? new Set([...v3].filter((x3) => x3 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r3 = def.fn(input);
    if (r3 instanceof Promise) {
      return r3.then((r6) => handleRefineResult(r6, payload, input, inst));
    }
    handleRefineResult(r3, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e2 = typeEntry(t);
    if (e2)
      return e2.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e2 = typeEntry(t);
    const gender = e2?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v3) => stringifyPrimitive(v3));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// node_modules/zod/v4/core/registries.js
var _a;
var $output = /* @__PURE__ */ Symbol("ZodOutput");
var $input = /* @__PURE__ */ Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p3 = schema._zod.parent;
    if (p3) {
      const pm = { ...this.get(p3) ?? {} };
      delete pm.id;
      const f3 = { ...pm, ...this._map.get(schema) };
      return Object.keys(f3).length ? f3 : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v3) => typeof v3 === "string" ? v3.toLowerCase() : v3);
    falsyArray = falsyArray.map((v3) => typeof v3 === "string" ? v3.toLowerCase() : v3);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  json2.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minLength = minimum;
  if (typeof maximum === "number")
    json2.maxLength = maximum;
  if (format) {
    json2.format = formatMap[format] ?? format;
    if (json2.format === "")
      delete json2.format;
    if (format === "time") {
      delete json2.format;
    }
  }
  if (contentEncoding)
    json2.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json2.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json2.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json2.type = "integer";
  else
    json2.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.minimum = exclusiveMinimum;
      json2.exclusiveMinimum = true;
    } else {
      json2.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json2.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json2.minimum;
      else
        delete json2.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.maximum = exclusiveMaximum;
      json2.exclusiveMaximum = true;
    } else {
      json2.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json2.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json2.maximum;
      else
        delete json2.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json2.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json2, _params) => {
  if (ctx.target === "openapi-3.0") {
    json2.type = "string";
    json2.nullable = true;
    json2.enum = [null];
  } else {
    json2.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json2, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v3) => typeof v3 === "number"))
    json2.type = "number";
  if (values.every((v3) => typeof v3 === "string"))
    json2.type = "string";
  json2.enum = values;
};
var literalProcessor = (schema, ctx, json2, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json2.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.enum = [val];
    } else {
      json2.const = val;
    }
  } else {
    if (vals.every((v3) => typeof v3 === "number"))
      json2.type = "number";
    if (vals.every((v3) => typeof v3 === "string"))
      json2.type = "string";
    if (vals.every((v3) => typeof v3 === "boolean"))
      json2.type = "boolean";
    if (vals.every((v3) => v3 === null))
      json2.type = "null";
    json2.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
  json2.type = "array";
  json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  json2.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v3 = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v3.optin === void 0;
    } else {
      return v3.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json2.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json2.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json2.additionalProperties = false;
  } else if (def.catchall) {
    json2.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x3, i3) => process2(x3, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i3]
  }));
  if (isExclusive) {
    json2.oneOf = options;
  } else {
    json2.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b3 = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b3) ? b3.allOf : [b3]
  ];
  json2.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x3, i3) => process2(x3, ctx, {
    ...params,
    path: [...params.path, prefixPath, i3]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json2.prefixItems = prefixItems;
    if (rest) {
      json2.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json2.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json2.items.anyOf.push(rest);
    }
    json2.minItems = prefixItems.length;
    if (!rest) {
      json2.maxItems = prefixItems.length;
    }
  } else {
    json2.items = prefixItems;
    if (rest) {
      json2.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (const pattern of patterns) {
      json2.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json2.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v3) => typeof v3 === "string" || typeof v3 === "number");
    if (validKeyValues.length > 0) {
      json2.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json2.nullable = true;
  } else {
    json2.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}

// node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c3 = inst._zod.bag;
  inst.minDate = c3.minimum ? new Date(c3.minimum) : null;
  inst.maxDate = c3.maximum ? new Date(c3.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k3 = clone(keyType);
  k3._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k3,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports2,
  ...checks_exports2,
  iso: iso_exports
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path3 = ref.slice(1).split("/").filter(Boolean);
  if (path3.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path3[0] === defsKey) {
    const key = path3[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v3) => typeof v3 === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v3) => z.literal(v3));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i3 = 2; i3 < schemasToIntersect.length; i3++) {
            result = z.intersection(result, schemasToIntersect[i3]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i3 = startIdx; i3 < schema.allOf.length; i3++) {
        result = z.intersection(result, convertSchema(schema.allOf[i3], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// dist/utils/logger.js
var fs = __toESM(require("fs"), 1);
var path = __toESM(require("path"), 1);
var AGENTS = {
  QUEUE_PROCESSOR: "QUEUE_PROCESSOR",
  CHANGES_REVIEWER: "CHANGES_REVIEWER",
  WELLSPRING: "WELLSPRING",
  CLI: "CLI",
  TUI: "TUI",
  MCP_SERVER: "MCP_SERVER"
};
function findProjectRoot() {
  let currentDir = process.cwd();
  const root = path.parse(currentDir).root;
  while (currentDir !== root) {
    const knowledgeDir = path.join(currentDir, ".claude", "knowledge");
    if (fs.existsSync(knowledgeDir)) {
      return currentDir;
    }
    currentDir = path.dirname(currentDir);
  }
  const rootKnowledgeDir = path.join(root, ".claude", "knowledge");
  if (fs.existsSync(rootKnowledgeDir)) {
    return root;
  }
  return null;
}
function getLogFilePath() {
  const projectRoot = findProjectRoot();
  if (!projectRoot) {
    return null;
  }
  const knowledgeDir = path.join(projectRoot, ".claude", "knowledge");
  try {
    if (!fs.existsSync(knowledgeDir)) {
      fs.mkdirSync(knowledgeDir, { recursive: true });
    }
  } catch {
    return null;
  }
  return path.join(knowledgeDir, "mim.log");
}
function writeLog(level, agent, message) {
  try {
    const logFilePath = getLogFilePath();
    if (!logFilePath) {
      return;
    }
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logEntry = `[${timestamp}] [${agent}] [${level}] ${message}
`;
    fs.appendFileSync(logFilePath, logEntry, "utf-8");
  } catch {
  }
}
function logInfo(agent, msg) {
  writeLog("INFO", agent, msg);
}
function logWarn(agent, msg) {
  writeLog("WARN", agent, msg);
}
function logError(agent, msg) {
  writeLog("ERROR", agent, msg);
}

// dist/utils/mim-check.js
var import_child_process = require("child_process");
function isMimCliInstalled() {
  try {
    (0, import_child_process.execSync)("which mim", { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}
function checkMimActivation(_projectRoot) {
  const cliInstalled = isMimCliInstalled();
  const activated = cliInstalled;
  let message;
  if (activated) {
    message = "M\xEDm activated - background processing enabled";
  } else {
    message = 'M\xEDm CLI not installed. Run "npm install -g mim-ai" to enable background processing (contributes to some Opus usage)';
  }
  return { activated, cliInstalled, message };
}

// dist/servers/mim-server.js
var QueueProcessorOutputSchema = external_exports.object({
  status: external_exports.enum(["processed", "conflict_detected"]),
  action: external_exports.enum(["added", "updated", "duplicate_skipped", "created_review"]),
  file_modified: external_exports.string().nullable(),
  ready_for_next: external_exports.boolean()
});
var KNOWLEDGE_BASE_DIR = ".claude/knowledge";
var QUEUE_DIR = `${KNOWLEDGE_BASE_DIR}/remember-queue`;
var PENDING_REVIEW_DIR = `${KNOWLEDGE_BASE_DIR}/pending-review`;
var CORE_CATEGORIES = ["architecture", "patterns", "dependencies", "workflows", "gotchas"];
function createResponse(id, result) {
  return JSON.stringify({
    jsonrpc: "2.0",
    id,
    result
  });
}
function createError(id, code, message) {
  return JSON.stringify({
    jsonrpc: "2.0",
    id,
    error: { code, message }
  });
}
function generateShortId() {
  const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
  let id = "";
  for (let i3 = 0; i3 < 6; i3++) {
    id += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return id;
}
function ensureDir(dirPath) {
  if (!fs2.existsSync(dirPath)) {
    fs2.mkdirSync(dirPath, { recursive: true });
  }
}
function getProjectRoot() {
  let dir = process.cwd();
  while (dir !== "/") {
    if (fs2.existsSync(path2.join(dir, ".git"))) {
      return dir;
    }
    dir = path2.dirname(dir);
  }
  return process.cwd();
}
function recoverStaleQueueEntries(projectRoot) {
  const queueDir = path2.join(projectRoot, ".claude/knowledge/remember-queue");
  if (!fs2.existsSync(queueDir))
    return;
  const files = fs2.readdirSync(queueDir).filter((f3) => f3.endsWith(".json"));
  const staleThreshold = 5 * 60 * 1e3;
  for (const file2 of files) {
    const filePath = path2.join(queueDir, file2);
    try {
      const entry = JSON.parse(fs2.readFileSync(filePath, "utf8"));
      if (entry.status === "processing") {
        const processingTime = entry.processingStartedAt || 0;
        if (Date.now() - processingTime > staleThreshold) {
          entry.status = "pending";
          entry.lastError = "Recovered from stale processing state";
          delete entry.processingStartedAt;
          fs2.writeFileSync(filePath, JSON.stringify(entry, null, 2));
          logInfo(AGENTS.MCP_SERVER, `Recovered stale queue entry: ${entry.id}`);
        }
      }
    } catch (e2) {
    }
  }
}
function findClaudeExecutable() {
  try {
    const result = (0, import_node_child_process.execSync)("which claude", { encoding: "utf8" }).trim();
    if (result && fs2.existsSync(result)) {
      return fs2.realpathSync(result);
    }
  } catch (e2) {
  }
  const home = (0, import_node_os.homedir)();
  const commonPaths = [
    path2.join(home, ".local", "bin", "claude"),
    "/usr/local/bin/claude",
    "/usr/bin/claude"
  ];
  for (const p3 of commonPaths) {
    if (fs2.existsSync(p3)) {
      return fs2.realpathSync(p3);
    }
  }
  return "claude";
}
var QUEUE_PROCESSOR_SYSTEM_PROMPT = `You are the Knowledge Processor for Mim, a persistent memory system.

Your job is to process incoming knowledge entries and organize them into the appropriate files, then update the knowledge maps.

## Available Tools

You have access to: Read, Write, Edit, Glob, Grep, Bash
You do NOT have access to: AskUserQuestion (you cannot ask the user anything)

Use these tools to examine existing knowledge and write new entries.

## Knowledge Structure

The knowledge base is organized under .claude/knowledge/:

**Category Directories:**
- architecture/ - System design, component relationships, data flow
- patterns/ - Code patterns, conventions, idioms used in the project
- dependencies/ - External dependencies, their purposes, version notes
- workflows/ - Development workflows, deployment processes, common tasks
- gotchas/ - Pitfalls, gotchas, things that don't work as expected

**Knowledge Maps (MUST UPDATE BOTH):**
- KNOWLEDGE_MAP.md - User-facing index with markdown links like [Topic Name](category/file.md)
- KNOWLEDGE_MAP_CLAUDE.md - Claude-facing index with RELATIVE @ references like @category/file.md

Both maps should have identical structure, just different link formats.

## Entry Format

Each entry you receive has:
- category: The knowledge category (architecture, patterns, etc.)
- topic: Brief descriptive title
- details: Full content/explanation
- files: Optional related file paths (comma-separated)

## Your Task

When you receive a knowledge entry to process:

1. **Check for duplicates**: Use Grep to search existing files for similar content
2. **Check for conflicts**: Look for existing knowledge that contradicts the new entry
3. **Take action**:
   - If duplicate: Skip it (action: duplicate_skipped)
   - If conflicts: Create a pending-review JSON file (action: created_review)
   - Otherwise: Append to the appropriate file or create a new one (action: added/updated)
4. **UPDATE BOTH KNOWLEDGE MAPS** when adding/updating:
   - Add entry to KNOWLEDGE_MAP.md with markdown link: [Topic](category/file.md)
   - Add entry to KNOWLEDGE_MAP_CLAUDE.md with @ reference: @category/file.md
   - Place under the appropriate category section (## Architecture, ## Patterns, etc.)

## Pending Review Format

When conflicts are detected, write to .claude/knowledge/pending-review/{id}-{subject}.json:

{
  "id": "short-id",
  "subject": "brief-subject-slug",
  "type": "conflict",
  "question": "Explain the situation in 2-4 sentences. The user sees BOTH this AND the options list below, so do NOT repeat or list the options here - just explain what happened and what needs deciding.",
  "options": ["First option", "Second option"],
  "knowledge_file": "category/filename.md",
  "agent_notes": "Technical details for applying the decision - file paths, what to change, etc. Human does NOT see this."
}

## File Organization

When adding new knowledge:
- Use descriptive filenames based on topic: architecture/api-design.md
- Append to existing files when the topic matches
- Create new files for distinct topics
- Use markdown formatting with headers
- Include the topic as an H2 header (## Topic Name)
- Include related files if provided

Example file content:
\`\`\`markdown
## Redis Caching Strategy

The application uses Redis for session caching with a 30-minute TTL.

**Related files:** src/cache/redis.js, config/redis.yml
\`\`\`

## Structured Output

Your response MUST be valid JSON with these exact fields:
- status: "processed" or "conflict_detected"
- action: "added", "updated", "duplicate_skipped", or "created_review"
- file_modified: path to the file you modified, or null if none
- ready_for_next: always set to true when done with this entry

Example: {"status":"processed","action":"added","file_modified":"architecture/api.md","ready_for_next":true}

## Important

- Be ruthless about avoiding duplicates - skip anything that's essentially the same
- When in doubt about conflicts, create a review entry
- Always signal ready_for_next: true when done processing an entry
- If you encounter errors, still output valid JSON with ready_for_next: true
- **ALWAYS update both knowledge maps when adding or updating entries**

## Output Schema (REQUIRED)

You MUST always respond with this exact JSON structure:

{
  "status": "processed" | "conflict_detected",
  "action": "added" | "updated" | "duplicate_skipped" | "created_review",
  "file_modified": "/path/to/file.md" | null,
  "ready_for_next": true | false
}

- status: Whether processing completed normally or found a conflict
- action: What you did with the entry
- file_modified: Path to the file you modified, or null if none
- ready_for_next: Always set to true when done with the current entry

## Tool Restrictions

You have access to file tools (Read, Write, Edit, Grep, Glob) but NOT AskUserQuestion.
When facing decisions, use your best judgment rather than asking.`;
var QUEUE_PROCESSOR_OUTPUT_SCHEMA = {
  type: "object",
  properties: {
    status: {
      type: "string",
      enum: ["processed", "conflict_detected"],
      description: "Result of processing the entry"
    },
    action: {
      type: "string",
      enum: ["added", "updated", "duplicate_skipped", "created_review"],
      description: "What action was taken"
    },
    file_modified: {
      type: ["string", "null"],
      description: "Path to modified knowledge file, or null"
    },
    ready_for_next: {
      type: "boolean",
      description: "True if ready to process another entry"
    }
  },
  required: ["status", "action", "file_modified", "ready_for_next"],
  additionalProperties: false
};
var QueueProcessor = class {
  projectRoot;
  session;
  sessionId;
  isProcessing;
  query;
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.session = null;
    this.sessionId = null;
    this.isProcessing = false;
    this.query = null;
  }
  /**
   * Initialize the SDK (dynamic import for ESM in CJS)
   */
  async initSDK() {
    if (this.query)
      return;
    try {
      const sdk = await Promise.resolve().then(() => (init_sdk(), sdk_exports));
      this.query = sdk.query;
      logInfo(AGENTS.QUEUE_PROCESSOR, "Claude Agent SDK imported successfully");
    } catch (err) {
      logError(AGENTS.QUEUE_PROCESSOR, `Failed to import Claude Agent SDK: ${err.message}`);
      throw err;
    }
  }
  /**
   * Load all existing knowledge for context
   */
  async loadAllKnowledge() {
    const knowledgeDir = path2.join(this.projectRoot, KNOWLEDGE_BASE_DIR);
    let content = "";
    for (const category of CORE_CATEGORIES) {
      const categoryDir = path2.join(knowledgeDir, category);
      if (!fs2.existsSync(categoryDir))
        continue;
      const files = fs2.readdirSync(categoryDir).filter((f3) => f3.endsWith(".md"));
      for (const file2 of files) {
        const filePath = path2.join(categoryDir, file2);
        const fileContent = fs2.readFileSync(filePath, "utf8");
        content += `
--- ${category}/${file2} ---
${fileContent}
`;
      }
    }
    return content || "(No existing knowledge files)";
  }
  /**
   * Start or get the agent session
   */
  async getSession() {
    await this.initSDK();
    if (this.session && this.sessionId) {
      return this.session;
    }
    logInfo(AGENTS.QUEUE_PROCESSOR, "Starting new agent session");
    const knowledge = await this.loadAllKnowledge();
    const canUseTool = async (toolName, input) => {
      if (toolName === "AskUserQuestion") {
        return {
          behavior: "deny",
          message: "This tool is not available. Process the entry based on your analysis."
        };
      }
      return { behavior: "allow", updatedInput: input };
    };
    const prompt = `You are the Knowledge Processor. Here is all current knowledge in the repository:

${knowledge}

I will send you knowledge entries to process. For each entry, analyze it against existing knowledge, then take the appropriate action (add, update, skip duplicate, or create review for conflicts).

Reply with your structured output indicating ready_for_next: true when you're ready for the first entry.`;
    const options = {
      model: "opus",
      systemPrompt: QUEUE_PROCESSOR_SYSTEM_PROMPT,
      canUseTool,
      outputFormat: {
        type: "json_schema",
        schema: QUEUE_PROCESSOR_OUTPUT_SCHEMA
      },
      pathToClaudeCodeExecutable: findClaudeExecutable()
      // Don't load project CLAUDE.md - agent has its own instructions
    };
    this.session = this.query({ prompt, options });
    for await (const message of this.session) {
      if (message.type === "system" && message.subtype === "init") {
        this.sessionId = message.session_id;
        logInfo(AGENTS.QUEUE_PROCESSOR, `Session started with ID ${this.sessionId}`);
      }
      if (message.type === "result" && message.subtype === "success") {
        break;
      }
    }
    return this.session;
  }
  /**
   * Send a message to the agent and get structured response
   */
  async sendToAgent(message, isRetry = false) {
    await this.initSDK();
    const options = {
      model: "opus",
      systemPrompt: QUEUE_PROCESSOR_SYSTEM_PROMPT,
      resume: this.sessionId,
      canUseTool: async (toolName, input) => {
        if (toolName === "AskUserQuestion") {
          return {
            behavior: "deny",
            message: "This tool is not available. Process the entry based on your analysis."
          };
        }
        return { behavior: "allow", updatedInput: input };
      },
      outputFormat: {
        type: "json_schema",
        schema: QUEUE_PROCESSOR_OUTPUT_SCHEMA
      },
      pathToClaudeCodeExecutable: findClaudeExecutable()
    };
    try {
      const session = this.query({ prompt: message, options });
      let structuredOutput = null;
      for await (const msg of session) {
        if (msg.type === "result" && msg.subtype === "success") {
          structuredOutput = msg.structured_output || null;
        }
      }
      return structuredOutput;
    } catch (err) {
      if (err.message && err.message.toLowerCase().includes("context") && !isRetry) {
        logWarn(AGENTS.QUEUE_PROCESSOR, "Context exhaustion detected, resetting session");
        this.resetSession();
        return this.sendToAgent(message, true);
      }
      throw err;
    }
  }
  /**
   * Process a single queue entry
   */
  async processEntry(entry, isRetry = false) {
    logInfo(AGENTS.QUEUE_PROCESSOR, `Processing queue entry ${entry.id} [${entry.entry.category}]`);
    try {
      await this.getSession();
      const prompt = `Process this knowledge entry:

Category: ${entry.entry.category}
Content: ${entry.entry.content}

Timestamp: ${entry.timestamp}
ID: ${entry.id}

Analyze this against existing knowledge and take the appropriate action.`;
      const result = await this.sendToAgent(prompt);
      if (result) {
        logInfo(AGENTS.QUEUE_PROCESSOR, `Entry ${entry.id} processed: ${result.action}${result.file_modified ? ` -> ${result.file_modified}` : ""}`);
      }
      return result || {
        status: "processed",
        action: "added",
        file_modified: null,
        ready_for_next: true
      };
    } catch (err) {
      if (err.message && err.message.toLowerCase().includes("context") && !isRetry) {
        logWarn(AGENTS.QUEUE_PROCESSOR, "Context exhaustion detected in processEntry, resetting session");
        this.resetSession();
        return this.processEntry(entry, true);
      }
      logError(AGENTS.QUEUE_PROCESSOR, `Error processing entry ${entry.id}: ${err.message}`);
      throw err;
    }
  }
  /**
   * Process all pending queue entries
   */
  async processQueue() {
    if (this.isProcessing)
      return;
    this.isProcessing = true;
    try {
      const queueDir = path2.join(this.projectRoot, QUEUE_DIR);
      if (!fs2.existsSync(queueDir)) {
        this.isProcessing = false;
        return;
      }
      const files = fs2.readdirSync(queueDir).filter((f3) => f3.endsWith(".json")).sort();
      if (files.length === 0) {
        this.isProcessing = false;
        return;
      }
      logInfo(AGENTS.QUEUE_PROCESSOR, `Starting queue processing: ${files.length} entries`);
      for (const file2 of files) {
        const filePath = path2.join(queueDir, file2);
        try {
          const content = fs2.readFileSync(filePath, "utf8");
          const entry = JSON.parse(content);
          if (entry.status !== "pending")
            continue;
          entry.status = "processing";
          entry.processingStartedAt = Date.now();
          fs2.writeFileSync(filePath, JSON.stringify(entry, null, 2));
          const result = await this.processEntry(entry);
          if (result.ready_for_next) {
            fs2.unlinkSync(filePath);
          } else {
            entry.status = "pending";
            entry.lastError = "Agent not ready for next";
            fs2.writeFileSync(filePath, JSON.stringify(entry, null, 2));
            logWarn(AGENTS.QUEUE_PROCESSOR, `Entry ${entry.id} marked for retry: agent not ready`);
          }
        } catch (err) {
          logError(AGENTS.QUEUE_PROCESSOR, `Error processing queue entry ${file2}: ${err.message}`);
          try {
            const content = fs2.readFileSync(filePath, "utf8");
            const entry = JSON.parse(content);
            entry.status = "pending";
            entry.lastError = err.message;
            fs2.writeFileSync(filePath, JSON.stringify(entry, null, 2));
          } catch (e2) {
          }
        }
      }
      logInfo(AGENTS.QUEUE_PROCESSOR, "Queue processing completed");
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Reset the session (called on context exhaustion)
   */
  resetSession() {
    logInfo(AGENTS.QUEUE_PROCESSOR, `Resetting session${this.sessionId ? ` (previous ID: ${this.sessionId})` : ""}`);
    this.session = null;
    this.sessionId = null;
  }
};
var queueProcessor = null;
async function handleRemember(params) {
  const { category, topic, details, files } = params;
  if (!category || typeof category !== "string" || category.trim().length === 0) {
    throw new Error("Category is required and must be a non-empty string");
  }
  if (!topic || typeof topic !== "string" || topic.trim().length === 0) {
    throw new Error("Topic is required and must be a non-empty string");
  }
  if (!details || typeof details !== "string" || details.trim().length === 0) {
    throw new Error("Details is required and must be a non-empty string");
  }
  const normalizedCategory = normalizeCategory(category.trim().toLowerCase());
  const projectRoot = getProjectRoot();
  const queueDir = path2.join(projectRoot, QUEUE_DIR);
  ensureDir(queueDir);
  const timestamp = Date.now();
  const id = generateShortId();
  const entry = {
    id,
    timestamp,
    status: "pending",
    entry: {
      category: normalizedCategory,
      topic: topic.trim(),
      details: details.trim(),
      files: files ? files.trim() : null
    }
  };
  const filename = `${timestamp}-${id}.json`;
  const filepath = path2.join(queueDir, filename);
  fs2.writeFileSync(filepath, JSON.stringify(entry, null, 2));
  logInfo(AGENTS.MCP_SERVER, `Entry queued: ${id} [${normalizedCategory}] ${topic}`);
  const activation = checkMimActivation(projectRoot);
  if (!activation.activated) {
    logInfo(AGENTS.MCP_SERVER, `Entry queued but processing skipped: ${activation.message}`);
    return `\u2713 Remembered: [${normalizedCategory}] ${topic}
(Queued for later - ${activation.message})`;
  }
  if (!queueProcessor) {
    queueProcessor = new QueueProcessor(projectRoot);
  }
  setImmediate(() => {
    queueProcessor.processQueue().catch((err) => {
      logError(AGENTS.MCP_SERVER, `Queue processing error: ${err.message}`);
    });
  });
  return `\u2713 Remembered: [${normalizedCategory}] ${topic}`;
}
function normalizeCategory(category) {
  const categoryMap = {
    // architecture
    "architecture": "architecture",
    "design": "architecture",
    "structure": "architecture",
    "system": "architecture",
    // patterns
    "patterns": "patterns",
    "pattern": "patterns",
    "convention": "patterns",
    "conventions": "patterns",
    "idiom": "patterns",
    "idioms": "patterns",
    // dependencies
    "dependencies": "dependencies",
    "dependency": "dependencies",
    "deps": "dependencies",
    "packages": "dependencies",
    "libs": "dependencies",
    "libraries": "dependencies",
    // workflows
    "workflows": "workflows",
    "workflow": "workflows",
    "process": "workflows",
    "processes": "workflows",
    "deployment": "workflows",
    "build": "workflows",
    // gotchas
    "gotchas": "gotchas",
    "gotcha": "gotchas",
    "pitfall": "gotchas",
    "pitfalls": "gotchas",
    "bug": "gotchas",
    "bugs": "gotchas",
    "quirk": "gotchas",
    "quirks": "gotchas"
  };
  return categoryMap[category] || category;
}
var REMEMBER_TOOL = {
  name: "remember",
  description: `Capture project discoveries and learnings for persistent documentation. Automatically preserves knowledge about architecture, patterns, workflows, dependencies, and unique behaviors.

\u{1F3AF} USE THIS TOOL when you:
\u2022 Discover how something works in this project
\u2022 Learn project-specific patterns or conventions
\u2022 Find configuration details or requirements
\u2022 Understand architecture or system design
\u2022 Encounter non-obvious behaviors or gotchas
\u2022 Figure out dependencies or integrations
\u2022 Realize your assumptions were incorrect

\u{1F4A1} KEY TRIGGERS - phrases that signal discovery:
"I learned that", "turns out", "actually it's", "I discovered", "for future reference", "good to know", "interesting that"

\u26A1 ALWAYS CAPTURE project-specific knowledge immediately - this creates the persistent memory that survives context resets.

\u2713 Examples: Database schema conventions, API authentication flows, build system quirks
\u2717 Skip: Current bug fixes, temporary debug output, generic programming concepts

Knowledge is automatically deduplicated and organized. Conflicts are queued for human review.`,
  inputSchema: {
    type: "object",
    properties: {
      category: {
        type: "string",
        description: "Category name for organizing this knowledge. Use descriptive categories like: architecture, api, database, pattern, dependency, workflow, config, gotcha, convention, testing, security, deployment, frontend, backend, auth, etc. Any relevant category name is acceptable.",
        examples: ["architecture", "patterns", "dependencies", "workflows", "gotchas", "api", "database", "config", "testing", "security", "auth"]
      },
      topic: {
        type: "string",
        description: 'Brief, descriptive title for what you learned (e.g., "Redis caching strategy", "JWT authentication flow", "MongoDB connection pooling")'
      },
      details: {
        type: "string",
        description: "Complete details of what you discovered. Include specifics, configuration values, important notes, and any context that would help understand this knowledge later."
      },
      files: {
        type: "string",
        description: "Comma-separated list of related file paths where this knowledge was discovered (optional but recommended)",
        examples: ["app.js", "src/auth/jwt.js, src/middleware/auth.js", "config/database.yml"]
      }
    },
    required: ["category", "topic", "details"]
  }
};
async function handleRequest(request) {
  const { id, method, params } = request;
  switch (method) {
    case "initialize":
      return createResponse(id ?? null, {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {}
        },
        serverInfo: {
          name: "mim",
          version: "2.0.0"
        }
      });
    case "notifications/initialized":
      const projectRoot = getProjectRoot();
      const activation = checkMimActivation(projectRoot);
      if (!activation.activated) {
        logInfo(AGENTS.MCP_SERVER, activation.message);
        if (!queueProcessor) {
          queueProcessor = new QueueProcessor(projectRoot);
        }
        return null;
      }
      logInfo(AGENTS.MCP_SERVER, activation.message);
      if (!queueProcessor) {
        queueProcessor = new QueueProcessor(projectRoot);
      }
      recoverStaleQueueEntries(projectRoot);
      setImmediate(() => {
        queueProcessor.processQueue().catch((err) => {
          logError(AGENTS.MCP_SERVER, `Startup queue processing error: ${err.message}`);
        });
      });
      return null;
    case "tools/list":
      return createResponse(id ?? null, {
        tools: [REMEMBER_TOOL]
      });
    case "tools/call":
      const toolParams = params;
      if (toolParams?.name === "remember") {
        try {
          const result = await handleRemember(toolParams.arguments || {});
          return createResponse(id ?? null, {
            content: [
              {
                type: "text",
                text: result
              }
            ]
          });
        } catch (err) {
          return createResponse(id ?? null, {
            content: [
              {
                type: "text",
                text: `Error: ${err.message}`
              }
            ],
            isError: true
          });
        }
      }
      return createError(id ?? null, -32601, `Unknown tool: ${toolParams?.name}`);
    default:
      if (id !== void 0) {
        return createError(id, -32601, `Method not found: ${method}`);
      }
      return null;
  }
}
function main() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
  });
  rl.on("line", async (line) => {
    if (!line.trim())
      return;
    try {
      const request = JSON.parse(line);
      const response = await handleRequest(request);
      if (response) {
        process.stdout.write(response + "\n");
      }
    } catch (err) {
      const errorResponse = createError(null, -32700, "Parse error");
      process.stdout.write(errorResponse + "\n");
    }
  });
  rl.on("close", () => {
    process.exit(0);
  });
}
main();
